{"pages":[],"posts":[{"title":"C函数执行","text":"此篇博文根据斯坦福公开课 《编程范式》整理，来阐述C语言函数执行时，在内存中的简单过程，也算是一个简单的笔记。 函数的活动记录 所谓活动记录，便是C语言程序在调用过程中的储存分配方案的记录。即：当一个过程被调用时，就把它的活动记录推入运行时存储栈的栈顶，而在控制返回调用程序时，再从栈顶弹出相应的活动记录。如此反复，以执行整个程序。 我们首先将内存抽象为一个索引从 0 开始的庞大数组，然后为了方便说明函数的具体执行过程，我们以一段简单的代码作为说明： 1234void foo(int a, int b) { char c[4]; int d;} 当我们写下这样一个函数的时候，在编译过程中，在内存中会如下图这样分配空间： C函数活动记录1.png 在该函数编译之时，以 Save PC 为分界线，内存上半部分依次为形参空间，下半部分为函数中所申明的变量的空间。 注：save PC 我其实并没有搞得很懂，但是按照老师的说法，应当可以理解为函数本身的地址（此处存疑） 函数的执行 为了较为顺畅地理解，我们依旧以示例代码来说明： 123456789int foo(int a) { if (a == 0) return 1; return foo(a-1);}int main() { int n = 3; foo(n);} 此时，编译之时，会像上边一般，在内存中以相同的方式分配空间，然后，函数开始执行： 执行过程会在内存的栈区进行，在调用 foo 函数之后，PC 会直接跳转到 foo 函数所在的内存空间之处，也就是 Save PC 所在，如下图所示： C函数活动记录2.png 由于 foo 函数的形参刚好在其上，所以，参数传递就如此完成了。此后，便会执行 foo 函数中的语句。 有趣的例子 利用上述原理，有这样一个有趣的例子： 1234567891011121314151617181920#include &lt;stdio.h&gt;void createArray() { int array[100]; for (int i = 0; i &lt; 100; i++) array[i] = i;}void printArray() { int array[100]; for (int i = 0; i &lt; 100; i++) printf(\"%d \", array[i]);}int main() { createArray(); // printf(\"Hello\"); printArray(); return 0;} 看到代码，你会有点懵，这不就是打印 0-99 吗？这代码有什么特别呢？然而，你再看看，便会发现两个 array 数组是在两个函数中，这时候你可能会记起当年学的C语言，不同函数中的声明是相互独立的啊？这样写不是脱裤子放屁吗？你就会心有疑虑，对这样是否能够实现相关功能而存疑。 然而，通过上述原理我们知道，函数调用结束之后，只是指针在内存中的跳转，而内容并不会被擦去，所以答案是肯定的，运行代码，会正常输出 0 1 2 3 ...99 。 那么如果在两次调用中加上一句呢？也就是将上面代码的的注释去掉。然后在运行你便会发现不成了，这是因为两次调用中间如果加入了其余语句，便会扰乱前一个函数所初始化的内存，从而使得第二个函数不能正常打印。","link":"/2019/10/04/C%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/"},{"title":"C语言实现简单的泛型","text":"众所周知，C语言是不支持泛型的，但可以利用C语言自身的语法特点来实现此特性。而此篇博文根据斯坦福公开课 《编程范式》整理，以阐述用C语言实现此种特性的大致思路，也算是一个简单的笔记。 从 Swap 谈起 交换函数应该是最常见也是最常用的函数之一，C语言的交换函数一般这样写： 12345void Swap (int *p, int *q) { int tmp = *p; *p = *q; *q = tmp;} 但是如上代码仅能对 int 类型数据进行交换，如果要交换 double 或者其他类型的数据又需要写一段极其相似的代码（仅将 int 换掉），而这样无疑是不够简练的，代码也不够优美。所以我们考虑写一个能交换所有数据类型的函数，以简练代码，提高效率。 既然有这样的想法，那么我们试着去实现它。既然要普适所以数据类型，那么我们就需要向本源出发去寻找。无论什么类型的数据，在计算机底层都是以二进制储存的，这我们就找到了所有不同类型数据的共同点，也就有了设计思路： 在内存中找到两个数据的地址 从头至尾，将两个数据的每一个字节进行交换 所以结合C语言的语法特点，便有了如下代码： 123456void Swap (void *p, void *q, int size) { char buffer[size]; memcpy(buffer, p, size); memcpy(p, q, size); memcpy(q, buffer, size);} 就代码而言，此一类函数写就的重中之重就是 void 指针的利用，将 void 指针用于形参，以作限定。由于 void * 变量无法直接引用，因为编译器不知道此指针所指变量到底占了几个字节，且因为要适应所有数据类型，所以多传了个参数—— size ，来对传入数据类型所占字节数进行说明。而整段代码原理如下： 传入两个数据在内存中的地址以及数据所占字节数 创建临时变量字符数组 buffer[] 作为中间值（因为一个 char 占1个字节，所以正好采用字符数组来作为中间值） 与正常交换的方式相同，不过是采用 memcpy() 来进直接对内存进行操作，逐个字节进行复制 谈谈 IsSearch() 既然知道了此种思路与写法，那么我们直接看另一个简单的函数——线性查找，以 int 为例，代码是这样的： 123456int IsSearch (int a[], int key, int size) { for (int i = 0; i &lt; size; i++) if (a[i] == key) return i; return -1;} 那么如果使用泛型，代码应该怎样写呢？答案是这样的： 12345678void* IsSearch (void* key, void* base, int n, int elemSize){ for (int i = 0; i &lt; n; i++) { void* elemAddr = (char*)base + i*elemSize; if (memcpy(key, elemAddr, elemSize) == 0) return elemAddr; } return NULL;} 整段代码解释如下： 传入需要搜索的值，被搜索数组，数组元素数，数组每个元素所占字节数 进入循环开始查找： 先确定每一个元素的地址（由于 void* 类型的指针不支持直接操作，所以需要先将其进行强制类型转换为 char* 类型指针） 调用库函数，将 key 和数组中的元素依次进行必较 成功则返回数组对应元素的首地址，否则返回NULL 但如果我们不利用库函数来进行比较呢？我们想使用自己写的比较函数来比较，那有应该怎么做呢？（注：这个想法显然必较牵强，因为此时的这种写法无疑是更加合理的，而为了说明知识点，就加了这个想法） （此处 qsort() 课中并未提及）在这里就不得不提一个C语言库函数了，那就是—— qsort() ，一个在调用之时需要写一个针对问题具体情况的比较函数当作参数传入函数之中，而我们这时的情况显然和 qsort() 函数面临的一样，所以我们采用相同的处理方式：传入一个必较函数，来判断两个元素是否一致。 12345678void* IsSearch (void* key, void* base, int n, int elemSize, int (*cmpfn) (void*, void*)){ for (int i = 0; i &lt; n; i++) { void* elemAddr = (char*)base + i*elemSize; if (cmpfn(key, elemAddr) == 0) return elemAddr; } return NULL;} 注：因为 cmpfn() 是调用者写的函数，所以其数据类型是确定的，只需直接比较就行，故只传入两个参数。 调用 IsSearch() 有了普适版（第二版）的代码，其中提供了函数接口，那么调用者应该怎么写这个函数呢？ int 类型数据 比较 int 类型数据的函数，代码如下： 12345int IntCmp (void* n1, void* n2) { int* ip1 = n1; int* ip2 = n2; return (*ip1 - *ip2);} 注：此函数所带参数l类型以及返回值类型需与形参中函数一致 char* (字符串)类型数据 字符串无疑是优雅的，但在C语言中处理字符串，就完全不存在优雅这一说了，因为C语言更加底层，对于字符串的处理不如其他的一些新语言来的形象（当然也是此些语言为字符串处理做了许多预备工作，以至于处理之时只调用已有的函数即可），所以关于字符串的处理可能要更加不易理解，代码如下： 12345int StrCmp (void* vp1, void* vp2) { char* s1 = * (char**)vp1; char* s2 = * (char**)vp2; return strcmp(s1, s2);} 仅看如此代码，会有种毫无头绪的感觉，那么为了更好地理解，我们需要写一下查找字符串时的全过程，代码： 123char* key = \"Li\";char* faName[] = {\"zhang\", \"wang\", \"li\", \"zhao\", \"sun\"};char** found = IsSearch(&amp;key, faName, 5, sizeof(char*), StrCmp); 好，因为单个的 char 是字符，而字符串是 char* ，那么理所当然字符串数组就是 char** 了，所以需要查找之时，传入 IsSearch() 的参数实际上是指针的指针，所以在调用比较函数之时需要进行一次解耦，将之变成两个字符串，而这也就是比较函数前两行的意义所在。 注： 为了比较函数代码美观，所以在传参之时将目标字符串也作为指针的指针传入，如只将其作为指针传入，就无需解耦和了。 在调用之时，用于接收返回值的变量必须是指针的指针，因为返回是个字符串，也就是一个字符指针","link":"/2019/03/05/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%9B%E5%9E%8B/"},{"title":"Fisher线性判别","text":"分类问题 现实世界中，我们常常需要对事物进行分类，而分类的所依据的标准往往是多样的，这尤其体现在使用电脑解决分类问题之时。 我们如果要使用电脑进行分类，首先需要的便是数据。比如：我们需要将两个不同品种的鱼进行分类，我们首先需要根据找不同的方式找出两种鱼在某些特征上的不一致之处（如：长度，宽度，鱼鳍数目、长度等等）。我们将找出来的这些特征构建为一个行向量，同时对每一类都选许多条鱼进行测量，每一条鱼都能得到这样个行向量，将所有行向量拼接起来，构成一个\\(N\\times M\\) 的矩阵（\\(N\\) 为鱼的数目，\\(M\\) 为依据的特征数目），这样就构成了一个简单的有标签的数据集。 有了数据集，接下来所要做的便是分类。什么是分类呢？现实生活中此概念很简单，比如我们买鱼时便有许多选择：鲤鱼，草鱼，带鱼等等等等，而用以区分这些鱼类的，大都是凭经验根据某些特征来区分。其实电脑也一样，分类要做的，就是将两类数据通过一个分类面区分开来，如下粗糙的图所示，分类所做的就是根据已有的数据，找出中间那条红线，将二者分开。 而所谓分类的方法，其归根到底就是利用各种方法，来找到这样一个最佳分类面。而这篇博客所介绍的，仅是所有方法中非常简单的一种——Fisher线性判别。 Fisher线性判别 Fisher 线性判别 是一种简单的二分类方法，其主要思路就是将高维空间的数据进行降维投影至一维空间，从而降低分类的难度。其一般步骤如下： 将高维数据投影到一维平面上 通过运算使得每一类之间更加紧凑（使同一类数据之间的距离变小），两类之间的距离尽可能远，从而方便将两类数据分开。 一般以两类数据中心点的中点最为分类面。 数学原理 显然，Fisher线性判别的重难点在于前两步，即如何找到一个投影面，使得类内距离尽可能小而类间距离尽可能大。 基础概念： 在 d 维的 X 空间中（样本空间）： 各类样本的均值向量\\(m_i\\) ：\\(m_i = \\frac{1}{n_i}\\sum_\\limits{X\\in D_i}{X},\\ i=1,2\\) 样本类内离散矩阵\\(S_i\\)和总样本类内离散度矩阵\\(S_w\\) （其实可以看出来，所谓类内离散度矩阵便是每一个样本与样本均值向量之间的欧氏距离所构成的矩阵） \\[ \\begin{align*} &amp; S_i = \\sum_{X\\in D_i}(x-m_i)(x-m_i)^T,\\ i = 1, 2\\\\ &amp;S_w = S_1+S_2\\\\ \\end{align*} \\] 样本类间离散度矩阵 $ S_b $ （即两类样本均值之间的欧氏距离） \\[ S_b = (m_1-m_2)(m_1-m_2)^T \\] 在 1 维的 Y 空间中（投影空间）： 各类样本的均值 \\(\\tilde{m_i}\\) ：\\(\\tilde{m_i} = \\frac{1}{n_i}\\sum_\\limits{y\\in D_i}{y},\\ i=1,2\\) 样本类内离散度 \\(\\tilde{S_i}\\) 和总样本类内离散度 \\(\\tilde{S_w}\\) \\[ \\begin{align*} \\tilde{S_i} &amp;= \\sum_{y\\in D_i}(y- \\tilde{m_i})(y- \\tilde{m_i})^T,\\ i = 1, 2\\\\ &amp;=\\sum_{y\\in D_i}(y- \\tilde{m_i})^2,\\ i = 1, 2\\\\ \\tilde{S_w} &amp;= \\tilde{S_1}+ \\tilde{S_2}\\\\ \\end{align*} \\] 样本类间离散度： \\[ \\begin{align*} \\tilde{S_b} &amp;= (\\tilde{m_1}-\\tilde{m_2})(\\tilde{m_1}-\\tilde{m_2})^T\\\\ &amp;=(\\tilde{m_1} - \\tilde{m_2})^2 \\end{align*} \\] 接下来要让投影后的类内距离尽可能小而类间距离尽可能大，也就是要使得 \\(\\tilde{S_w}\\) 尽可能小， \\(\\tilde{S_b}\\) 尽可能大，换言之也就是令 \\(\\frac{\\tilde{S_b}}{\\tilde{S_w}}\\) 尽可能取得最大值，我们令其比值为 \\(J(w)\\)，如下式子： \\[ \\begin{align*} J(w) &amp;= \\frac{\\tilde{S_b}}{\\tilde{S_w}}= \\frac{(\\tilde{m_1} - \\tilde{m_2})^2}{\\tilde{S_1}+ \\tilde{S_2}} \\end{align*} \\] 又因为，由各类样本均值可推出： \\[ \\begin{align*} \\tilde{m_i} &amp;= \\frac{1}{n_i}\\sum_\\limits{y\\in D_i}{y}\\\\ &amp;= \\frac{1}{n_i}\\sum_\\limits{X\\in D_i}{w^Tx}\\\\ &amp;= {w^T}(\\frac{1}{n_i}\\sum_\\limits{X\\in D_i}{x})\\\\ &amp;= w^Tm_i \\end{align*} \\] 则，投影样本均值之差可以展开为： \\[ \\begin{align*} (\\tilde{m_1} - \\tilde{m_2})^2 &amp;= (w^Tm_1 - w^Tm_2)^2\\\\ &amp;= w^T(m_1-m_2)(m_1-m_2)^Tw\\\\ &amp;= w^TS_bw \\end{align*} \\] 同理，可将 \\(\\tilde{S_i}\\) 以相同的方式进行变化： \\[ \\begin{align*} \\tilde{S_i} &amp;= \\sum_{y\\in D_i}(y- \\tilde{m_i})^2\\\\ &amp;= \\sum_{X\\in D_i}{(w^Tx-w^Tm_i)^2}\\\\ &amp;= \\sum_{X\\in D_i}{w^T(x-m_2)(x-m_2)^Tw}\\\\ &amp;= w^TS_iw \\end{align*} \\] 则 \\(J(w)\\) 可化为： \\[ \\begin{align*} J(w) &amp;= \\frac{(\\tilde{m_1} - \\tilde{m_2})^2}{\\tilde{S_1}+ \\tilde{S_2}}\\\\ &amp;= \\frac{w^TS_bw}{w^TS_ww} \\end{align*} \\] 之后令分母为非零常数，然后采用拉格朗日乘子法确定最佳变换向量，定义拉格朗日函数如下： \\[ \\begin{align*} L(w, \\lambda) = w^TS_bw-\\lambda (w^TS_ww-c) \\end{align*} \\] 求解过程如下： \\[ \\begin{align*} &amp;\\frac{\\partial L(w,\\lambda)}{\\partial w} = 2S_bw-2\\lambda S_ww =0\\\\ \\\\ 即：\\qquad &amp;S_bw^* = \\lambda S_ww^* \\qquad S^{-1}_wS_bw^* = \\lambda w^*\\\\ \\\\ \\end{align*} \\] \\[ \\begin{align*} w^* &amp;= \\frac{1}{\\lambda}S^{-1}_wS_bw^*\\\\ &amp;= \\frac{1}{\\lambda}S^{-1}(m_1-m_2)(m_1-m_2)^Tw^*\\\\ &amp;= \\frac{R}{\\lambda}S^{-1}(m_1-m_2) \\end{align*} \\] 省去常数，则最后可得 \\(w^* = S^{-1}(m_1-m_2)\\) 数据便可通过向量 \\(w^*\\) 投影至一维平面上，变成一个个点，而要将两类分开，便直接可以找出阈值点 \\(w_0\\) ，将之分开。常用确定方法如下： \\[ \\begin{align*} &amp;w^0 = \\frac{\\tilde{m_1} - \\tilde{m_2}}{2}\\\\ &amp;w_0 = \\frac{n_1\\tilde{m_1} + n_2\\tilde{m_2}}{n_1+n_2} = \\tilde{m}\\\\ &amp;w^0 = \\frac{\\tilde{m_1} - \\tilde{m_2}}{2}+\\frac{ln[P(w_1)/P(w_2)]}{n_1+n_2-2} \\end{align*} \\] 实例验证 要求：在 UCI 数据集上的 Iris和 sonar 数据上验证算法的有效性。【Iris 数据3类，4维，150个数据；Sonar 数据2类，60维，208个样本】 说明：训练和测试样本有三种方式进行划分：（三选一） 将数据随机分训练和测试，多次平均求结果 k折交叉验证 留1法 下载数据集 到 UCI 官网上即可直接下载两个数据集 零碎说明 我选择的是第一种划分方式 为了简便，我使用了 MATLAB 进行编程 开始验证 首先将数据读入，并划分矩阵，此为基础问题，不再赘述 然后，利用 mean() 函数 求每一类样本的均值向量 根据公式，求取训练数据的类内散度矩阵 \\(S_i\\) 和 \\(S_w\\) ，代码实现函数如下： 123456789101112131415function [s] = getScatter(sample, size, m, n1, n2) % getScatter % 计算数据的类内离散度矩阵 s = {zeros(size), zeros(size), zeros(size)}; for i = 1:n1 tmp = sample{i:i}; mi = m{i:i}; for j = 1:n2 xj = tmp(j:j, :); A = (xj-mi); si = A' * A; s{i:i} = s{i:i} + si; end endend 根据公式，求取最佳变换向量 \\(w^*\\) 和阈值 \\(w_0\\) ，代码实现函数如下： 1234567function [w, w0] = bestVector(s1, s2, m1, m2) % bestVector % 求取最佳变换向量 sw = s1 + s2; w = sw \\ ((m1 - m2)'); w0 = (w'*m1' + w'*m2') / 2;end 将样本矩阵在投影方向上投影，以方便进行检验和画图，代码实现如下： 123456789101112131415function [D] = rearProjection(sample, size, i1, i2, w1, n) % rearProjection % 计算投影后的点 D = {zeros(size, 1), zeros(size, 1)}; k = 1; for i = [i1 i2] tmp = sample{i:i}; for j = 1:n(k) xj = tmp(j:j, :); Di = w1' * xj'; D{k:k}(j,1) = Di; end k = k+1; endend 进行检验，我写了两个函数，分别检验两类分的是否正确，代码实现如下： 1234567891011121314function [rate] = testLeft(class, i, n, w1, w0) % test % 检验剩余测试用例 count = 0; for j = i:n xj = class(j:j, :); Di = w1' * xj'; if Di &lt; w0 count = count + 1; end end rate = (count*100)/(n+1-i); fprintf(\"%d/%d = %.2f%%\\n\", count, (n-i+1), rate);end 1234567891011121314function [rate] = testRight(class, i, n, w1, w0) % test % 检验剩余测试用例 count = 0; for j = i:n xj = class(j:j, :); Di = w1' * xj'; if Di &gt; w0 count = count + 1; end end rate = (count*100)/(n+1-i); fprintf(\"%d/%d = %.2f%%\\n\", count, (n-i+1), rate);end 将投影后的数据画出散点图，画图函数如下： 12345678910function [] = drawPicture(x1, x2, n, w0) % drawPicture % 画图函数，分类点为五角星 figure scatter(x1, zeros(n(1), 1), 'o'); hold on scatter(x2, zeros(n(2), 1), 'x'); hold on scatter(w0, 0, 400, 'p');end 结果展示 由于 Fisher 仅用于处理二分类问题，但是，Iris 数据集有三类，所以我仅在两两之间进行了分类。执行完毕后画出的三张散点图如下： Iris1-2.png Iris1-3.png Iris2-3.png Sonar 数据集只有两类，分类后的图像如下： sonar.png","link":"/2019/09/28/Fisher%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB/"},{"title":"C的编译与链接","text":"曾经在初读 CSAPP 之时，我初步了解了 C 语言的全部编译过程，即大概可分为以下三大步： 预处理 编译 链接 今天，又看了节公开课，对这部分有了相对较为深入的理解，并且知道了一些有意思的事情。 开始之前，我们应该有这样一个概念：在使用 gcc 编译器进行编译之时，以上三步在某种意义上来说是相互分离的。 预处理阶段 对于此阶段，我之前所理解的全部，便是曾经所做的笔记： 通过预处理器( cpp ) 处理之后，将其变成了 .i 文件，.i 文件实际上对你写的 .c 文件里以井号 # 开头的语句进行了处理，其发现你引入了某个头文件，于是预处理器便将头文件的内容插入到了你的代码之中。 而如今，我想可以进一步扩展（或许不准确），预处理阶段所处理的内容，实质上就是对 C语言中的宏进行处理，而其中需要处理的部分，即通过宏语法限定的，在程序中有效的宏语言1。其中主要有两大类： #define ：对以 #define 打头的宏定义部分进行替换。 #include：对以 #include 格式引入的库文件进行添加。 #define 最为常见的宏定义，新手常常使用其表示变量，老手便会使用宏来表示一些简单的函数等等： 12#define PI 3.14159 // 新手#define MAX(a,b) ((a)&gt;(b))?(a):(b) // 老手 一般来说，既然已经有了函数，但是还是有许多人使用宏来替代函数，那么必有原因，一般来说，宏的优点主要有以下几点： 同函数一般，简单可复用！同时能够使代码含义更加清晰。 与函数相比，其直接在预处理阶段进行替换，所以其省去了函数调用的时间，所以，我觉得宏适合在下列情境下使用： 函数功能较为简单，只有一行代码，函数调用所花时间对函数功能影响较大 函数需要多次重复使用（不适合有递归的情况） #include 只要学过C语言，想必就不会对此陌生，人生中第一个 hello world 就使用了这个语句，也就是所谓的头文件，头文件的格式有以下两种： #include&lt;&gt; ：以 &lt;&gt; 引用的一般是系统自带的库文件 #include&quot;&quot; ：以 &quot;&quot; 引用的一般是自己写的头文件 此部分无需多叙。 编译阶段 所谓编译，就是将C语言文件编译为汇编文件，以方便计算机执行，而此阶段所做工作的目的是： 将C语言进行初步编译，并对程序进行语法上的一次检查，对不符合语法规则的，进行报错，也就是 Error ，并会停止程序的编译 ；对有争议，或是不明确的内容提出警告 Warning ，但是并不会停止编译，最终还是会生成可执行文件 。 既然如此，那么有这样一个有趣的问题：如果，我们在写代码的时候，不加上头文件，那么该代码是否能通过编译呢？ 示例 有这样一段毫无意义的代码，其目的仅是为了说明上述问题： 1234567891011#include&lt;stdio.h&gt; // printf#include&lt;stdlib.h&gt; // malloc, free#include&lt;assert.h&gt; // assertint main() { void* mom = malloc(400); assert(mom != NULL); printf(\"yeah!\\n\"); free(mom); return 0;} 我们首先将 #include&lt;stdio.h&gt; 注释掉，那么此时，编译到 printf 语句的时候，编译器由于找不到 printf 的声明，于是会提出警告，并将 printf 以默认的方式进行编译——将之认为是一个函数（参数为字符串，返回值为 int ）。 所以在编译阶段，此代码即使去掉了 #include&lt;stdio.h&gt; 头文件，也依旧能够编译成功 链接阶段 链接阶段看似是根据编译的结果进行的，但是却不尽然，因为链接阶段是相对独立的，在链接阶段，编译器会根据编译之后的结果，在库中去依次寻找对应的函数。 所以，上述代码，在编译成功之后，进行链接之时，依旧能够从库中寻找到 printf 函数，并执行成功。也就是说，上述代码，去掉了 #include&lt;stdio.h&gt; 头文件，使用 gcc 编译，能够成功地编译并产生可执行文件，唯一的影响仅是：在编译过程中会产生一条警告信息。我自己实验的结果也同理论相同，结果如下图： C的编译与链接1.png 可以看到，仅产生了一个 warning，并且能够执行成功。 普适与特例 同样地，在去掉 #include&lt;stdlib.h&gt; 之后，也如是。但是，正如上面所说，链接阶段会重新在库函数中寻找函数原型，那么对于所有的库函数，都能够如此吗？ 答案当然是否定的！ #include&lt;assert.h&gt; 头文件之中，assert() 的实现，实质上并不是一个函数，而是一个宏定义，所以如果去掉此头文件，在编译阶段便会将 assert() 解释为一个函数。但是显然，其并非一个函数，那么链接之时便不可能找得到了，所以如此便会出错！验证结果如下： C的编译与链接2.png 意义 乍一看，这种写法好像没什么意义，但是，如果需要追求极度的精简，减小文件体积，这样的写法还是有意义的。事实上，我觉得这种写法，其实是远古时期，内存极度短缺时候的小技巧【实际测试中，其最后产生的可执行文件大小是一样的】。 至于为何会影响文件大小？因为加上头文件之后，在预处理阶段就会将头文件中的所有内容加到你的程序当中，而尽管你只使用了该头文件中的几个函数。而以现在大内存当道的现状，估计很少会有人这么写了。 所以，此技巧更多地还是体现了C语言的 ”自由“，并且还是蛮有趣的。 深入 既然不加头文件，编译器会将其理解为一个函数，那么我们就会想到：我直接在自己的代码中以函数的方式进行声明，那么是不是就不会产生警告了？答案是可行的！2验证如下： 代码改为： 123456789101112#include&lt;stdlib.h&gt; // malloc, free#include&lt;assert.h&gt; // assertint printf(char* s);int main() { void* mom = malloc(400); assert(mom != NULL); printf(\"yeah!\\n\"); free(mom); return 0;} 编译结果如下： C的编译与链接3.png 拓展 有个很有趣的事情，如果不加库，并且利用一个库函数中已有的函数，但是将其参数进行改变（传参数目变多或变少），那么此时程序又会如何被编译，或是产生何种后果？ 比如下面一段代码： 123456int mian() { int num = 65; int length = strlen((char*)&amp;num, num); printf(\"length = %d\\n\", length); return 0;} 话不多说，首先来看编译结果： C的编译和链接4.png 哈哈哈哈哈，报错了，本来还想着正确之后讲述一番教授的思路呢！看来时代变了啊，编译器是变得安全了不少！那这部分也只能提前结束了。 为何说是有效，因为宏拥有一套自己简单的语法，可以控制某段宏是否进行处理，处理几次等操作，所以在此使用了有效的宏语言一词↩ 可以看到，最终编译结果和公开课教授所讲的还是有出入，可能是编译器进化了的缘故吧！毕竟是10 年的公开课↩","link":"/2019/10/04/C%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"},{"title":"LeetCode练习（一）","text":"此系列博文记录自己的刷题过程，一些有意思或者精妙的解答将会被我整理成一篇博文 No.3 无重复字符的最长子串 给定一个字符串，找出不含有重复字符的最长子串的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 无重复字符的最长子串是 &quot;abc&quot;，其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 无重复字符的最长子串是 &quot;b&quot;，其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 无重复字符的最长子串是 &quot;wke&quot;，其长度为 3。 请注意，答案必须是一个子串，&quot;pwke&quot; 是一个子序列 而不是子串。 说明：在看到此题之后，菜鸡的我开始思考如何通过设置一临时字符指针对未重复数字进行复制求长，有了大致思路之后开始胡乱操作，写的代码涂涂改改愣是半天没有结果，我随手百度一手，看到了一个简洁与智慧并存的解决方案，让人五体投地，特来膜拜 算法来源：XDmonkey 的CSDN博客 123456789101112131415int lengthOfLongestSubstring(char* s) { int i, idx = -1, max = 0; int p[256]; memset(p, -1, sizeof(p)); for (i = 0; s[i] != '\\0'; i++) { if (p[s[i]] &gt; idx) idx = p[s[i]]; if (i - idx &gt; max) max = i - idx; p[s[i]] = i; } return max;} 说明： 其首先设置了一个 int 数组p，开辟256空间并初始为-1 ；idx 为辅助变量；max为最小子串的长 循环读入单个字符，判断字符是否出现重复，如果出现重复，也就是 p[s[i]] &gt; idx ，就刷新 idx 值，也就是 i - idx 开始从0重新记录子串长度。不重复则在p数组对应的位置（字符对应ASCII码）更新为 i 的值，同时更新max的值 贴上提交后的分析图： No.3 No.7 反转整数 给定一个 32 位有符号整数，将整数中的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−\\(2^{31}\\), \\(2^{31}\\) − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 说明：此题作为一个简单题，重点就是后面的注意内容，作为一个菜鸡，我的代码是这样判断滴： 1234567891011int reverse(int x) { int s = 0, i = 0; while (x){ if (i == 9 &amp;&amp; (s &gt; 214748364 || s &lt; -214748364)) return 0; s = s * 10 + x % 10; x /= 10; i++; } return s;} 也就是 if 部分，采用判断转换后的前九位与\\(2^{31}\\)的前九位进行比较，来判断是否return 0 提交后运行时间为20ms，之后我有幸看到了8ms的代码，如下： 1234567891011int reverse(int x) { int y=0; while(x){ int temp=y; y=y*10+x%10; if((y-x%10)/10!=temp) return 0; x/=10; } return y;} 嗯，很强，可不是嘛！如果转换后超出，y就会成一个奇怪的数，因此只需在每次y被赋值之后检验其对应位置是否还是x对应位置即可！！！学到了 贴上提交后的分析图： No.7","link":"/2018/10/23/LeetCode%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"pygame初探","text":"想写小游戏的心早就有了，但是一直觉得额外学习一门语言的GUI编程好像不是很划算，今年趁着看了点 python 的内容，所以想试试用python来写，在过程中了解到python有一个专门的库——pygame ，所以就看了点教程，以下权当做个笔记 初识 pygame pygame最小开发框架主要包含两个方面 —— 引入库和初始化，主循环和刷新 引入主要是引入自己要用到的库 初始化主要是初始化窗体，主要包括窗体的大小，窗体的名称，图标等等 主循环主要是接收操作，逻辑判断，事件处理和刷新游戏等 根据教程的壁球小游戏，我直接贴上老师的代码： 初始化部分 1234567891011121314151617181920212223242526import pygame, sysfrom pygame.locals import *# 初始化 pygamepygame.init()# 获取系统屏幕尺寸大小sysSize = pygame.display.Info()size = width, height = 400, 600speed = [1, 1]BLACK = 255, 255, 255# 创建屏幕对象并设定尺寸screen = pygame.display.set_mode(size)# 屏幕大小可调节# screen = pygame.display.set_mode(size, pygame.RESIZABLE)# 屏幕无边框# screen = pygame.display.set_mode(size, pygame.NOFRAME)# 全屏模式# screen = pygame.display.set_mode(sysSize, pygame.FULLSCREEN)# 设置窗体显示 一般为游戏名称pygame.display.set_caption(\"壁球\")icon = pygame.image.load(\"F:\\\\PYG02-ball.gif\")# 设置窗体图标pygame.display.set_icon(icon) 首先，pygame.init()代表初始化pygame，也就是所有用pygame写的第一句代码 之后可以看到初始化部分主要依托于pygame.XXX()的属性设置来完成，具体属性见代码注释 比如：pygame.display.set_mode() 来设置窗体大小 pygame.display.set_caption() 来设置窗体名称 pygame.display.set_icon(icon) 设置窗体图标 等等…… pygame.display.Info() 来获取系统，也就是自己电脑的屏幕尺寸大小 主循环和刷新 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 载入球图片 保存为一个 Surface 对象ball = pygame.image.load(\"F:\\\\PYG02-ball.gif\")# 调用 get_rect() 方法 返回覆盖图像的矩形 Rect 对象# Rect 对象具有 上下左右宽高 等属性ballRect = ball.get_rect()fps = 500fClock = pygame.time.Clock()# while True 为游戏主体循环running = Truewhile running: # 从队列中取出事件 for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() # 按键操控 elif event.type == KEYDOWN: if event.key == K_ESCAPE: running = False elif event.key == K_LEFT: speed[0] = speed[0] if speed[0] == 0 else (abs(speed[0]) - 1) * int(speed[0]/abs(speed[0])) elif event.key == K_RIGHT: speed[0] = speed[0] + 1 if speed[0] &gt; 0 else speed[0] - 1 elif event.key == K_DOWN: speed[1] = speed[1] if speed[1] == 0 else (abs(speed[1]) - 1) * int(speed[1]/abs(speed[1])) elif event.key == K_UP: speed[1] = speed[1] + 1 if speed[1] &gt; 0 else speed[1] - 1 # 如果改变了窗体大小 elif event.type == pygame.VIDEORESIZE: size = width, height = event.size[0], event.size[1] screen = pygame.display.set_mode(size, pygame.RESIZABLE) # 判断窗体是否被最小化 if pygame.display.get_active(): # 调用move方法移动矩形 ballRect = ballRect.move(speed[0], speed[1]) # 判断 反弹 if ballRect.left &lt; 0 or ballRect.right &gt; width: speed[0] = -speed[0] if ballRect.top &lt; 0 or ballRect.bottom &gt; height: speed[1] = -speed[1] # 填充窗口背景 screen.fill(BLACK) # 使小球绘制在矩形框内 screen.blit(ball, ballRect) pygame.display.update() # 控制帧速度 fClock.tick(fps) 载入图片，之后会保存为surface 对象，因此载入的图片可以运用其方法和属性 for event in pygame.event.get(): pygame 中的事件都储存在队列中，需要逐次取出 event.type == KEYDOWN 表示按下某个键，在此判断内，可以进而匹配是按下了什么键 screen.fill(BLACK) 窗口的背景色，直接可以传RGB值 pygame.display.update() 刷新画面，适用于变换场景简单的画面 fClock.tick(fps) 控制帧率","link":"/2018/11/29/pygame%E5%88%9D%E6%8E%A2/"},{"title":"以stack来进一步了解C语言的泛型","text":"此篇博文根据斯坦福公开课 《编程范式》整理，也算是一个简单的笔记。 Stack（栈） 栈是一种十分基础的数据结构，也十分简单，下面我们首先来实现此种数据结构的int表示 stack.h 在此文件之中，我们对栈的结构和栈的基本操作进行了定义，其中代码如下： 12345678910typedef struct { int* elems; int logLength; int allocLength;}stack;void StackNew(stack* s);void StackDispose(stack* s);void StackPush(stack* s, int value);int StackPop(stack* s); stack.c 此文件中，将 .h 文件中的函数进行了实现，代码如下： 123456void StackNew(stack* s) { s-&gt;allocLength = 4; s-&gt;logLength = 0; s-&gt;elems = malloc(sizeof(int)*s-&gt;allocLength); assert(s-&gt;elems != NULL);} 123void StackDispose(stack* s) { free(s-&gt;elems);} 12345678void StackPush(stack* s, int value) { if (s-&gt;logLength == s-&gt;allocLength) { s-&gt;allocLength *= 2; s-&gt;elems = realloc(s-&gt;elems, s-&gt;allocLength*sizeof(int)); assert(s-&gt;elems != NULL); } s-&gt;elems[s-&gt;logLength++] = value;} 1234int StackPop(stack* s) { assert(s-&gt;logLength &gt; 0); return s-&gt;elems[s-&gt;logLength--];} 说明： assert() ：存于 assert.h 头文件之中，其传参为一个布尔值，传入值为true 之时，什么也不做；如果为flase ，就停止继续执行程序并打印错误。用于此处，是为了检测开辟空间是否成功。 StackPush() 函数可以拓展栈的大小 如同之前所讲，有了基本的 int 版，那么就可以向着泛型版转化了。 泛型化的stack 为了向泛型进化，我们必须在原结构体中加入数据类型的字节数，所以结构体结果如下： 1234567891011typedef struct { int* elems; int elemSize; int logLength; int allocLength;}stack;void StackNew(stack* s, int elemSize);void StackDispose(stack* s);void StackPush(stack* s, void* elemAddr);void StackPop(stack* s, void* elemAddr); 同理，各个函数的写法如下： 12345678void StackNew(stack* s, int elemSize) { assert(s-&gt;elems &gt; 0); s-&gt;elemSize = elemSize; s-&gt;allocLength = 4; s-&gt;logLength = 0; s-&gt;elems = malloc(elemSize*s-&gt;allocLength); assert(s-&gt;elems != NULL);} 123void StackDispose(stack* s) { free(s-&gt;elems);} 12345678910111213static void StackGrow(stack *s) { s-&gt;allocLength *= 2; s-&gt;elems = realloc(s-&gt;elems, s-&gt;elemSize * s-&gt;allocLength); assert(s-&gt;elems != NULL);}void StackPush(stack* s, void* elemAddr) { if (s-&gt;logLength == s-&gt;allocLength) StackGrow(s); void* target = (char*)s-&gt;elems + s-&gt;logLength*s-&gt;elemSize; memcpy(target, elemAddr, s-&gt;elemSize); s-&gt;logLength++;} 12345void StackPop(stack* s, void* elemAddr) { int* source = (char*)s-&gt;elems + (s-&gt;logLength - 1) * s-&gt;elemSize; memcpy(elemAddr, source, s-&gt;elemSize); s-&gt;logLength--;} 说明： 值与值之间的传递都依靠参数传递 static 修饰的函数，只在当前文件可以调用（也就是相当于一个内部函数） 关于字符串 众所周知，字符串的传递是与众不同的，所以与其相关的一些问题也需要进行特殊处理，我们先来看一段使用字符串进行栈操作的代码： 1234567891011121314151617int main() { const char* names[] = {\"Bob\", \"Lily\", \"Mike\", \"James\"}; stack* s; char* name; StackNew(s, sizeof(char*)); for(int i = 0; i &lt; 4; i++) { char* copy = strdup(names[i]); StackPush(s, &amp;copy); } for(int i = 0; i &lt; 4; i++) { StackPop(s, &amp;name); printf(\"%s\\n\", name); free(name); } StackDispose(s); return 0;} 由于字符串的长度是不一定的，为了简化代码，因此操作字符串之时在栈中保存的是指向该字符串的指针，但是如此一来便会产生一个问题： 当栈中还有元素之时，用户直接进行StackDispose() 操作之后，并没有释放掉指针所指向的空间，因此我们需要继续改进代码。 而怎样改进呢？首先我们应该让程序知道这个栈到底是什么类型的栈，如果是指针类型的，就要在结构体中传入一个额外的指针，指向栈所指向的地址，以便在之后更好地进行free()，所以将结构体改进如下： 1234567typedef struct { int* elems; int elemSize; int logLength; int allocLength; void (*freefn) (void*);}stack; 而我们在进行 StackNew() 操作之时，就需要对栈的类型进行声明，所以将其传参改进如下： 123456789void StackNew(stack* s, int elemSize; void* freefn(void*)) { assert(s-&gt;elems &gt; 0); s-&gt;freefn = freefn; s-&gt;elemSize = elemSize; s-&gt;allocLength = 4; s-&gt;logLength = 0; s-&gt;elems = malloc(elemSize*s-&gt;allocLength); assert(s-&gt;elems != NULL);} 同时，我们将对 StackDispose() 进行重写： 12345678void StackDispose(stack* s) { if (s-&gt;freefn != NULL) { for (int i = 0; i &lt; s-&gt;logLength; i++) { s-&gt;freefn ((char*)s-&gt;elems + i * s-&gt;elemSize); } } free(s-&gt;elems);} 一般来说，字符串的释放函数应当如下： 123void StrFree(void *s) { free(*(char**)s);}","link":"/2019/03/29/%C2%96%E4%BB%A5stack%E6%9D%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B3%9B%E5%9E%8B/"},{"title":"串","text":"定义：串是由零个或多个字符组成的有限序列，又叫做 字符串 一般记为 S = “\\(a_1a_2......a_n\\)”(n ≥ 0) S : 串的名称 \\(a_1a_2......a_n\\)：串的值 概念解释： 空格串：只包含空格的串，空格串不是空串，其有内容有长度，可不止一个空格 子串与主串：串中任意个数的连续字符组成的子序列称之为该串的子串，包含子串的串称之为主串 子串位置：子串第一个字符在主串中的位置 串的比较 定义： 给定两个串：s= “\\(a_1a_2......a_n\\)”, t = “\\(b_1b_2......b_n\\)”，当满足以下条件之时，s &lt; t： n &lt; m，且 \\(a_i = b_i\\) ( i = 1，2，…，n) 存在某个k ≤ min(m, n) ，使得\\(a_i = b_i\\)（i = 1，2，…，k-1），\\(a_k &lt; b_k\\) 其原理就如同英文字典一样，字典前面的单词总是小于后面的 串的抽象数据类型 类型名称：串（string） 数据对象集：串中元素仅由一个字符组成，相邻元素具有前驱和后继关系 操作集： StrAssign(T,*chars) 生成一个其值等于chars的串T StrCopy(T,S) 由串S复制得到串T StrEmpty(S) 若串为空串返回TRUE否则返回FALSE StrLength(S) 返回s的元素个数称为串的长度 StrCompare(S,T) S&gt;T 返回 &gt;0 ; S=T ,返回 =0 ； ClearString(&amp;S) 将串S清空 SubString(&amp;Sub,S,pos,len) 用sub返回串S的第pos个字符起长度为len的子串 Index(S,T,pos) 若子串中存在和串T值相同的子串，则返回它在主串中第pos个字符之后第一次出的位置 ；否则函数值为0 Replace(&amp;S,T,V) 用V替换串S中出现的所有与T相等的不重叠的子串 StrInsert(&amp;S,pos,T) 在串S的第pos个字符之前插入串T StrDelete(&amp;S,pos,len) 从串S中删除从第pos个字符起出长度为len的子串 DestroyString(&amp;S) 串S被销毁 串的存储结构 顺序存储结构 预定义最大串长度，一般可将串长度值保存在数组的0下标位置，可以方便许多，当然，在C语言中也可通过遍历直到 ‘\\0’ 来计算串的长度 利用堆进行动态存储 由于1方法在串比较小的时侯，浪费空间；而在串比较大时，会发生数据丢失的情况，所以一般多考虑第二种次存储方案 链式存储结构 一般不如顺序存储好用，因为链式存储不可能一个结点只放一个字符，如果那样就会变得无比繁杂，而一个结点存放多少字符，则又需要根据实际情况做出选择，综合来看，其不如顺序存储灵活，性能也不如顺序存储 串的模式匹配算法 串的模式匹配算法为串中特别重要的一个算法 朴素的模式匹配算法","link":"/2018/09/08/%E4%B8%B2/"},{"title":"二分查找","text":"二分查找，显而易见就是每次一分为二的查找方式。其先决条件为必须要在数组中实现，且查找的数据必须已经排序完毕。 首先我们来看一个二分查找库函数的实现： C语言 代码： 1234567891011121314151617181920212223242526/** * * @param key 需要查找的元素 * @param base 查找数组 * @param n 数组大小 * @param elemSize 数组元素字节数 * @param cmpfn 比较函数 * @return */void* BSearch(void* key, void* base, int n, int elemSize, int (*cmpfn) (void*, void*)) { int left = 0, right = n; while (left &lt;= right) { int mid = left + (right - left)/2; void* elemAddr = (char*) base + mid*elemSize; int tmp = cmpfn(key, elemAddr); if (tmp == 0) { return elemAddr; } else if (tmp &lt; 0) { right = mid - 1; } else { left = mid + 1; } } return NULL;} 说明： left + (right - left)/2 此种写法为防止 left + right 的值过大而溢出，所以采用此种写法 写一个函数 LowerBound，在包含 size 个元素的、从小到大排序的 int 数组 a 里查找比给定整数 p 小的，下标最大的元素。找到则返回其下标，找不到则返回-1。 123456789101112131415int LowerBound(int a[],int size,int p) { int L = 0; int R = size - 1; int lastPos = -1; //到目前为止找到的最优解 while( L &lt;= R) { int mid = L+(R-L)/2; if(a[mid] &gt;= p) R = mid - 1; else { lastPos = mid; L = mid + 1; } } return lastPos;} 说明： 1lastPos = mid; L = mid+1; 如上 else 中语句，执行时 mid 处数组的值小于p，所以先将其中的最大值 mid 的下标给 lastPos ，然后寻找比 mid 处值大而比p的值小的数，所以将 mid+1 作为左端点继续操作。 练手 题目： 求下面方程的一个根：\\(f(x) = x^3-5x^2+10x-80 = 0\\)，若求出的根是a，则要求 \\(|f(a)| \\le 10^{-6}\\) 解法： 对 \\(f(x)\\) 求导，得 \\(f'(x)=3x^2-10x+10\\) 。 由一元二次方程求根公式知方程 \\(f'(x)= 0\\) 无解，因此 \\(f'(x)\\) 恒大于0。 故 \\(f(x)\\) 是单调递增的。易知 \\(f(0) &lt; 0\\) 且 \\(f(100)&gt;0\\) ,所以区间 \\([0,100]\\) 内必然有且只有一个根。由于\\(f(x)\\)在 \\([0,100]\\) 内是单 调的，所以可以用二分的办法在区间 \\([0,100]\\) 中寻找根。 代码： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;double EPS = 1e-6;double f(double x) { return x*x*x - 5*x*x + 10*x - 80;}int main() { double root, x1 = 0, x2 = 100,y; root = x1+(x2-x1)/2; int triedTimes = 1; //记录一共尝试多少次，对求根来说不是必须的 y = f(root); while(fabs(y) &gt; EPS) { if(y &gt; 0) x2 = root; else x1 = root; root = x1+(x2 - x1)/2; y = f(root); triedTimes ++; } printf(\"%.8f\\n\",root); printf(\"%d\",triedTimes); return 0;} 说明： 循环条件：fabs(y) &gt; EPS 也就是在精度值达到之后结束循环。","link":"/2018/04/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"title":"二叉搜索树","text":"二叉搜索树（BST，Binary Search Tree）， 也称二叉排序树或二叉查找树 定义：一棵二叉树，可以为空；如果不为空，满足以下性质： 非空左子树的所有键值小于其根结点的键值。 非空右子树的所有键值大于其根结点的键值。 左、右子树都是二叉搜索树。 二叉搜索树操作的一些重要函数 Position Find( ElementType X, BinTree BST )：从二叉搜索树BST 中查找元素X，返回其所在结点的地址； Position FindMin( BinTree BST )：从二叉搜索树BST中查找并返回 最小元素所在结点的地址； Position FindMax( BinTree BST ) ：从二叉搜索树BST中查找并返回 最大元素所在结点的地址。 BinTree Insert( ElementType X, BinTree BST ) ： BinTree Delete( ElementType X, BinTree BST )： 二叉树的搜索 查找从根结点开始，如果树为空，返回NULL 若搜索树非空，则根结点关键字和X进行比较，并进行不同处理： 若X小于根结点键值，只需在左子树中继续搜索； 如果X大于根结点的键值，在右子树中进行继续搜索； 若两者比较结果是相等，搜索完成，返回指向此结点的指针。 递归实现 12345678910Position Find ( ElementType X , BinTree BST ){ // 递归查找 if ( !BST ) return NULL; // 树空 查找失败 if ( X &lt; BST-&gt;Data) // 小于父节点 在左子树中继续查找 return Find ( X , BST-&gt;Left ) ; else if ( X &gt; BST-&gt;Data) // 大于父节点 在右子树中继续查找 return Find ( X , BST-&gt;Right ) ; else // 都不成立 则已经找到 返回找到结点的地址 return BST;} 由于递归实现的效率不高，所以我们可以将此种递归 ——“尾递归”转化为迭代函数 迭代实现 123456789101112Position Find ( ElementType X , BinTree BST ){ // 非递归查找 while ( BST ){ if ( X &lt; BST-&gt;Data ) // 小于父节点 在左子树中继续查找 BST = BST-&gt;Left; else if ( X &gt; BST-&gt;Data ) // 大于父节点 在右子树中继续查找 BST = BST-&gt;Right; else // X == BST-&gt;Data return BST // 都不成立 则已经找到 返回找到结点的地址 } return NULL ;} 查找最大最小元素 根据搜索二叉树特点，我们可以知道： 最大元素一定是在树的最右分枝的端结点上 最小元素一定是在树的最左分枝的端结点上 而且，由普通查找算法可知，查找最大和最小元素也有两种方法 查找的最大和最小只是向左向右有所不同，所以在此仅仅写上查找最大值的两种实现函数 递归函数 12345678osition FindMax ( BinTree BST ){ if ( !BST ) return NULL ; // 空树 返回NULL else if ( !BST-&gt;Right ) return BST; // 右子树为空 直接返回自身 else retuen FindMax (BST-&gt;Right) // 右子树不空 对右子树进行递归} 迭代函数 1234567Position FindMax ( BinTree BST ){ if ( BST ) while ( BST-&gt;Right) BST = BST-&gt;Right ; // 树不空 则直接进行循环查找 直到最右叶节点 return BST;} 二叉搜索树的插入 插入的重点在于找到插入的位置，而找位置的方法也就是Find方法，找到之后将元素插入即可。 代码 12345678910111213BinTree Insert ( ElementType X , BinTree BST ){ if (!BST){ // 空树 生成并返回一个结点的二叉搜索树 BST = malloc(sizeof(struct TreeNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; } else if ( X &lt; BST-&gt;Data ) // 小于 则在树左边插入 BST-&gt;Left = Insert( X , BST-&gt;Left ) ; else if ( X &gt; BST-&gt;Data ) // 大于 就在树右边插入 BST-&gt;Right = Insert( X , BST-&gt;Right ); return BST ;} 注： 第一个 if 语句的两个作用： 刚开始判断是否为空树（第一次传入的树），如果为空树，则创建树 找到插入点后进行插入 二叉搜索树的删除 二叉搜索树的删除主要分为三种情况： 删除叶节点：直接删除，之后将父节点指针置为NULL 删除的结点只有一个子节点：将其父结点的指针指向要删除的结点的子结点 删除的结点有两个完整的子节点，也就是有左右两棵子树： 可以采用另一结点替代被删除结点：左子树最大的元素或者右子树最小的元素，因为只有这样操作，才能在结点删除之后，仍然是一棵完整的二叉搜索树 代码 1234567891011121314151617181920212223242526BinTree Delete ( ElementType X , BinTree BST ){ Position Tmp; if ( !BST ) printf ( \"要删除的元素未找到\" ); else if ( X &lt; BST-&gt;Data ) // 左子树递归删除 BST-&gt;Left = Delet( X , BST-&gt;Left) ; else if ( X &gt; BST-&gt;Data ) // 右子树递归删除 BST-&gt;Right = Delet( X , BST-&gt;Right ); else // 找到需要删除的结点 if ( BST-&gt;Left &amp;&amp; BST-&gt;Right ){ // 删除节点的左右结点都存在 Tmp = FindMin( BST-&gt;Right ) // 寻找右子树中最小值 赋给Tmp BST-&gt;Data = Tmp-&gt;Data; // 找到后赋值给需要删除的结点 将其覆盖 BST-&gt;Right = Delet(BST-&gt;Data , BST-&gt;Right) ; // 在右子树中递归删除 覆盖了原结点的结点 } else { // 左右子树只存在一个或均不存在 Tmp = BST; if ( !BST-&gt;Left ) // 左子树不存在 BST = BST-&gt;Right ; // 将其右子树接到要删除结点的上一个结点 else if ( !BST-&gt;Right ) // 右子树不存在 BST = BST-&gt;Left; // 将其右子树接到要删除结点的上一个结点 free(Tmp); // 释放Tmp } return BST ;}","link":"/2018/08/02/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"二叉树","text":"树 树（Tree）: n（n≥0）个结点构成的有限集合。 当n=0时，称为空树； 对于任一棵非空树（n&gt; 0），它具备以下性质： 树中有一个称为“根（Root）”的特殊结点，用 r 表示； 其余结点可分为m(m&gt;0)个互不相交的有限集T1，T2，… ，Tm，其 中每个集合本身又是一棵树，称为原来树的“子树（SubTree）” 树的一些基本术语 结点的度（Degree）：结点的子树个数 树的度：树的所有结点中最大的度数 叶结点（Leaf）：度为的结点 父结点（Parent）：有子树的结点是其子树 的根结点的父结点 子结点（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也 称孩子结点。 兄弟结点（Sibling）：具有同一父结点的各 结点彼此是兄弟结点。 路径和路径长度：从结点n1到nk的路径为一 个结点序列n1 , n2 ,… , nk , ni是 ni+1的父结 点。路径所包含边的个数为路径的长度。 祖先结点(Ancestor)：沿树根到某一结点路 径上的所有结点都是这个结点的祖先结点。 子孙结点(Descendant)：某一结点的子树 中的所有结点是这个结点的子孙。 结点的层次（Level）：规定根结点在1层， 其它任一结点的层数是其父结点的层数加1。 树的深度（Depth）：树中所有结点中的最 大层次是这棵树的深度。 树的表示 数组？ — 树的分枝是不确定的，因此用数组表示不太方便链表？ 常规表示 劣势：此种链表表示方法由于子结点的个数不确定，因此需要多个结构来实现。 如是直接选取子结点最多的结构来代替所有结构，简化了结构，但会造成资源浪费。 儿子兄弟表示法 链表结构固定，两个指针，第一个指针指向他的第一个儿子，第二个指针指向他旁边的兄弟，如不存在，则指针为空。如下图所示： 二叉树 定义：一个有穷的结点集合，由根结点和称为其左子树T_L和右子树T_R的两个不相交的二叉树组成（非空集合）。也可以说是特殊度为2的树，有左右之分。 相关概念： 叶结点：没有子节点的结点，个数表示为n_0 只有一个子节点的结点，个数表示为n_1 有两个子节点的结点，个数表示为n_2 由左至右分别为：空树 特殊二叉树： 斜二叉树：只有一边的结点 完美二叉树：所有根节点都由两个子结点 完全二叉树：相对于完美二叉树而言，最后一层的子节点可以缺项，但是从上至下从左往右编号时，前面的编号和完美二叉树完全一致 性质： ​ 1. 一个二叉树第i层的最大结点数为：2^(i-1) , i &gt;= 1 2. 深度为k的二叉树有最大的结点总数为：2^k-1 , k &gt;= 1 3. 对于任何非空二叉树，若 n_0 表示叶节点个数，n_2是度为2的非叶节点个数，那么两者之间满足关系 n_0 = n_2 +1 证明：一个二叉树的两个结点之间的连线可以看作一条边，由下往上看，每一个结点都有一条边，除去根节点，所以，节点数 = 边数 + 1 由上往下看，则可以得到如下等式：n_0 + n_1 + n_2 - 1（节点数）= 0 * n_0 + 1 * n_1 + 2 * n_2（边数，由上往下看，结点拥有子节点的个数等于其边数），化简即可证得。 二叉树的存储结构 ### 顺序存储结构： 完全二叉树：从上至下、从左到右的方式进行顺序存储 Q：储存后相关操作是否方便？ A ：方便，相关操作是有规律的 非根节点 (序号 i &gt; 1) 的父节点序号是 [i/2] 结点（序号为 i ）的左孩子结点是 2i （若 2i &lt;= n , 否则没有左孩子） 结点（序号为 i ）的右孩子结点是 2i+1 （若 2i+1 &lt;= n , 否则没有右孩子） 一般二叉树：存储方式同完全二叉树，如结点有缺，则在数组中留出空位 缺点：会造成空间浪费。 链表存储 儿子兄弟表示法 二叉树的遍历 先序遍历：void PreOrderTraversal( BinTree BT )：先序—-根、左子树、右子树； 中序遍历：void InOrderTraversal( BinTree BT )： 中序—左子树、根、右子树； 后序遍历：void PostOrderTraversal( BinTree BT )：后序—左子树、右子树、根 层次遍历：void LevelOrderTraversal( BinTree BT )：层次遍历，从上到下、从左到右 先序遍历 遍历过程为： ​ 1. 访问根节点 2. 先序遍历左子树 3. 先序遍历右子树 1234567void PreOrderTraversal ( BinTree BT){ // 先序遍历 if ( BT ){ printf (\"%d\", BT-&gt;Data); // 输出节点 PreOrderTraversal ( BT-&gt;Left ); //对左边进行递归 PreOrderTraversal ( BT-&gt;Right ); // 对右边进行递归 }} 输出顺序如图所示： 中序遍历 遍历过程为： 1. 中序遍历其左子树； 2. 访问根结点； 3. 中序遍历其右子树。 1234567void InOrderTraversal ( BinTree BT ){ // 中序遍历 if ( BT ){ InOrderTreversal ( BT-&gt;Left ); printf ( \"%d\" , BT-&gt;Data ); InOrderTreversal ( BT-&gt;Right ); }} 输出顺序如图所示：后序遍历遍历过程为： 1. 后序遍历其左子树； 2. 后序遍历其右子树； 3. 访问根结点。 1234567void PostOrderTraversal ( BinTree BT ){ // 后序遍历 if ( BT ){ PreOrderTraversal ( BT-&gt;Left ); //对左边进行递归 PreOrderTraversal ( BT-&gt;Right ); // 对右边进行递归 printf (\"%d\", BT-&gt;Data); // 输出节点 }} 输出顺序如图所示： 以上三种遍历均属于递归遍历 我们可以发现，上述三种遍历，经过节点的路线都是一样的，之时访问节点的时机不同，也就是输出顺序不同。 中序遍历非递归遍历算法： 基本思路：使用堆栈 123456789101112131415void InOrderTraversal ( BinTree BT ){ BinTree T = BT ; // 简化树的变量名 Stack S = CreatStack ( MaxSize ); // 创建并初始化堆栈 while （ T || ! IsEmpty(S) ）{ while ( T ){ Push ( S , T ); // 压栈 T = T-&gt;Left; // 从树左边开始 } if ( ! IsEmpty (S)){ T = Pop(S) ; // 结点弹出堆栈 printf( \"%5d\" , T-&gt;Data ) ; // 输出结点 T = T-&gt;RIght ; // 转向右子树 } }} 中序遍历非递归遍历算法： 递归实际也是一种用堆栈实现的算法，所以两种方式实现是相同的，只不过不用递归，直接采用建立堆栈，用压栈弹栈进行操作而已。 层序遍历 使用队列实现： 123456789101112void LevelOrderTraversal ( BinTree BT ){ Queue Q ; // 创建队列 BinTree T ; // 创建临时二叉树 if ( !BT ) return ; // 是空树则直接返回 AddQ ( Q , BT ) ; while ( !IsEmptyQ (Q) ){ // 循环 直至队列为空 T = DelateQ ( Q ); printf ( \"%d\\n\" , T-&gt;Data ) ; // 访问取出队列的结点 if ( T-&gt;Left ) AddQ( Q , T-&gt;Left ) ; if ( T-&gt;Right ) AddQ( Q , T-&gt;Right ) ; }} 遍历二叉树的应用 输出二叉树中的叶节点 由题意可知，输出叶节点，也就是输出没有没有左右子树的结点，那么我们使用前序便历，在输出之时，检测其是否有左右子树。代码如下： 12345678void PreOrderPrintLeaves( BinTree BT ){ if( BT ){ if ( !BT-Left &amp;&amp; !BT-&gt;Right ) printf(“%d”, BT-&gt;Data ); PreOrderPrintLeaves ( BT-&gt;Left ); PreOrderPrintLeaves ( BT-&gt;Right ); }} 求二叉树的高度 二叉树的高度等于左右子树最高的高度，所以遍历之时添加计数功能。 12345678910int PostOrderGetHeight( BinTree BT ) { int HL, HR, MaxH; if( BT ) { HL = PostOrderGetHeight(BT-&gt;Left); //求左子树的深度 HR = PostOrderGetHeight(BT-&gt;Right); // 求右子树的深度 MaxH = （HL &gt; HR）? HL : HR; // 取左右子树较大的深度 return ( MaxH + 1 ); // 返回树的深度 } else return 0; // 空树深度为0} 二元运算表达树及其遍历 三种遍历得到不同的访问结果 先序遍历得到前缀表达式 中序遍历得到中缀表达式：但是中缀表达式可能由于优先级不同，出现问题 —- 如何解决？ 输出左子树之前加左括号，输出右子树之后加右括号 后序遍历得到后续表达式 由两种遍历序列确定二叉树 Q：可以是任意两种吗？ A：不可以，确定之时必须要有中序遍历，仅仅依靠前序和后序无法确定出一个唯一的树 先序和中序遍历来确定一棵二叉树 分析： 根据先序遍历序列第一个结点确定根结点； 根据根结点在中序遍历序列中分割出左右两个子序列 对左子树和右子树分别递归使用相同的方法继续分解。","link":"/2018/07/29/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"分治","text":"何为分治？简单来说，就是将大的问题分解成小问题进行求解，然后对每个小问题的解进行处理【一般是合并】为大问题的解，下面是分治较为官方的说明： 分治： 把一个任务，分成形式和原任务相同，但规模更小的 几个部分任务（通常是两个部分），分别完成，或只需要选一部完成。然后再处理完成后的这一个或几个 部分的结果，实现整个任务的完成。 斐波那契数列 我想了很多，最后发现还是从这个例子开始说起更加便于理解。 斐波那契数列的定义很简单，其最早的历史来自于那个生兔子的问题。斐波那契数列的解法众多，详细描述可见维基百科，而如果使用数学公式来描述，那么就是这个样子的： \\[ \\begin{equation} \\left\\{ \\begin{array}{**lr**} F_0 = 0 &amp; \\\\ F_1 = 1 &amp; \\\\ F_n = F_{n-1} + F_{n-2} &amp; \\\\ \\end{array} \\right. \\end{equation} \\] 他这种递归的定义方式，其实以初等数学使用暴力求解的思路来说，刚好是符合我们的分治思想的。因为你若将求解 \\(F_4\\) 看作一个大问题，就必须将其分解为两个小一点的子问题，即求解 \\(F_3\\) 和 \\(F_2\\) ，然后再计算二者之和。 那么根据这个递归式，我想只要有点语言基础，都能很快写出一段递归的代码进行求解： 12345678int Fibonacci(int n) { if (n == 0) return 0; if (n == 1) return 1; return Fibonacci(n-1) + Fibonacci(n-2);} 当然，Fibonacci 真正实现的时候不能这么写。 分治范式 大致对分治这种思想有了一个整体认识之后，我们便可以总结出一个求解分治问题的范式： 何时使用分治思想：问题规模太大或者其他原因导致难以直接求解，那么这时候便可以考虑将问题划分为子问题，通过求解子问题来实现原问题最终的求解。 范式的一般步骤： 划分：简单来说，此步骤就是将大问题分解为小问题【注：每个小问题的求解必须一致，不然分治就失去了其原本的意义】。 治理：1也就是对每一个子问题进行求解。 组合：将所有子问题的结果进行合并，得到原问题的解。 分治的分析 分治的性质决定了其与递归联系紧密，所以如果一个问题可以用分治的思想来解决，那么其必然可以转化为一个递归表达式，就如同最开始直接以递归定义的斐波那契数列的表达式一般。而此类问题时间复杂度的详细分析，也往往依靠求解这样的递归式来得到。 归并排序 许多算法都是利用分治思想提出来的，而归并排序无疑是最具代表性的一个，我们可以根据分治范式来一步步分析求解，最终明确这个算法的原理。 划分 两个数之间如何排序【注：此后所说的排序均代表顺序排序】？很显然两两之间比较，小的放左边，大的放右边。 那三个数如何排序？选两个排好之后，再将第三个数与已经排好的两数比较，进而确定第三个数的位置。 四个？此时可以两两排好，然后再合并两个已排序的数组即可。 六十四个？可以分为俩三十二个的，每个三十二个的又可分为俩十六个的…… 如此，我们可以将大问题以对半划分的方式【注：奇数对半，一半比一半多1即可】层层划分，直至不可划分为止，也就是仅剩一个数的时候。而划分，也往往就是递归的过程。 治理 治理，即解决划分后的子问题，划分后的子问题是什么呢？答案就是，一个数的排序。一个数显然无需排序，那么此步骤便无需进行处理。 组合 将子问题的结果组合起来，在此问题中便是，将已排序的两个数组合并为一个已排序的数组。 具体实现 分析清楚之后便可自己尝试写出代码了，首先要写的，便是 组合 部分，C语言代码如下： 1234567891011121314151617181920212223/** - 将数组a的局部a[l,r-1]和a[r,rightEnd]合并到tmp - 然后再拷贝回a[l,rightEnd]**/void merge(int a[], int l, int r, int rightEnd, int tmp[]) { int leftEnd = r - 1; int left = l, count = l; while (l &lt;= leftEnd &amp;&amp; r &lt;= rightEnd) { if (a[l] &lt; a[r]) tmp[count++] = a[l++]; else tmp[count++] = a[r++]; } while (l &lt;= leftEnd) tmp[count++] = a[l++]; while (r &lt;= rightEnd) tmp[count++] = a[r++]; for (int i = left; i &lt; rightEnd+1; i++) a[i] = tmp[i];} 然后，就可以完成划分部分，从而进行排序了。C语言代码如下： 12345678void mergeSort(int a[], int left, int rightEnd, int tmp[]) { if (left &lt; rightEnd) { int mid = left + (rightEnd-left)/2; mergeSort(a, left, mid, tmp); // 划分左半部分 mergeSort(a, mid+1, rightEnd, tmp); // 划分右半部分 merge(a, left, mid+1, rightEnd, tmp); // 组合子问题的解 }} 汉诺塔问题 作为练习，可尝试自己实现一下汉诺塔问题！【待补】 此处按照教科书上（算法技巧与分析【沙特】）来说，此步骤实质上是一种优化复杂度的步骤，但在此，为了简便起见，直接将其写为了子问题的求解。↩","link":"/2019/10/09/%E5%88%86%E6%B2%BB/"},{"title":"初入博客世界","text":"在大佬分享的链接以及自己胡乱操作之后，我的博客终于是搭建完成了，这里附上两个起了主要作用的链接吧！ 知乎 吴润的详细示例 主要的步骤就是依照上述文章进行，但文中仍然有一些小的细节并没有提出 1.安装过程中路径应该使用英文，这也是很多软件安装的必要条件。 使用npm命令安装Hexo，输入： npm install -g hexo-cli 这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入： hexo init blog 注意，这里的命令都是作用在刚刚创建的Blog文件夹中。 2.进行完这步操作之后，Blog文件夹中应该会生成一个blog文件夹，之后的三条命令就需要切换 到blog文件夹之后再进行操作。 为了检测我们的网站雏形，分别按顺序输入以下三条命令： hexo new test_my_site hexo g hexo s 博客园 cherishzy的示例 这一篇，是我在与GitHub关联出错之后搜到的一篇解决方案，而他的一些经验刚好完美解决了我所遇到的问题。 在自己的Github主页右下角,创建一个新的repository。比如我的Github用户名为Gitzhaoyang，那么我创建的repository的名字应该是 gitzhaoyang.github.io 。 添加reponsitories 这里严重注意: 一定要以你的Github用户名.github.io创建。假如我没有用gitzhaoyang.github.io而是用了mungo.github.io，那么当我浏览器访问博客的时候会出现404错误。如果想直接gitzhaoyang.github.io访问，那么就需要和用户名保持一致。题主在这里吃了不小的苦头，最&gt;后给Github客服发邮件才知道原因。 创建好如下图： 一定要保持一致 将本地的文件部署（上传）到Github账户中 编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码（在你修改时，把 gitzhaoyang 要替换成你自己的用户名） deploy: type: git repository: http://github.com/Gitzhaoyang/gitzhaoyang.github.io.git branch: master .yml文件对格式规范要求很严格，type: repository: branch: 前面有两个空格，冒号后面都有一个空格。 通过如上教程与帮助，我搭建完成，并在此写下了我的第一篇博客。","link":"/2018/03/22/%E5%88%9D%E5%85%A5%E5%8D%9A%E5%AE%A2%E4%B8%96%E7%95%8C/"},{"title":"单源最短路径","text":"说明 在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的一条路径 这条路径就是两点之间的最短路径（Shortest Path） 第一个顶点为源点（Source） 最后一个顶点为终点（Destination） 分类： 单源最短路径：从某固定源点出发，求其到其他顶点的最短路径 无权图 有权图 无权图的单源最短路 实现方法：从源点开始，按照非递减的顺序，找出各个顶点的最短路，此类查找类似于图的BFS遍历，但有细微的不同 代码： 1234567891011121314151617void UnWeighted (LGraph graph, int dist[], int path[], Vertex s){ /* dist[] 存距源点的距离 path[] 存通过结点找到此结点的结点 */ Queue Q = CreateQueue(); Vertex v; PtrToAdjVNode w; dist[s] = 0; // 初始化源节点 AddQ(Q, s); while (!IsEmpty(Q)){ v = Delete(Q); for (w = graph-&gt;g[v]-&gt;firstEdge; w; w = w-&gt;next) if (dist[w-&gt;adjv] == -1){ dist[w-&gt;adjv] = dist[v]+1; // 存入此结点到源节点的距离 path[w-&gt;adjv] = v; // 存入上个结点的位置 AddQ(Q, w-&gt;adjv); // 将结点压入队列 } }} 注：上述代码使用过之前应首先将数组dist[]和path[]各位初始化为-1 解析：上述代码实现方式如下： 将源点对应的 dist[s] 更改为0，并将源点压入队列 弹出源点，并对源点连接的所有结点均作如下处理：记录其与源点的距离并存入 dist[] 数组对应的位置，记录源点的下标于 path[] 数组，将结点压入队列 将队头结点弹出，并对其所连结点做与 2 相似处理：记录其与源点的距离并存入 dist[] 数组对应的位置，记录弹出结点的下标于 path[] 数组，将此结点压入队列 重复 3 ，直至图中所有结点全部 进入并被弹出过队列 此算法结束后，如需打印某结点到源结点的最短路径，可以采用栈依靠 path 数组 从此结点开始压栈至源节点，然后依次 pop 打印即可 有权图的单源最短路 有了无权图的单源最短路解决方案，有权图的单源最短路便也显得触手可及了 区别：无权图的最短路即经过顶点最少的路径，而有权图的最短路却并非如此，经过的顶点最少的并不一定是最短路 注意：负值圈的影响：由于权值可为负数，有权图可能出现某一回路权值和为负数，那么为了求权值和最小，就会一直在此回路绕圈子，所以，我们首先讨论权值均非负的情况 实现方法：Dijkstra 算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Vertex FindMinDist(MGraph graph, int dist[], int collected[]){ Vertex minV, v; int minDist = INFINITY; for (v = 0; v &lt; graph-&gt;nv; v++) { if (collected[v] == false &amp;&amp; dist[v] &lt; minDist){ minDist = dist[v]; minV = v; } } if (minDist &lt; INFINITY) return minV; else return ERROR;}bool Dijkstra(MGraph graph, int dist[], int path[], Vertex s){ int collected[MAXSIZE]; Vertex v, w; /* 初始化：邻接表不存在的边用INFINITY表示 */ for (v = 0; v &lt; graph-&gt;nv; v++) { dist[v] = graph-&gt;g[s][v]; if (dist[v] &lt; INFINITY) path[v] = s; else path[v] = -1; collected[v] = false; } /* 先将起点收入集合 */ dist[s] = 0; collected[s] = true; while (1){ /* v = 未被收录顶点中dist最小者 */ v = FindMinDist(graph, dist, collected); if (v == ERROR) // 若v不存在 break; collected[v] = true; // 收录v for (w = 0; w &lt; graph-&gt;nv; w++) // 对图中每个顶点w if (collected[w] == false &amp;&amp; graph-&gt;g[v][w] &lt; INFINITY){ // 若w是v的邻接点并且未被收录 if (graph-&gt;g[v][w] &lt; 0) // 有负边 return false; if (dist[v] + graph-&gt;g[v][w] &lt; dist[w]){ // 收录v使得dist[w]变小 dist[w] = dist[v] + graph-&gt;g[v][w]; // 更新dist[w] path[w] = v; // 更新s到w的路径 } } } return true;} void Dijkstra() 函数主要分为两部分：初始化，正式运行 初始化： 将 dist[] 数组对应值更新为其到源点的权重，如与源结点不直接相连，则更新为 INFINITY 将与源点相连通的结点对应的 dath[] 更新为源点下标，不相连的更新为 -1 将判断结点是否收录的数组 collected[] 全部置为 false 正式运行： 将源点收录集合，即 collected[s] 置为true 通过 FindMinDist() 函数，查找距离源点最近的结点v并将其收录 遍历v的邻接点，更新其对应的 dist[] 值，存在着两个用处： 为邻接点为 INFINITY 的结点赋值 查找是否存在比已有路径更短的路径，如果有，将其更新 循环，直至所有结点均被收录","link":"/2018/10/19/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"title":"图","text":"什么是图（Graph）？ 表示“多对多”的关系 包含： 一组顶点：通常用V（Vertex） 表示顶点集合 一组边：通常用E（Edge）表示边的集合 边是顶点对：（v,w）属于 E ，其中 v,w 属于 V 有向边 &lt;v,w&gt; 表示从v指向w的边（单行线） 不考虑重边和自回路 抽象数据类型定义 类型名称：图（Graph） 数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成。 操作集：对于任意图 G 属于（\\(/in\\)） Graph，以及 v 属于 V, e 属于 E Graph Create()： 建立并返回空图； Graph InsertVertex(Graph G, Vertex v)： 将v插入G； Graph InsertEdge(Graph G, Edge e)： 将e插入G； void DFS(Graph G, Vertex v)： 从顶点v出发深度优先遍历图G； void BFS(Graph G, Vertex v)： 从顶点v出发宽度优先遍历图G； void ShortestPath(Graph G, Vertex v, int Dist[])：计算图G中顶点v到任意其他顶点的最短距离； void MST(Graph G)： 计算图G的最小生成树； …… 图的表示 邻接矩阵： 二维数组直接表示：直接用一个二维数组G[N][N]表示一个图，也就相当于一个方阵，顶点之间是否连接通过1，0 来表示，也就是说G[i][j] 的值为 1 ，说明 i j 两个顶点联通，之间存在边，如果为0，则不连通 二维数组表示的缺点：如此表示无向图（边没有方向）有些浪费空间，G[i][j] 与 G[j][i] 表示的内容是相同的，即i 与 j 之间联通 改进：用长度为 N(N+1)/2 的一维数组A存储 一维数组直接表示法：只取原矩阵的下三角或者上三角矩阵，从左到右从上到下依次存入 如何判断两顶点之间是否联通：我们以下三角矩阵为例，发现二维数组之中的 G[i][j] 对应A的下标为 ( i * (i + 1)/2 + j )，所以，判断 i j 之间是否连通，直接查看对应下标的值即可 建图代码：代码的思路很简单，首先图包括顶点和边，所以我们将之分离，因为顶点的建立很方便，所以我们可以先初始化一个没有边的图，之后再插入边。 有了这个思路，我们首先将数据类型名称重新设定一番，使之可以见名知意 代码：一切之前 12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX_VERTEX_NUM 100 /* 设定数组最大容量 */#define INFINITY 65535 /* 双字节无符号整数最大值 */typedef int Vertex; /* 用顶点下标表示顶点 为整型*/typedef int WeightType; /* 边的权值为整型 */typedef char DataType; /* 顶点储存的数据类型为字符串 */ 接下来我们需要两个结构，也就是边和图的结构 代码：结构的设立 123456789101112131415typedef struct ENode *PtrToENode;struct ENode{ // 边的定义 Vertex V1,V2; // 有向边v1, v2 WeightType Weight; // 权重};typedef PtrToENode Edge;typedef struct GNode *PtrToGNode;struct GNode{ // 图结点的定义 int Nv; // 顶点数 int Ne; // 边数 WeightType G[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; // 邻接矩阵 DataType Data[MAX_VERTEX_NUM]; // 存顶点的数据，此项可根据具体情况省去或添加};typedef PtrToGNode MGraph; 之后创建一个函数，进行图的初始化，也就是只有顶点没有边的图 代码：初始化图 1234567891011/* 初始化有VertexNum个顶点但没有边的图 */MGraph CreateGraph(int VertexNum){ Vertex V, W; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); // 建立图 Graph-&gt;Nv = VertexNum; // 设立顶点数 Graph-&gt;Ne = 0; // 设立边数 for (V = 0; V &lt; Graph-&gt;Nv; V++) for (W = 0; W &lt; Graph-&gt;Nv; W++) Graph-&gt;G[V][W] = INFINITY; // 初始化数组 return Graph; 既然建图之时需要插入边，所以需要一个插入边的函数 代码：插入边 12345/* 插入边 */void InsertEdge(MGraph Grape, Edge E){ Grape-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight; Grape-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight; // 无向图还需反向插入} 准备工作做完之后就可以创建完整的图了 代码：建立完整的图 123456789101112131415161718192021/* 建立完整的图 */MGraph BuildGraph(){ MGraph Graph; Edge E; Vertex V; int Nv, i; scanf(\"%d\", &amp;Nv); // 读入顶点数 Graph = CreateGraph(Nv); scanf(\"%d\", &amp;(Graph-&gt;Ne)); // 输入图的边数 if (Graph-&gt;Ne != 0){ E = (Edge)malloc(sizeof(struct ENode)); // 新建边结点 for (i = 0; i &lt; Graph-&gt;Ne; i++) { // 读入边 // 输入格式 “起点 终点 权重” scanf(\"%d %d %d\", &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); InsertEdge(Graph, E); // 向图中插入边 } } for (V=0; V &lt; Graph-&gt;Nv; V++) // 输入顶点值 若没有顶点值可以不写 scanf(\"%c\", &amp;(Graph-&gt;Data[V])); return Graph;} 邻接矩阵的缺点：面对稀疏图，我们的邻接矩阵就会有些浪费空间了，大量的0占据了大量空间 改进：用邻接表表示 邻接表 G[N] 为指针数组，对应矩阵每行一个链表，只存非0元素，如果是网络，结构之中要增加权重的域 建图代码： 我们的实现方案和邻接矩阵一样，先建立一个只有顶点没有边的图，之后再插入边以形成一个完整的图，所以一些代码完全和邻接矩阵相同 准备工作和定义边的代码与邻接矩阵相同 之后，定义邻接点结构 代码： 1234567/* 邻接点的定义 */typedef struct AdjVNode *PtrToAdjVNode;struct AdjVNode{ Vertex AdjV; //邻接点下标 WeightType Weight; // 边权重 PtrToAdjVNode Next; // 指向下一个邻接点的指针}; 为方便操作，定义表头结点 代码： 12345/* 顶点表头结点的定义 */typedef struct Vnode{ PtrToAdjVNode FirstEdge; // 边表头指针 DataType Data; // 存顶点的数据 /* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */} AdjList[MaxVertexNum]; // AdjList是邻接表类型 重新以邻接表的方式定义图结点 代码： 12345678/* 图结点的定义 */typedef struct GNode *PtrToGNode; struct GNode{ int Nv; // 顶点数 int Ne; // 边数 AdjList G; // 邻接表};typedef PtrToGNode LGraph; 初始化一个只有顶点没有边的初识图 代码： 1234567891011/* 初始化一个有VertexNum个顶点但没有边的图 */LGraph CreateGraph( int VertexNum ) { Vertex V; LGraph Graph; Graph = (LGraph)malloc( sizeof(struct GNode) ); // 建立图 Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; // 初始化邻接表头指针 /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */ for (V=0; V&lt;Graph-&gt;Nv; V++) Graph-&gt;G[V].FirstEdge = NULL; // 初始化 VertexNum 个表头结点，指针为空 return Graph;} 设计插入函数 代码： 123456789101112131415161718void InsertEdge( LGraph Graph, Edge E ) { PtrToAdjVNode NewNode; // 插入边 &lt;V1, V2&gt; /* 为V2建立新的邻接点 */ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; /* 将V2插入V1的表头 */ NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; /* 若是无向图，还要插入边 &lt;V2, V1&gt; */ /* 为V1建立新的邻接点 */ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; // 将V1插入V2的表头 NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;} 写出建立完整图的函数 代码： 12345678910111213141516171819202122LGraph BuildGraph() { LGraph Graph; Edge E; Vertex V; int Nv, i; scanf(\"%d\", &amp;Nv); // 读入顶点个数 Graph = CreateGraph(Nv); // 初始化有Nv个顶点但没有边的图 scanf(\"%d\", &amp;(Graph-&gt;Ne)); // 读入边数 if ( Graph-&gt;Ne != 0 ) { // 如果有边 E = (Edge)malloc( sizeof(struct ENode) ); // 建立边结点 /* 读入边，格式为\"起点 终点 权重\"，插入邻接矩阵 */ for (i=0; i&lt;Graph-&gt;Ne; i++) { scanf(\"%d %d %d\", &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); /* 注意：如果权重不是整型，Weight的读入格式要改 */ InsertEdge( Graph, E ); } } /* 如果顶点有数据的话，读入数据 */ for (V=0; V&lt;Graph-&gt;Nv; V++) scanf(\" %c\", &amp;(Graph-&gt;G[V].Data)); return Graph;} 缺点：此种表示方法缺点多多，首先图一定要足够稀疏才行，否则的话是不如矩阵节省空间的，其次这样表示不方便进行检查两顶点之间是否存在边","link":"/2018/09/07/%E5%9B%BE/"},{"title":"图的遍历","text":"定义：从图中某一顶点出发，访遍图中其余结点，且使每一个顶点仅被访问一次，此过程称之为图的遍历 此文主要介绍两种遍历方法：DFS和BFS 深度优先遍历（DFS – Depth First Search） 深度优先遍历也称之为深度优先搜索，是一种常用的图遍历算法 深度优先遍历实现总的来说就是两句话： 从一顶点开始，在图中进行 ”深入“ —— 即从这个顶点开始，顺着某条边进行遍历 无法 ”深入“ 时，进行 ”回溯“ —— 即若遍历到这条边的终点，则原路返回上一个结点，在此结点进行查询通过此结点所有可以到达的所有结点是否还有未遍历过的结点，再次进行 ”深入“ 可见，此遍历的实现过程描述是一种递归描述，所以首先考虑通过递归的方法进行实现 代码： 12345678void DFS(MGraph graph, int i) { int j; visited[i] = TRUE; printf(\"%5d\", graph-&gt;data[i]); for (j = 0; j &lt; graph-&gt;nv; j++) if (graph-&gt;g[i][j] != 0 &amp;&amp; !visited[j]) DFS(graph, j);} 注： 此代码为邻接数组实现的图的DFS遍历 visited[] 为标记数组，标记某结点是否被遍历到 代码： 123456789void DFS(LGraph graph, Vertex v){ PtrToAdjVNode w; visited[v] = TRUE; printf(\"%5d\", graph-&gt;g[v].data); for (w = graph-&gt;g[v].firstEdge; w; w = w-&gt;next) { if (!visited[w-&gt;adjv]) DFS(graph, w-&gt;adjv); }} 注： 此代码为邻接表实现的图的DFS遍历 visited[] 为标记数组，标记某结点是否被遍历到，使用之前应进行初始化为FALSE 广度优先遍历（BFS – Breadth First Search） 深度优先遍历也称之为深度优先搜索，是最简单的图搜索算法之一 广度优先搜索的实现过程实质就是树的层序遍历，从某一结点开始，将这一结点压入队列，结点出队时，将此结点所有边连接的结点统统压入队列 代码： 1234567891011121314151617181920212223void BFS(MGraph graph){ int i, j; Queue Q; for (i = 0; i &lt; graph-&gt;nv; ++i) visited[i] = FALSE; Q = CreateQueue(MAXSIZE); // 初始化辅助队列 for (i = 0; i &lt; graph-&gt;nv; i++) // 循环每一个顶点 if (!visited[i]){ // 判断是否访问过 visited[i] = TRUE; printf(\"%d\", graph-&gt;data[i]); AddQ(Q, i); while (!IsEmpty(Q)){ // 队列不空 i = Delete(Q); // 取出元素 赋值给i for (j = 0; j &lt; graph-&gt;nv; j++) { if (graph-&gt;g[i][j] == 1 &amp;&amp; !visited[j]){ // 判断其他顶点与当前顶点之间是否存在边且是否被访问 visited[j] = TRUE; printf(\"%d\", graph-&gt;data[j]); AddQ(Q, j); // 将j结点压入队列 } } } }} 两步： 创造辅助队列，并将 i 压入队列 弹出 i ，并将其联通的结点依次压入队列 邻接表实现方式，基本代码相同 代码： 1234567891011121314151617181920212223void BFS(MGraph graph){ int i, j; Queue Q; for (i = 0; i &lt; graph-&gt;nv; ++i) visited[i] = FALSE; Q = CreateQueue(MAXSIZE); // 初始化辅助队列 for (i = 0; i &lt; graph-&gt;nv; i++) // 循环每一个顶点 if (!visited[i]){ // 判断是否访问过 visited[i] = TRUE; printf(\"%d\", graph-&gt;data[i]); AddQ(Q, i); while (!IsEmpty(Q)){ // 队列不空 i = Delete(Q); // 取出元素 赋值给i for (j = 0; j &lt; graph-&gt;nv; j++) { if (graph-&gt;g[i][j] == 1 &amp;&amp; !visited[j]){ // 判断其他顶点与当前顶点之间是否存在边且是否被访问 visited[j] = TRUE; printf(\"%d\", graph-&gt;data[j]); AddQ(Q, j); // 将j结点压入队列 } } } }} 注： 注意指针的指向并深刻理解代码含义即可","link":"/2018/10/15/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"},{"title":"堆","text":"引例：计算机中，经常会遇到这样一个问题——优先级。程序的执行必须要有优先级的确立，而不能仅仅利用程序打开的先后次序，一台电脑，不能因为你新打开了某个巨大的软件，就直接停掉了一个很久之前打开的重要驱动。这显然是不现实的，所以我们可以假设一种序列，取出元素的顺序以优先级大小为准。 优先队列（Priority Queue）：特殊的“队列”，取出元素的顺序是 依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。 既然已经有了这样一个设想，那我们应该采用何种方式来实现呢？ 我们首先会想到以前学过的基本内容，以数组，链表等方式来储存，为了方便判断各种储存方法的优劣，我们将几种方法的时间复杂度进行比较。 普通数组 插入：我们只需要将普通数组的尾部即可 —— 时间复杂度 O(1) 删除：需要从数组中查找最大或最小的元素，进行一次遍历即可 —— 时间复杂度为 O(n) 链表 插入：元素总是插在链表的头部(头插法) —— 时间复杂度 O(1) 删除：同样需要遍历查找查找最大或最小元素 —— 时间复杂度O(1) 有序数组：即在插入时就按照一定顺序插入 插入：找到合适位置 —— 时间复杂度O(n) 或者 O(log n) [二分查找] 移动元素并插入 —— 时间复杂度 O(n) 删除：删去最后一个元素 —— 时间复杂度 O(n) 有序链表：同有序数组插入时按照一定顺序插入 插入：找到合适的位置 —— 时间复杂度为 O(n) 插入元素 —— 时间复杂度 O(1) 删除：删除首元素或者最后的元素 —— 时间复杂度为 O(1) 我们发现，四种表示的时间复杂度基本都是 O(n)，那么可不可以找得到一种表示，降低其时间按复杂度呢？ 树！我们可以用二叉树来表示，平衡二叉树的删除与插入时间复杂度都是与树高有关，为 log(n) 的，所以我们可以考虑用二叉树来表示。 二叉搜索树： 二叉搜索树是很好进行插入 删除操作的，删除时只需要将最左或者最右元素删除。但如果删除元素变多之后，可能会出现树”一边倒“ 的情况，这时会使时间复杂度变大，所以二叉搜索树也不合适。 完全二叉树： 将最大值或者最小值置于根结点处，用完全二叉树来存储，在删除之时就会避免树出现“一边倒”的情况 堆： 堆的两个特性 结构性：用数组表示的完全二叉树； 有序性：任一结点的关键字是其子树所有结点的最大值(或最小值) “最大堆(MaxHeap)”,也称“大顶堆”：最大值 “最小堆(MinHeap)”,也称“小顶堆” ：最小值 堆的抽象数据类型描述： 类型名称：最大堆（MaxHeap） 数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值 操作集：最大堆H 属于 MaxHeap，元素item 属于 ElementType 主要操作有： MaxHeap Create( int MaxSize )：创建一个空的最大堆。 Boolean IsFull( MaxHeap H )：判断最大堆H是否已满。 Insert( MaxHeap H, ElementType item )：将元素item插入最大堆H。 Boolean IsEmpty( MaxHeap H )：判断最大堆H是否为空。 ElementType DeleteMax( MaxHeap H )：返回H中最大元素(高优先级)。 首先应该了解怎样创建一个空的最大堆，但在这之前，我们首先应该设计出合适的结构体来表示堆 代码 123456typedef struct HeapStruct *MaxHeap ;struct HeapStruct{ ElementType *Elements ; // 存储堆元素的数组 int Size ; // 堆当前的元素个数 int Capacity ; // 堆的最大容量}; 重点理解： 两次申请空间：第一次是为整个堆申请一个空间，第二次则是为堆中储存元素的的数组申请空间哨兵的定义：哨兵是为了其他操作方便特意设立的，他是数组的首个元素，存的元素比堆中任何元素值都大 堆中元素的插入 插入分两步： 将元素插入到数组中元素之后，也就是末位，使之符合完全二叉树的结构 调整元素位置，使之成为堆 代码 1234567891011void Insert ( MaxHeap H, ElementType item ){ int i ; if ( isFull(H) ){ printf(\"最大堆已满\"); return ; } i = ++H-&gt;Size ; // i 指向插入后 堆中最后一个元素的位置 for ( ; H-&gt;Elements[i] &gt; H-&gt;Elements[i/2] ; i/=2 ) H-&gt;Elements[i] = H-&gt;Elements[i/2] ; // 向下过滤节点 H-&gt;Elements[i] = item ; // 将item插入} 理解： 代码的主要部分为for循环及之后，for循环在于将新插入至末尾的结点与其父节点进行比较，如新插入节点更大，则将其父节点与其交换位置，即可变为堆。 注意： 交换位置之时，在循环中直接将父节点覆盖子节点，而最后再将新需要插入的结点直接插入到相应位置之中，可以提高效率。 循环之时，如果在堆中不设哨兵，在循环之时还应进行判断，使其循环替换元素之时不能出堆 最大堆的删除 最大堆的删除操作也就是删除掉堆中的最大元素（即树根），并将之返回出去 删除之后堆中会少一个元素，因此我们的思路就是在删除操作进行之时首先将树根元素复制并返回，之后直接将数组最后一个元素将树根元素直接覆盖。那么随之而来的问题肯定就是将元素顺序重新调整为一个堆。 代码 123456789101112131415161718192021ElementType DeleteMax( MaxHeap H ){ int parent, child ; ElementType MaxItem, temp ; if ( IsEmpty(H) ){ printf(\"最大堆已空\") ； return ; } MaxItem = H-&gt;Elements[1] ; // 取出根节点的最大值 temp = H-&gt;Elements[H-&gt;Size--] ; // 将最后一个元素赋给temp for ( parent = 1 ; parent*2 &lt;= H-&gt;Size ; parent = child ){ child = parent * 2 ; if ( (child != H-&gt;Size) &amp;&amp; (H-&gt;Elements[child] &lt; H-&gt;Elements[child+1]) ) child++ ; // 使 child 指向左右结点中较大者 if ( temp &gt;= H-&gt;Elements[child] ) break ; else // 将 temp 元素移动到下一层 H-&gt;Elements[parent] = H-&gt;Elements[child] ; } H-&gt;Elements[parent] = temp ; return MaxItem ;} 理解：代码之中重点就在于重新调整元素，也就是for循环中内容——从根节点开始，依次与最大子结点比较，如果小于就与其交换位置，直至调整好为止。 注：for循环的前一个if是用来调整 child 的，使 child 指向子结点中最大结点，之后就是调整结点元素的过程 最大堆的建立 建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中 我们首先直接想到的就是将n个元素依次直接插入，这时其时间复杂度为O(nlogn) 如果需要压缩时间按复杂度的话，我们可以设计出第二种方法 将N个元素按输入顺序存入，先满足完全二叉树的结构特性 调整各结点位置，以满足最大堆的有序特性。 而此时的时间复杂度如下： 哈夫曼树与哈夫曼编码 什么是哈夫曼树？ 回答这个问题之前首先应该回答这样一个问题 —— 如何根据结点不同的查找频率构造更有效的搜索树？ 答案是采用哈夫曼树 定义： 带权路径长度（WPL）：设二叉树有n个叶子节点，每个叶子节点带有权值 w_k，从根节点到每个叶结点的长度为I_k，则每个叶子结点的带权路径长度之和就是：WPL = $ _{k=1}^{n}w_kl_k $ 哈夫曼树（又称最优二叉树） WPL最小的二叉树 哈夫曼树的构造 每次将权值最小的两棵二叉树合并，合并之后二者根结点权值为两个结点权值之和，再将根节点作为一个新的结点加入序列中再次选取两个最小值 程序如何写呢？此构造的重点在于选出两个最小的元素。，而此操作可以直接借助最小堆来实现。 代码 123456789101112131415HuffmanTree Huffman ( MinHeap H ){ // 假设 H-&gt;Size 个权值已经存在 H-&gt;Elements[]-&gt;Weight 里 int i ; HuffmanTree t ; BuildMinHeap(H) ; // 将H-&gt;Elements[] 按权值调整为最小堆 for ( i = 1 ; i &lt; H-&gt;Size ; i++ ){ // 进行合并 T = mallo( sizeof( struct TreeNode ) ) ; // 建立新结点 T-&gt;Left = DeleteMin(H) ; // 从最小堆中删除一个结点，作为T的左子结点 T-&gt;Right = DeleteMin(H) ; // 从最小堆中删除已一个结点，作为新T的右子结点 T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight ; // 计算新权值 insert( H , T ); // 将新T插入最小堆 } T = DeleteMin(H) ; return T ;} 先将所有元素存入到最小堆中 for 循环之中 先从堆中抽出最小值作为左子结点，再抽出最小值作为右子结点，计算新的权值之后将新结点插入进最小堆 哈夫曼树的特点: 没有度为1的结点； 哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树； n个叶子结点的哈夫曼树共有2n-1个结点； 对同一组权值{w1 ,w2 , …… , wn}，存在不同构的两棵哈夫曼树 哈夫曼编码 Q ：给定一段字符串，如何对其进行编码，使得该字符串编码的储存空间最少？ 我们可以有下列想法： 1. 用等长ASCII编码； 2. 不等长编码：出现频率高的字符用的编码短些，出现频率低的字符则可以编码 显然进行不等长编码的储存空间更小 但是进行不等长编码时容易产生歧义，也就是二义性： 如将下列四字母如下编码： a 编码：0 b 编码：1 c 编码：10 d 编码：11 那么此时给出一段字符串编码：0110，其表达的含义是什么呢？ 当然会产生歧义：abba abc ada 都是可以解释通的，而为了避免此种结果，我们就可以采用哈夫曼编码的方式来解决。","link":"/2018/08/12/%E5%A0%86/"},{"title":"堆栈","text":"堆栈是一种数据项按序排列的数据结构，只能在一端（称为栈顶(top)）对数据项进行插入和删除。 简单地说，堆栈可以看作一个箱子，只能在一端放和取，所以其主要操作有： 插入数据：入栈（Push） 删除数据：出栈（Pop） 而只能一端存取，也形成了其最主要的特性： 后入先出：Last In First Out（LIFO） 类型名称：堆栈（Stack） 数据对象集：一个有0个或多个元素的有穷线性表 操作集：长度为 MaxSize 的堆栈 S 属于 Stack ， 堆栈元素 item 属于 ElementType 123451. Stack CreateStack () 生成空堆栈2. int IsFull (Stack S) 判断堆栈S是否已满3. void Push (Stack PtrS, ElementType item) 将元素item压入堆栈4. int IsEmpty (Stack S) 判断堆栈S是否为空5. ElementType Pop (Stack PtrS) 删除堆栈并返回栈顶元素 栈的顺序储存实现 所谓顺序存储，也就是利用数组来实现栈的相关操作，那么根据之前的叙述，我们可以写出栈库的头文件 Stack.h C语言代码： 1234567891011121314151617181920212223#ifndef DATA_STRUCTURE_STACK_H#define DATA_STRUCTURE_STACK_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int elementType;typedef struct SNode* stack;struct SNode{ int* stack; // 栈元素所在的数组 int allocLength; // 栈的大小 int top; // 栈顶下标};stack createStack();void push (stack s, int val);elementType pop (stack s);bool isFull(stack s);bool isEmpty(stack s);#endif //DATA_STRUCTURE_STACK_H 说明： 栈所在结构体，为了使其大小可扩展，所以将 stack[] 数组以指针的方式替换，同时增加了一个用于保存栈大小的元素，即 allocLength 接下来在 Stack.c 中实现所定义的函数。 C语言代码： 1234567891011121314151617181920212223242526272829303132333435/* * Created by wenmang on 2019/7/22. */#include &lt;assert.h&gt;#include \"Stack.h\"stack createStack() { stack s = (stack) malloc(sizeof(struct SNode)); s-&gt;allocLength = 8; // 栈初始空间分配为 8 s-&gt;top = 0; s-&gt;stack = (elementType*) malloc(sizeof(elementType) * s-&gt;allocLength); return s;}void push (stack s, int val) { if (isFull(s)) { s-&gt;allocLength *= 2; s-&gt;stack = (elementType*) realloc(s-&gt;stack, sizeof(elementType) * s-&gt;allocLength); } s-&gt;stack[s-&gt;top++] = val;}elementType pop (stack s) { assert(s-&gt;top &gt;= 0); return s-&gt;stack[s-&gt;top--];}bool isFull(stack s) { return s-&gt;top == s-&gt;allocLength-1;}bool isEmpty(stack s) { return s-&gt;top &lt; 0;} 思考 问：一个数组实现两个堆栈 数组对半分之后分别从左向右储存 缺点：对半分之后，如果右边的数组放满之后左边却未放满，即有空间却无法再储存，就会造成空间浪费 一个从左向右，一个从右向左（改进方法） 对应栈的结构体如下： 12345678typedef struct SNode *Stack;struct DStack{ ElementType Data[MaxSize]; int Top1; int Top2; // 表示栈中元素的下标}S;S.Top1 = -1; // 栈1的初始下标为-1S.Top2 = MaxSize; //栈2的初始下标为MaxSise 压栈 1234567891011void Push(struct DStack *ParS, ElementType item, int Tag){ // 压栈操作 /* Tag 为区分两个堆栈的标志 取值为1和2 */ if (PtrS-&gt;Top2 - PtrS-&gt;Top1 == 1){ printf(\"堆栈满\"); return; } if (Tag == 1) // 压入第一个堆栈 PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item; else // 压入第二个堆栈 PtrS-&gt;Data[--(PtrS-&gt;Top1)] = item;} 弹栈 12345678910111213141516ElementType Pop(struct DStack *ParS, int Tag){ // 弹栈操作 两个栈分别考虑 /* Tag 为区分两个堆栈的标志 取值为1和2 */ if (Tag == 1){ if (PtrS-&gt;Top1 == -1){ printf(\"堆栈1为空\"); return; } else return PtrS-Data[(PtrS-&gt;Top1)--]; } else { if (PtrS-&gt;Top2 == MaxSize){ printf(\"堆栈2为空\"); return NULL; } else return PtrS-&gt;Data[(PtrS-&gt;Top2)++]; }} 堆栈的链式储存实现 链式存储其实我认为就栈而言，并不占什么优势，所以一般顺序实现即可，链式存储的 Stack.h 如下： C语言代码： 1234567891011121314151617181920#ifndef DATA_STRUCTURE_STACK_H#define DATA_STRUCTURE_STACK_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef struct LNode* lStack;struct LNode{ // 链式存储的栈 elementType data; struct LNode* next;};lStack createLStack();void pushL (lStack s, int val);int popL (lStack s);bool isLEmpty(lStack s);#endif //DATA_STRUCTURE_STACK_H 函数实现如下： 1234567891011121314151617181920212223lStack createLStack(){ lStack s = (lStack) malloc(sizeof(struct LNode)); s-&gt;next = NULL; return s;}void pushL (lStack s, int val) { struct LNode* tmp = (lStack) malloc(sizeof(struct LNode)); tmp-&gt;data = val; tmp-&gt;next = s-&gt;next; s-&gt;next = tmp;}elementType popL (lStack s) { assert(s-&gt;next != NULL); int tmp = s-&gt;next-&gt;data; s-&gt;next = s-&gt;next-&gt;next; return tmp;}bool isLEmpty(lStack s) { return s-&gt;next == NULL;} 说明： 链式存储的栈，为方便操作，是带有头指针的。 学习的数据结构就是拿来用的，而如今的许多高级语言，已经将绝大多数数据结构以库的形式封装起来，在使用的时候，我们只需要直接调用即可，而不需要自己再写一个栈。例如 Java 中的 Stack 类，我们在使用的时候如果不熟，则可以查看文档，然后直接调用即可。 在熟悉构成之后，便可以进行应用，比如刷LeetCode","link":"/2019/07/22/%E5%A0%86%E6%A0%88/"},{"title":"多项式的表示","text":"由多项式的表示引出链表概念，因此，首先学习多项式的表示。 ##1.顺序存储的直接表示——数组表示 a[i] 表示，a[i] 的值表示系数，i 表示指数 如：f(x) = 4x^5 - 3x^2 + 1 下标 0 1 2 3 4 5 …… a[i] 1 0 -3 0 0 4 …… 优点：运算简单，两个多项式相加只需将对应分量相加即可。 缺点：遇到0项很多时，浪费空间。 2.顺序储存结构表示非零项——结构数组 数组分量由系数a[i]、指数 i 组成的结构，对应一个非零项 如：P(x) = 9x^12 + 15x^8 + 3x^2 下标 i 0 1 2 …… 系数 a[i] 9 15 3 …… 指数 i 12 8 2 …… 优点：节省空间 相加过程 1.首先将数据按照 i 由小到大排列 2.将两个需要相加的多项式由两个多项式的第一项进行比较，将小的那一项直接作为和多项式的一项，并将此多项式的项向后移动一位。如果两个指数相等，则将其系数相加。 3.链表结构存储非零项——链表 相加过程同结构数组","link":"/2018/05/20/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA/"},{"title":"多源最短路径","text":"知道了单源最短路的算法之后，我们可以更进一步，学习多源最短路问题，因为我们的需求是多样的，我们在知道某点到某点最短距离之后还想知道其他两点间的最短距离，那么我们需要再求解一次吗？显然，那样过于麻烦，显然，我们需要一种算法来一次性求解所有的两两间距，用的时候只需要取出即可 弗洛伊德（Floyd）算法 弗洛伊德算法是比较经典的求解多元路径的算法，代码极为简洁 代码： 123456789101112131415161718typedef int Pathmatirx[MAXSIZE][MAXSIZE];typedef int ShortPathTable[MAXSIZE][MAXSIZE];void ShortestPathFloyd(MGraph graph, Pathmatirx *P, ShortPathTable *D){ int v, w, k; for (v = 0; v &lt; graph-&gt;nv; ++v) for (w = 0; w &lt; graph-&gt;nv; ++w) { // 初始化数组 (*D)[v][w] = graph-&gt;g[v][w]; (*P)[v][w] = w; } for (k = 0; k &lt; graph-&gt;nv; ++k) for (v = 0; v &lt; graph-&gt;nv; ++v) for (w = 0; w &lt; graph-&gt;nv; ++w) if ((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w]){ // 求解 (*D)[v][w] = (*D)[v][k] + (*D)[k][w]; (*P)[v][w] = (*P)[v][k]; }} 算法解释： 首先对传入的两个二维数组进行初始化，将图的存储权重的数组复制给D数组，P数组将每列初始化为列标数 利用三重循环来查找最短路径 k控制中转点，如：k = 0时，所有顶点都经过v0中转；k = 1时，所有顶点都经过v1中转…… 依次判断两个点经过中转点时路径是否会缩短，如果是，更新D数组的权重，P数组相应位置更新为中转点的下标 所以，最后结果为D数组存着某点到某点的最短距离的值，P数组存着相应的某两点之间最短路径所经过的中转点 细节说明： 上述代码直接适用于邻接矩阵存储的图，如是邻接表存储，则初始化部分的代码需重写 12typedef int Pathmatirx[MAXSIZE][MAXSIZE];typedef int ShortPathTable[MAXSIZE][MAXSIZE]; 以上述方式定义之后便于直接将二维数组以参数传递进函数 判断的代码直接带入图中更好理解：v -&gt; w 的距离是否大于v-&gt;k 再由 k-&gt;w的距离之和，以此种方式更容易理解和记忆写出该代码的方树，k是中转点也变得更容易理解 输出结果 运行算法之后，该如何输出某点到某点的最短路径呢？我们直接给出最普遍的方式——打印出所有两两结点间的最短路径 代码： 12345678910111213for (v = 0; v &lt; graph-&gt;nv; ++v) { for (w = v+1; w &lt; graph-&gt;nv; ++w) { printf(\"v%d-v%d weight:%d\", v, w, (*D)[v][w]); k = (*P)[v][w]; printf(\" path: %d\", v); while (k != w){ printf(\" -&gt; %d\", k); k = (*P)[k][w]; } printf(\" -&gt; %d\\n\", w); } printf(\"\\n\");} 算法解释： 首先输出某点到某点以及之间的距离 之后输出路径 在P数组对应位置找到其值k，输出该值之后让其代替初始结点（v）下标 在新的位置找到新的k并赋值，输出，直至 k==w 说明： 该循环直接嵌入上述函数使用","link":"/2018/10/21/%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"title":"平衡二叉树","text":"搜索树中，由于结点插入顺序不同，将导致不同的深度和不同的平均查找长度（ASL） 二叉搜索树一般ASL计算方法：（每层结点个数 * 层数）之和 / 结点个数 平衡因子（Balance Factor BF）： BF(T) = \\(h_L\\) - \\(h_R\\) (注：\\(h_L\\) 和 \\(h_R\\)分别为左右子树的高度) 平衡二叉树（Balance Binary Tree）：AVL树 空树，或者任意结点左右子树高度差绝对值不超过1，即|BF(T)| &lt;= 1 平衡二叉树是为了提升查找效率而提出的一种树的结构，其是基于二叉搜索树的，也就是满足二叉搜索树右大左小的道理。 所以给定节点数为n的AVL树，其最大高度为O(\\(log_2n\\)) AVL树的结构代码： 12345678910/* AVL树的类型 */typedef struct AVLNode *Position;typedef Position AVLTree;struct AVLNode{ ElementType Data; // 结点数据 AVLTree Left; // 左子树 AVLTree Right; // 右子树 int Height; // 树高}; 平衡二叉树要保持平衡态是不容易的，插入一个元素之后，很可能就会破坏平衡，所以为了保证其一直处于平衡态，我们就需讨论在插入元素并破坏平衡态之后如何再次调整为平衡态，同时，还要保证其是二叉搜索树。 平衡二叉树的调整 相关说明： 破坏平衡的结点又可称之为 “麻烦节点” 被破坏平衡的结点又可称之为 “发现者” RR旋转 也就是 “麻烦节点” 在 “发现者” 右子树的右边 调整方式： 将 “发现者” 右子树的根节点提上来代替 “发现者” 的位置，“发现者”连同其左子树作为新的左子树，而 “发现者” 右子树根节点原来的左子树作为 “发现者” 的右子树，右边不变，如图： 代码实现： 调整平衡如上解释，只采用三步即可完成： 将 “发现者” 右子树的根节点提上来代替 “发现者” 的位置，即将 “发现者” 右子树赋值给一个新结点 “发现者” 右子树根节点原来的左子树作为 “发现者” 的右子树，即将“发现者” 右子树根节点原来的左子树赋值给 “发现者” 的右子树 “发现者” 连同其左子树作为新的左子树，即将 “发现者” 赋值给新树树的左节点 1234567891011/* 右单旋 更新高度并返回新结点 B */AVLTree SingRightRotation(AVLTree A){ /* 调整平衡树 */ AVLTree B = A-&gt;Right; A-&gt;Right = B-&gt;Left; B-&gt;Left = A; /* 更新高度 */ A-&gt;Height = Max(A-&gt;Right-&gt;Height, A-&gt;Left-&gt;Height) + 1; B-&gt;Height = Max(B-&gt;Right-&gt;Height, A-&gt;Height) + 1; return B;} LL旋转 也就是 “麻烦节点” 在 “发现者” 左子树的左边 理论以及实现和RR旋转相同，只不过操作位置相反，省去解释 代码： 代码实现的前提：A必须要有一个左子节点B 123456789/* 左单旋 更新高度并返回新结点 B */AVLTree SingleLeftRotation(AVLTree A){ AVLTree B = A-&gt;Left; // 将A左子树给B A-&gt;Left = B-&gt;Right; // 将B的右子树给A 成为新A的左子树 B-&gt;Right = A; // A给B的右子树 A-&gt;Height = Max(A-&gt;Left-&gt;Height, A-&gt;Right-&gt;Height) + 1; B-&gt;Height = Max(B-&gt;Left-&gt;Height, A-&gt;Height) + 1; return B;} LR旋转 也就是 “麻烦结点” 在左子树的右边 对于LR旋转，我们可以将其分为两步： 1. 首先将 “发现者” 的左子树进行RR旋转 再将 “发现者” 本身进行LL旋转，返回即可 示意图如下： ** 代码：** 1234567/* 将B与C做右单旋，C被返回 */AVLTree DoubleLeftRightRotation(AVLTree A){ /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */ A-&gt;Left = SingRightRotation(A-&gt;Left); return SingleLeftRotation(A);} RL旋转 也就是 “麻烦结点” 在右子树的左边 与LR旋转对称，RL仍然何以分为两步： 1. 首先将 “发现者” 的右子树进行LL旋转 2. 再将 “发现者” 本身进行RR旋转，返回即可 代码简略，直接省去 平衡二叉树的插入 解决了平衡二叉树的调整问题，我们便可以方便地讨论其插入问题 问题简单，直接上代码 代码： 1234567891011121314151617181920212223242526272829303132AVLTree Insert(AVLTree T, ElementType X){ if (!T){ // 空树中插入，建立新树 T = (AVLTree)malloc(sizeof(struct AVLNode)); T-&gt;Data = X; T-&gt;Height = 0; T-&gt;Left = T-&gt;Right = NULL; } else if (X &lt; T-&gt;Data){ // 小值 插入左树 T-&gt;Left = Insert(T-&gt;Left, X); if (T-&gt;Left-&gt;Height - T-&gt;Right-&gt;Height == 2) if (X &lt; T-&gt;Left-&gt;Data) // 判断X插入到左边还是右边 // 左子树左边 T = SingleLeftRotation(T); else // 左子树右边 T = DoubleLeftRightRotation(T); } else if (X &gt; T-&gt;Data){ // 大值 插入右树 T-&gt;Right = Insert(T-&gt;Right, X); if (T-&gt;Left-&gt;Height - T-&gt;Right-&gt;Height == -2){ if (X &gt; T-&gt;Right-&gt;Data) // 判断X插入到左边还是右边 // 右子树右边 T = SingleRightRotation(T); else // 右子树左边 T = DoubleRightLeftRotation(T); } } /* else X == T-&gt;Data，无须插入 */ // 更新树高 T-&gt;Height = Max(T-&gt;Left-&gt;Height, T-&gt;Right-&gt;Height) + 1; return T;}","link":"/2018/08/06/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"拓扑排序","text":"拓扑序：如果图中从v到w有一条有向路径，则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序 拓扑排序：获得一个拓扑序的过程就是拓扑排序 AOV如果有合理的拓扑序，则必定是有向无环图 算法原理： 将图中入度为0的顶点输出，或者储存在一数组中 输出之后，将这些结点以及其所在边一同抹掉，即将其连接的下个结点的入度设为0 继续输出新的入度为0的顶点 算法优化： 问题：进行寻找入度为0的结点之时，每次都扫描一次，这时很多都是无用功 优化：用一个容器将所有入度为0的结点装入，每次输出之时只需取出即可 12345678910111213141516171819202122232425262728bool TopSort(LGraph graph, Vertex topOrder[]){ // 拓扑排序 int indegree[MAXSIZE], cnt; Vertex v; PtrToAdjVNode w; Queue Q = CreateQueue(graph-&gt;nv); for (v = 0; v &lt; graph-&gt;nv; ++v) // 初始化indegree[] indegree[v] = 0; for (v = 0; v &lt; graph-&gt;nv; ++v) // 遍历图 得到indegree[] for (w = graph-&gt;g[v].firstEdge; w; w = w-&gt;next) indegree[w-&gt;adjv]++; for (v = 0; v &lt; graph-&gt;nv; ++v) if (indegree[v] == 0) // 将入度为0的顶点入队 AddQ(Q, v); cnt = 0; while (!IsEmpty(Q)){ v = Delete(Q); // 弹出一个入度为0的顶点 topOrder[cnt++] = v; for (w = graph-&gt;g[v].firstEdge; w; w = w-&gt;next) if (--indegree[w-&gt;adjv] == 0) // 将删除v使得w-&gt;adjv入度为0 AddQ(Q, w-&gt;adjv); } if (cnt != graph-&gt;nv) return false; return true;} 代码分析： 定义变量：indegree[MAXSIZE] 值为下标对应结点的入度 初始化 初始化入度数组，使数组所有值均为0 遍历图，将有前驱结点的结点的入度值+1，变为1 将入度为0的结点压入队列 排序 弹出队列中一个结点，装入排序数组中 将该结点的边所指向的结点的入度更改为0，并再次将入度为0的结点入队 判断 如果所有节点都被访问到，则返回true； 否则返回false","link":"/2018/10/28/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"并查集","text":"集合的表示 用树的结构表示集合 用链表，由于集合的操作只需确定元素属于哪个集合，所以采用双亲表示法，孩子的指针指向双亲 用结构数组，data表示元素值，parent表示其父结点下标 集合的运算 集合运算：交、并、补、差，判定一个元素是否属于某一集合 并查集：集合并、查某元素属于什么集合 查找算法： 1234567891011typedef int elementType; // 默认元素可以用非负整数表示typedef int setName; // 默认根结点的下标作为集合名称typedef elementType setType[MAXN]; // 假设集合元素下标从0开始setName Find(setType s, elementType x){ // 寻找元素所在的集合 并返回其根结点下标 if (s[x] &lt; 0) // 找到集合的根 return x; else return s[x] = Find(s, s[x]); // 路径压缩} 路径压缩待学习：—— 并集操作： 123456789void Union(setType s, setName root1, setName root2){ // 进行并集运算 if (s[root2] &lt; s[root1]){ s[root2] += s[root1]; s[root1] = root2; } else { s[root1] += s[root2]; s[root2] = root1; }} 代码分析： 将小一点的集合并入大一点的集合 根节点数组的值为负数，其绝对值表示集合元素数 也就是将其所在根节点值相加，因为元素数变大了；并将小集合的根结点数组值设为大集合数组下标","link":"/2018/08/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"排序进阶","text":"开始之前 进阶排序是对一些特殊情况下排序的处理方式，也是非常重要的一些排序方法 表排序 当数据不再是简单的数字或者字符，而是一些比较大的元素，例如文件等，那么这时在之前介绍的排序中所采取方式就会产生很大的时间复杂度 —— 因为文件的移动是需要时间的，而且需要不短的一段时间，我们普通的排序所采取的不停Swap的操作，就会使时间大大增加 间接排序 那么此时，我们可以采取间接排序的方式，也就是在结构体中添加一个属性，将之进行简单排序，来作为数据的真实顺序 A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 0 1 2 3 4 5 6 7 对table根据key值进行排序即可 A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 3 5 2 1 7 0 4 6 排序完成后结果如上，这时如果要求按顺序输出元素，就可按照A[table[i]] `i取值为0~n-1 物理排序 如果明确要求需要对数据进行物理排序的话，那么我们就可以在表排序的基础之上对数据进行交换 首先我们将A[0]取出，赋给临时值temp，之后寻找A[table[0]]，将之移动到空位上，依次寻找并移动 因有定理：N个数字的排列由若干个独立的环组成，所以我们将每个环都一次移动一遍就好 那么如何判断一个环已经全部排列整齐呢？我们可以将已排列好的环的table值改为A的下标值，所以if(table[i] == i)为true之时，就说明此环已经被排列整齐 物理排序复杂度分析 最好情况：有序，不用交换 最坏情况：每个环都只有两个元素 桶排序 采用传统交换的排序，其时间下限为\\(O(Nlog(N))\\) ，就算是最快的排序也总能找到一个特例，使其最坏时间复杂度为\\(O(Nlog(N))\\) 那么就无法让排序变为线性复杂度吗？ 例：有N(N = 50000)个学生，考试成绩为 0 - 100 ，那么此时将学生的考试成绩排序，怎样排序最快呢？ 这时我们可以采用桶排序，将时间复杂度提升到线性时间： 因为人数极多，而分数只有101种可能，所以我们可以先建立101个桶（指针数组） 遍历每个学生的成绩，将其放在对应的桶下 依次输出每个桶内的学生，排序完成 实现思路 桶排序的一般实现思路： 在数据种类小而数据规模大时使用 为所有可能出现的数据种类建桶，将数据分别放入对应的桶中 从桶中取出并进行之后的操作 那么，如果数据规模不大，但是种类比较多，又该如何操作呢？ 基数排序 假设有10个整数，数字在0到999之间，这时应该怎样使用基数排序呢？ 次位优先法进行排序 在一个数中，个位被称为该数的次位，最高位称为主位 实例说明 例：有数字 64， 8， 216， 512， 27， 729 ，0， 1， 343， 125 因为是十进制数字，所以我们建立0-9十个桶 0 1 2 3 4 5 6 7 8 9 0 1 512 343 64 125 216 27 8 729 第一次排列，根据个位（次位）数字，将之放入相应的桶中 0 1 2 3 4 5 6 7 8 9 0 512 125 343 64 1 216 27 8 729 第二次排列，在第一次的基础上按照十位数字将元素放入相应的桶中 0 1 2 3 4 5 6 7 8 9 0 125 216 343 512 729 1 8 27 64 第三次排列，按照百位数字放入相应的桶中，排序完毕 用的时候，直接将元素按次序从桶中依次取出即可 实现思路 显然，我们首先要知道最高位的位数，以便知晓我们应该进行几趟排序 之后就是每一趟将元素依次放入桶中即可 次位优先 实现需要创建桶的结构体 1234567891011121314#define MAX_DIGIT 4#define REDIX 10/* 桶元素结点 */typedef struct Node* PtrToNode;struct Node{ int key; PtrToNode next;};/* 桶头结点 */struct HeadNode{ PtrToNode head, tail;};typedef struct HeadNode Bucket[REDIX]; REDIX表示需要排序数字的进制，MAX_DIGIT表示排序数字的最高位数 之后，因为要根据每一位的数字来放置，所以需要一个取固定位 数字的函数 12345678int GetDit (int x, int d) { int tmp, i; for (i = 0; i &lt;= d; ++i) { tmp = x % REDIX; x /= REDIX; } return tmp;} 准备工作做完之后，就可以进行排序了 12345678910111213141516171819202122232425262728293031323334353637383940414243void LSDRadixSort (ELEMENT_TYPE a[], int n) { int d, di, i; Bucket bucket; PtrToNode tmp, p, list = NULL; for (i = 0; i &lt; REDIX; ++i) // 初始化桶 bucket[i].head = bucket[i].tail = NULL; for (i = 0; i &lt; n; ++i) { // 将数组逆序存入list链表 tmp = (PtrToNode)malloc(sizeof(struct Node)); tmp-&gt;key = a[i]; tmp-&gt;next = list; list = tmp; } for (d = 1; d &lt;= MAX_DIGIT; ++d) { // 排序 p = list; while (p) { // 将 list 按顺序放入桶中 di = GetDit(p-&gt;key, d); tmp = p; p = p-&gt;next; tmp-&gt;next = NULL; if (bucket[di].head == NULL) bucket[di].head = bucket[di].tail = tmp; else { bucket[di].tail-&gt;next = tmp; bucket[di].tail = tmp; } } list = NULL; for (di = REDIX-1; di &gt;= 0; di--) { // 将桶中数字按顺序放回 list 中 if (bucket[di].head) { bucket[di].tail-&gt;next = list; list = bucket[di].head; bucket[di].head = bucket[di].tail = NULL; } } } for (i = 0; i &lt; n; ++i) { // 将排序完成的list重新赋值给a数组 tmp = list; list = list-&gt;next; a[i] = tmp-&gt;key; free(tmp); }} 主位优先 该算法采用递归的方式实现，初始化部分和之前一致，只是后面有点差异 12345678910111213141516171819202122232425262728293031323334353637383940414243void MSD (ELEMENT_TYPE a[], int l, int r, int d) { int di, i, j; Bucket bucket; PtrToNode tmp, p, list = NULL; if (d == 0) return; for (i = 0; i &lt; REDIX; ++i) bucket[i].head = bucket[i].tail = NULL; for (i = l; l &lt;= r; ++l) { tmp = (PtrToNode)malloc(sizeof(struct Node)); tmp-&gt;key = a[i]; tmp-&gt;next = list; list = tmp; } p = list; while (p) { di = GetDit(p-&gt;key, d); tmp = p; p = p-&gt;next; if (bucket[di].head == NULL) bucket[di].tail = tmp; tmp-&gt;next = bucket[di].head; bucket[di].head = tmp; } i = j = l; for (di = 0; di &lt; REDIX; ++di) { if (bucket[di].head) { p = bucket[di].head; while (p) { tmp = p; p = p-&gt;next; a[j++] = tmp-&gt;key; free(tmp); } MSD(a, i, j-1, d-1); i = j; } }}void MSDRadixSort (ELEMENT_TYPE a[], int n) { MSD(a, 0, n-1, MAX_DIGIT);} 如上 基数排序的应用 在有多个条件之时，可以先按照一个条件将之进行简单的归类，再逐个类进行排序，最后将其合并 总结 排序算法的探究到这里就告一段落了，我们对所有排序的时间复杂度和空间复杂度，以及其是否稳定进行一次统计总结： 排序方法 平均时间复杂度 最坏时间复杂度 额外空间复杂度 稳定性 简单选择排序 \\(O(N^2)\\) \\(O(N^2)\\) \\(O(1)\\) 不稳定 冒泡排序 $O(N^ 2 ) $ \\(O(N^2 )\\) \\(O(1)\\) 稳定 直接插入排序 \\(O(N^ 2)\\) \\(O(N^ 2)\\) \\(O(1)\\) 稳定 希尔排序 \\(O(N^ d)\\) \\(O(N^ 2)\\) \\(O(1)\\) 不稳定 堆排序 \\(O(Nlog N)\\) \\(O(Nlog N)\\) \\(O(1)\\) 不稳定 快速排序 \\(O(Nlog N)\\) \\(O(N^ 2)\\) \\(O(log N)\\) 不稳定 归并排序 \\(O(Nlog N)\\) \\(O(Nlog N)\\) \\(O( N)\\) 稳定 基数排序 \\(O(P(N+B))\\) \\(O(P(N+B))\\) \\(O(N+B)\\) 稳定","link":"/2018/11/15/%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6/"},{"title":"改进排序","text":"在了解了简单排序之后，我们仍不满足简单排序的效率，在此驱动之下，又有效率更高的排序算法被设计出来 希尔排序 在学习了冒泡和插入排序之后，我们发现，对于同一数列而言，采用冒泡排序和采用插入排序所进行的交换次数是一致的，进而可以得知，排序实际是消除逆序对的过程，由此我们可以有以下思路 实现思路 冒泡和插入排序每次只消除一个逆序对 既然排序是为了消除逆序对，那么能不能通过一次交换消除多个逆序对呢 显然，我们可以采用隔几个数字的方式来进行排序，这样一来，进行一次交换就可消除不止一个逆序对 结和以上思路，便实现了希尔排序的一般实现方式 代码1 1234567891011void ShellSort(ELEMENT_TYPE a[], int n) { // 希尔1 int i, j, k; for (i = n/2; i &gt; 0; i /= 2) { for (j = i; j &lt; n; j++) { ELEMENT_TYPE temp = a[j]; for (k = j; k &gt;= i &amp;&amp; a[k - i] &gt; temp; k -= i) a[k] = a[k - i]; a[k] = temp; } }} 简单的希尔排序如上，也就是分别隔n/2``n/4…… 直至n = 1 但是采用这种方法可能出现尴尬的情况 1 9 2 10 3 11 4 12 5 13 6 14 7 15 8 16 1 9 2 10 3 11 4 12 5 13 6 14 7 15 8 16 1 9 2 10 3 11 4 12 5 13 6 14 7 15 8 16 1 9 2 10 3 11 4 12 5 13 6 14 7 15 8 16 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 也就是数列刚好每隔n/2``n/4…… 都是排序完成的，那么扫描就成了无用功 发现上述问题之后，有专家就提出来一个交换间隔的数列 Hibbard 增量序列 \\(D_K\\) = \\(2^k\\) - 1（\\(D_k\\)为间隔数） 最坏情况：\\(T = Θ{(N^{\\frac{2}{3}})}\\) 猜测：\\(T_{avg} = O(N{\\frac{5}{4}})\\) Sedgewick增量序列 {1, 5, 19, 41, 109, …} —— \\(9\\times4^i - 9\\times2^i + 1\\) 或者 \\(4^i - 3\\times2^i + 1\\) 猜想：\\(T_{avg} = O(N^\\frac{7}{6})\\) , \\(T_{worst} = O(N\\frac{4}{3})\\) 则改进后的代码为：（只写Sedgewick） 代码2 1234567891011121314void ShellSort(ELEMENT_TYPE a[], int n) { // 希尔2 int si, i, j, k; int Sedgewick[] = {929, 505, 20, 109, 41, 19, 5, 1, 0}; for (si = 0; Sedgrwick[si] &gt;= N; si++) { for (i = Sedgrwick[si]; i &gt; 0; i = Sedgrwick[++si]) { for (j = i; j &lt; n; j++) { ELEMENT_TYPE temp = a[j]; for (k = j; k &gt;= i &amp;&amp; a[k - i] &gt; temp; k -= i) a[k] = a[k - i]; a[k] = temp; } } } } 堆排序 那么简单排序中的选择排序是否可以优化呢？答案是肯定的 实现思路 首先选择排序的外层循环是不可变的，优化的只能是内层循环，即寻找数列之中最小的元素的过程 选择排序中，此过程运用了遍历数组的方式，复杂度为 \\(O(N)\\) 而在之前，我们学习了堆的知识，所以我们可以利用最小堆来进行寻找 代码1 123456789void HeapSort(ELEMENT_TYPE a[], int n) { // 堆 int i; ELEMENT_TYPE tmpA; BuildHeap(a); for (i = 0; i &lt; n; ++i) tmpA = DeleteMin(a); for (i = 0; i &lt; n; ++i) a[i] = tmpA[i];} 如上代码，首先将a调整为一个最小堆 之后取出依次最小的元素置于一个新临时数组中 最后，将排好序的tmpA数组中的元素复制回原数组 这样，虽然将时间复杂度降到了\\(O(log(n))\\) ，但是空间复杂度提升了一倍，在数据量较大之时应用不是很方便 代码2 123456789void HeapSort(ELEMENT_TYPE a[], int n) { // 堆 int i; for (i = N / 2; i &gt;= 0; --i) PercDown(a, i, n); for (i = 0; i &lt; n; --i) { Swap(&amp;a[0], &amp;a[i]); PercDown(a, i, n); }} 首先通过第一个循环将其建为最大堆 将最大堆的根与a[0]交换，之后再将a调整为最大堆 重复2步骤，n次 由定理可知，其平均比较次数为 \\(2NlogN - O(Nlog(logN))\\) 归并排序 归并排序的核心就是有序子列的归并，也就是将两个已经排好序的数列，归并到一个更大的数列中去 实现思路 分别设立两个指针，从两个数组的开头扫到结尾，比较指针所在处数组的值，将小值复制到大数组中，之后将小值所在数组的指针后移一位 重复步骤一，直至所有数字都挪入大数组 核心理解之后就可以进行排序了，也就是将需排序的数组拆分成若干已排序的小数组直接进行归并 递归代码 1234567891011121314151617181920212223242526272829303132333435363738void Merge(int a[], int l, int r, int rightEnd, int temp[]){ int leftEnd = r-1 ; int left = l, tmp = l; while (l &lt;= leftEnd &amp;&amp; r &lt;= rightEnd){ // 当左右子序列均不空 if (a[l] &gt; a[r]) temp[tmp++] = a[r++]; else temp[tmp++] = a[l++]; } while (l &lt;= leftEnd) temp[tmp++] = a[l++]; while (r &lt;= rightEnd) temp[tmp++] = a[r++]; for (int i = left; i &lt; rightEnd + 1; i++) a[i] = temp[i];}void MergeSort(int a[], int l, int rightEnd, int temp[]) { int center; if (l &lt; rightEnd) { center = (l + rightEnd) / 2; MergeSort(a, l, center, temp); MergeSort(a, center + 1, rightEnd, temp); Merge(a, l, center+1, rightEnd, temp); }}void Merge_sort(int a[], int n){ int* tmpA; tmpA = malloc(n * sizeof(int)); if (tmpA != NULL){ MergeSort(a, 0, n-1, tmpA); free(tmpA); } else { printf(\"ERROR\"); }} 三个函数，分别为归并函数，主函数，和接口函数 归并函数就是将两个有序数组归并为一个大数组 主函数起到将数组左边右边分别进行归并的作用，也就是当数组分割到只有一个元素之后，直接进行归并 接口函数为了使其符合排序函数的规律，仅传入数组及其长度 循环代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void Merge(int a[], int temp[], int l, int r, int rightEnd){ int leftEnd = r-1 ; int left = l, tmp = l; while (l &lt;= leftEnd &amp;&amp; r &lt;= rightEnd){ if (a[l] &gt; a[r]) temp[tmp++] = a[r++]; else temp[tmp++] = a[l++]; } while (l &lt;= leftEnd) temp[tmp++] = a[l++]; while (r &lt;= rightEnd) temp[tmp++] = a[r++]; for (int i = left; i &lt; rightEnd + 1; i++) a[i] = temp[i];}void MergePass(ELEMENT_TYPE a[], ELEMENT_TYPE tmpA[], int n, int length) { int i, j; for (i = 0; i &lt;= n - 2*length; i += 2*length) Merge(a, tmpA, i, i+length, n-1); if (i + length &lt; n) Merge(a, tmpA, i, i+length, n-1); else for (j = i; j &lt; n; j++) tmpA[j] = a[j];}void MergeSort (ELEMENT_TYPE a[], int n) { int length; ELEMENT_TYPE* tmpA; length = 1; tmpA = malloc(n*sizeof(ELEMENT_TYPE)); if (tmpA != NULL) { while (length &lt; n) { MergePass(a, tmpA, n, length); length *= 2; MergePass(a, tmpA, n, length); length *= 2; } free(tmpA); } else { printf(\"空间不足\"); }} 简单的递归可以用循环代替，所以也就有了上面的代码 即先将数组元素，相邻的两个一对进行归并 之后相邻的元素便排序完成，再四个一对进行归并，同理，之后就是八个…… 快速排序 快排是很有名的一个排序算法，在许多语言的库函数中直接调用的排序函数就是快速排序，据说快排是在实际应用中最快的算法，其由归并排序衍生而来，也主要采用递归的方法来实现，其主要原理寻找主元和针对主元对数组进行调整的过程 选主元 主元的选择是快排中至关重要的一个环节，如果主元失误的话就整个排序就容易废掉，那么如何选取主元呢? 随机选择主元，rand() 函数也是需要时间的 取数组头，中，尾三个数字中的中位数 等等 等等…… 这里采取选取三者中位数的方式来选取主元 代码： 123456789101112ELEMENT_TYPE Media3 (ELEMENT_TYPE a[], int left, int right) { int center = (left + right) / 2; if (a[left] &gt; a[center]) Swap(&amp;a[left], &amp;a[center]); if (a[left] &gt; a[right]) Swap(&amp;a[left], &amp;a[right]); if (a[center] &gt; a[right]) Swap(&amp;a[center], &amp;a[right]); Swap(&amp;a[center], &amp;a[right-1]); return a[right-1];} 功能就是将三个数排列，并将中位数置于right-1的位置，并返回主元 子集划分 子集划分主要由两个 “指针” 从两端进行查找，将比主元小的元素调整到数组左边，比主元大的元素调整到数组的右边 之后将主元移动到数组固定的位置 在子集划分之后，采用递归处理， 将数组左边进行快排，右边进行快排 了解了子集划分之后，就又有了新的问题，因为快排的实现方式是采用递归的方法，所以对于小规模数据的排序可能还不如插入排序，所以我们应该设置一个阈值，在数据量低于此阈值的情况下直接采用插入排序 代码： 1234567891011121314151617181920void QSort (ELEMENT_TYPE a[], int left, int right) { int pivot, cutoff = 10000, low, high; if (cutoff &lt;= right - left) { pivot = Media3(a, left, right); low = left; high = right -1; for (; ;) { while (a[++low] &lt; a[right-1]); while (a[--high] &gt; a[right-1]); if (low &lt; high) Swap(&amp;a[low], a[high]); else break; } Swap(&amp;a[low], &amp;a[right-1]); QSort(a, left, low-1); QSort(a, low+1, right); } else InsertionSort(a+left, right-left+1);} 此段代码最精髓之处我觉得是采用两个while循环进行子集划分的操作，很帅 pivot为主元 cutoff为阈值 我将其设为1000 之后对接口进行统一化处理 代码： 123void QuickSort (ELEMENT_TYPE a[], int n){ QSort(a, 0, n-1);}","link":"/2018/11/08/%E6%94%B9%E8%BF%9B%E6%8E%92%E5%BA%8F/"},{"title":"数据在内存中的存储","text":"二进制是计算机的基础，数据的存储在底层看来均是由二进制来表示的，那么如何用二进制来表示各种数据呢？此时就需要设计出一套完整的科学的储存方案 整型数据的存储 整型数据包括 short, int, long 等，其中最为常用的便是 int ，在目前的系统中（32位和64位编译器，以C语言为主要实例），其所占字节如下： 数据类型 所占字节 short 2 int 4 long 8 而整型数据的存储都是类似的，也就是以二进制方式进行存储，所以很容易理解，但是与日常使用的二进制数不同的是，在计算机储存中，为了方便地计算加减法，我们实际储存的是二进制数的 补码1: 示例 下面写几个简单 int 类型数字的在计算机中的二进制储存方式： 十进制 二进制（int） 10 00000000 00000000 00000000 00001010 -10 11111111 11111111 11111111 11110110 0 00000000 00000000 00000000 00000000 注：字符型（即 char）的存储方式和整数型一致，只不过仅占一个字节 浮点型数据的储存 浮点型数据由于有了小数点，小数点后的位数甚至可能是无穷的，那么此时我们就无法再采用和整型数据存储相同的方式了，必须有一种新的存储方法 浮点型数据最常见的有 float 和 double ，两种数据类型分别占4字节和8字节 所以，要在固定的位数中表示出各种浮点数，计算机中采取了如下方案： 下面以 float 为例进行说明： 从左到右：第一个 bit 为符号位，接下来的8个 bit 为整数位，后 23 个 bit 为小数位，依次为\\(2^{-1}, 2^{-2}, ...\\) ,如下图所示： 示意图 所表示的数字，由以下方式叠加：\\((-1)^m * 1.XXXX * 2^{exp-127}\\) 说明： XXX 为小数位所表示的数字 exp 为整数位数字的大小 综上所述，float 可表示从 $2^{-127} $ 到 \\(2^{128}\\)的数字 二进制的表示方式，具体计算方法为：正数补码不变，负数的补码等于反码加一↩","link":"/2019/01/24/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/"},{"title":"数据结构","text":"数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间关系和操作等相关问题的学科。 起源： 1968年，美国高德纳（Donald E. Knuth）教授所写的《计算机程序设计艺术》第一卷《基本算法》中，较为系统地阐述了数据的逻辑结构和存储结构及其操作，开创了数据结构课程体系。 基本概念和术语 数据 描述事物的客观符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 内容： 1. 数值型数据： 整型、实型等（可通过计算机直接进行数值计算） 2. 非数值型数据： 字符，声音、图像、视频等（后三者可以通过编码方式转换成字符数据，进而在计算机上进行处理） 数据元素 组成数据的有一定意义的基本单位，计算机中通常作为整体处理。也被称为记录。 数据项 一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位。 注： 数据项虽为数据不可分割的最小单位，但讨论问题时，数据元素才是数据结构中建立数据模型的着眼点。 数据对象 性质相同的数据元素集合，是数据的子集 数据结构 相互之间之间存在一种或多种特定关系的数据元素的集合。 现实世界中，不同数据元素之间不是独立的，而是存在着特定关系的，我们将这些关系称之为结构。 逻辑结构和物理结构 逻辑结构 是指数据对象中数据元素之间的相互关系。 可分为四种 集合结构 集合结构中的元素除了属于同一集合之外，之间没有其他关系，类似于数学中的集合 线性结构 线性结构中数据元素处于一一对应关系，之间关系图为一条线 树形结构 树形结构中元素存在一种一对多的层次关系，关系图为树状 图形结构 图形结构的数据元素是一对多的关系，关系图密集，分布呈现网状 注： 用示意图表示逻辑结构时，注意两点： 1. 每一个数据元素看作一个结点，用圆圈表示 2. 元素之间的逻辑关系用结点间连线表示，如果有方向则加上箭头。 物理结构 指数据的逻辑结构在计算机中的存储形式，也称为存储结构。 顺序存储结构 将数据元素放在地址连续的存储单元里，其数据间逻辑关系和物理关系是一致的，如：数组 ** 链式存储结构** 将数据元素放在任意的存储单元里，这组存储单元可连续，也可以不连续。通过指针的指向来说明其逻辑关系","link":"/2018/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"普通查找","text":"查找是一类重要的算法，尤其是在现今的大数据时代来看更是如此，选择一个好的查找算法往往可以起到事倍功半的效果 顺序表查找 顺序表查找是最为简单也是最为笨重的一类查找，其遵循的理念就是一个一个找。当需要在顺序表中查找一元素时，需要做的就是从头到尾对表进行一次遍历，直到找到结果为止 代码： 123456int SequentialSearch(int* a, int n, int key) { for (int i = 0; i &lt; n; i++) if (a[i] == key) return i; return -1;} 改进版顺序查找 为了使顺序表在每次查找之前不进行不必要的判断是否越界，我们可以利用 “哨兵” 法，在数组的开头或者末尾之前设置一个 “哨兵” ，查找至哨兵位置直接返回没找到即可 代码： 123456int SequentialSearch(int* a, int n, int key) { int i = n - 1; a[0] = key while (a[i--] != key); return i;} 注意：这样写返回 0 表示没有找到","link":"/2018/11/20/%E6%99%AE%E9%80%9A%E6%9F%A5%E6%89%BE/"},{"title":"最小生成树","text":"是一棵树 无回路 v 个顶点一定有 v-1 条边 是生成树 包含全部顶点 v-1 条边都在图里 向生成树中加入一条边都一定构成回路 边权重和最小 最小生成树问题的相关算法都基本按照贪心算法来实现 Prim算法 形象地来说，此算法就是让一棵小树长大——在图中任意选取一结点作为树根，然后继续在图中选取结点让这棵树长大 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Vertex FindMinDist (MGraph graph, WeightType dist[]){ /* 返回未收录顶点之中dist的最小者 */ Vertex minV, v; WeightType minDist = INFINITY; for (v = 0; v &lt; graph-&gt;nv; ++v) { if (dist[v] != 0 &amp;&amp; dist[v] &lt; minDist){ // 若v被收录，且dist[v]更小 minDist = dist[v]; // 更新最小距离 minV = v; // 更新对应顶点 } } if (minDist &lt; INFINITY) // 若找到最小的dist return minV; else // 不存在 返回-1 return ERROR;}int Prim(MGraph graph, MGraph MST){ /* 将最小生成树保存为邻接表储存的图MST 返回最小权重和 */ WeightType dist[MAXSIZE], totalWeight; Vertex parent[MAXSIZE], v, w; int vCount; Edge e; /* 初始化，默认初始点下标为0 */ for (v = 0; v &lt; graph-&gt;nv; ++v) { // 若v到w有直接的边 则graph-&gt;g[w][v]定义为INFINITY dist[v] = graph-&gt;g[0][v]; parent[v] = 0; // 定义所有顶点的父顶点都是初始点0 } totalWeight = 0; // 初始化权重 vCount = 0; // 初始化收录的顶点数 MST = CreateGraph(graph-&gt;nv); e = (Edge)malloc(sizeof(struct ENode)); // 建立空的边结点 dist[0] = 0; // 收录初始点0进入MST vCount++; parent[0] = -1; // 初始化树根结点的父节点为-1 while (1){ v = FindMinDist(graph, dist); if (v == ERROR) break; e-&gt;v1 = parent[v]; e-&gt;v2 = v; e-&gt;weight = dist[v]; InsertEdge(MST, e); totalWeight += dist[v]; dist[v] = 0; vCount++; for (w = 0; w &lt; graph-&gt;nv; ++w) // 对图中每一个顶点 if (dist[w] != 0 &amp;&amp; graph-&gt;g[v][w] &lt; INFINITY){ // w未被收录并且w和v是邻接点 if (graph-&gt;g[v][w] &lt; dist[w]){ // 收录v使得dist[w]变得更小 更新dist[w] dist[w] = graph-&gt;g[v][w]; parent[w] = v; } } } if (vCount &lt; graph-&gt;nv) totalWeight = ERROR; return totalWeight;} 代码分析： 首先对 dist[] 数组进行初始化，使数组值下标所在结点与初始结点的权重，parent[] 数组全部初始化为0，建立只有结点的邻接表存储的图MST来保存最小生成树，建立空结点e 将初始点0收录进MST，即将 dist[0] 的值设为0，收录的顶点数+1，根节点的父节点设为-1 进入循环，直至所有可以收录的结点都被收录 调用 FindMinDist() 函数，找到未收录结点中 dist 的最小者 v 将 v 结点加入到树中，即边的一端接 v 的父结点，一端接 v 结点，将边插入到MST树中 调整总权重，收录的顶点数加一 如有其他结点到 v 结点比已知路径断，对 dist 和 parent 数组进行更新 判断是否有未访问结点，如有，则说明图有独立结点，返回-1；否则，返回总权重 Kruskal算法 Kruskal算法的主要思想是让森林合并成一棵树——也就是从整个图中从权值最小的边开始，依次挑选，判断是否构成回路，一条边及其两端的两个结点可看作一棵树，挑选完n-1条边之后，形成了n-1棵树，将之合并为一棵生成树 那么应该如何选取最小权重的边呢？ ——利用最小堆 如何判断找出来的边在已有的树中不构成回路呢？ ——利用并查集 最小堆的定义 最小堆的调整： 12345678910111213141516/* 将n个元素的边数组以ESet[p]为根的子堆调整为关于Weight的最小堆 */void PercDown(Edge Eset, int p, int n){ int parent, child; struct ENode x; x = Eset[p]; // 取出根节点存放的值 for (parent = p; (parent*2) + 1 &lt; n; parent = child) { child = parent*2 + 1; if ((child != n-1) &amp;&amp; (Eset[child].weight &gt; Eset[child+1].weight)) child++; // child指向左右结点中最小者 if (x.weight &lt;= Eset[child].weight) // 找到了合适位置 break; else // 向下过滤结点 Eset[parent] = Eset[child]; } Eset[parent] = x;} 最小堆的初始化： 123456789101112131415161718/* 将图的边存入数组ESet中，并且初始化为最小堆 */void InitializeESet(LGraph graph, Edge eSet){ Vertex v; PtrToAdjVNode w; int eCount; eCount = 0; /* 将图的边存入数组eSet */ for (v = 0; v &lt; graph-&gt;nv; ++v) for (w = graph-&gt;g[v].firstEdge; w; w = w-&gt;next) if (v &lt; w-&gt;adjv){ // 避免重复录入的无向图的边， 只收v1&lt;v2的边 eSet[eCount].v1 = v; eSet[eCount].v2 = w-&gt;adjv; eSet[eCount++].weight = w-&gt;weight; } /* 初始化为最小堆 */ for (eCount = graph-&gt;ne/2; eCount &gt;= 0; --eCount) PercDown(eSet, eCount, graph-&gt;ne);} 123456/* 给定当前堆的的大小currentSize 将当前最小边位置弹出并调整堆 */int GetEdge(Edge eSet, int currentSize){ Swap(&amp;eSet[0], &amp;eSet[currentSize-1]); // 将最小边与当前堆的最后一个位置的边交换 PercDown(eSet, 0, currentSize-1); return currentSize-1; // 返回最小边所在位置} 顶点并查集的定义 开始之前： 123typedef Vertex ElementType;typedef Vertex SetName;typedef ElementType SetType[MAXSIZE]; 初始化并查集： 12345void InitializeVSet(SetType s, int n){ // 初始化并查集 ElementType x; for (x = 0; x &lt; n; ++x) // 集合元素全部初始化为-1 s[x] = -1;} 并集运算： 12345678910void Union(SetType s, SetName root1, SetName root2){ /* 保证小集合并入大集合 */ if (s[root1] &lt; s[root2]){ s[root2] += s[root1]; s[root1] = root2; } else { s[root1] += s[root2]; s[root2] = root1; }} 查找： 123456SetName Find(SetType s, ElementType x){ if (s[x] &lt; 0) // 找到集合的根 return x; else return s[x] = Find(s, s[x]);} 检查找出的边是否在已有的子集中构成回路： 123456789101112/* 检查连接v1和v2的边是否存在现有的最小生成树子集中构成回路 */bool CheckCycle(SetType vSet, Vertex v1, Vertex v2){ Vertex root1, root2; root1 = Find(vSet, v1); // 得到v1所属联通集名称 root2 = Find(vSet, v2); // 得到v2所属联通集名称 if (root1 == root2) // 判断v1和v2是否已经相连 return false; // 相连 不收录 else { Union(vSet, root1, root2); // 不相连 将v1和v2并入同一联通集 return true; }} Kruskal算法实现 代码： 1234567891011121314151617181920212223242526272829303132/* 将最小生成树保存为邻接表存储的图MST 并返回最小权重和 */int Kruskal(LGraph graph, LGraph MST){ WeightType totalWeight; int eCount, nextEdge; SetType vSet; // 顶点数组 Edge eSet; // 边数组 InitializeVSet(vSet, graph-&gt;nv); // 初始化顶点并查集 eSet = (Edge)malloc(sizeof(struct ENode) * graph-&gt;ne); InsertEdge(graph, eSet); // 初始化边的最小堆 MST = CreateGrape(graph-&gt;nv); // 创建只有顶点没有边的图 totalWeight = 0; // 总权重 eCount = 0; // 总收录的边数 nextEdge = graph-&gt;ne; // 原始边集的规模 while (eCount &lt; graph-&gt;nv-1){ nextEdge = GetEdge(eSet, nextEdge); // 从边集中得到最小边的位置 if (nextEdge &lt; 0) // 边集空 break; if (CheckCycle(vSet, eSet[nextEdge].v1, eSet[nextEdge].v2) == true){ /* 如此边可以收录 */ InsertEdge(MST, eSet+nextEdge); // 将边插入图 totalWeight += eSet[nextEdge].weight; eCount++; } } if (eCount &lt; graph-&gt;nv-1) // 边数不够 totalWeight = -1; // 设置错误标记 return totalWeight;} 代码说明： 初始化顶点并查集以及边的最小堆 初始化目标图MST 循环寻找最小边（直至收录了graph-&gt;nv-1条边或者所有边都被收录），判断此边是否可以收录- 如可以，插入图MST，并将相应的变量进行更新 不可以，继续寻找最小边","link":"/2018/10/27/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"title":"栈的应用及练习","text":"既然学了栈这种数据结构，那么就应该进一步深入或者熟练地应用。这也构成了两种不同的应用方式： 一种是利用栈这种数据结构，来实现一些其他的数据结构，比如：用栈来实现队列，或者是实现一些特殊的栈，比如：最小栈。 另一种是具体问题的解决，比如经典的逆波兰表达式的求解等一系列问题 闲话部分——在线提交 为什么要在线提交？答案很简单，就是保证自己代码的完全正确性。 怎么理解呢，就是说，你写完一个程序之后，应该仅仅会想出一组或者部分样例来进行测试代码运行结果是否符合自己的预期，但是自己想出来的这些样例往往是不完备的，而在线提交平台的样例基本是完备的，尤其是一些著名的提交平台。 那么有哪些平台可以选择呢？ 我个人的喜好是 LeetCode ，由于网速和英语不好的原因，我选择了其中文网站，如果想练习英语，也可以进其英文官网。 还有其他类似的平台，牛客啊啥的，可凭自己喜好进行选择。 栈的应用 LeetCode 还有比较好的一点就是可以按照标签进行刷题，而网站的题量也在稳步上升，而关于栈的应用，我特意选了这么几道有代表性的题： 最小栈 逆波兰表达式求值 二叉树的前序遍历 例题题解 用什么编程语言写是个问题，我个人觉得，用一些数据结构库比较完备的语言来写比较好，因为写这些题的目的是使用栈来解答问题，而不再需要过度关注栈的构成。 所以我推荐类似于 C++ ，java 甚至 python 等语言来写题。 但是也要注意库的使用，不能说题目让自己实现一个什么，然后你直接调用已经实现的库函数搞定，这样就背离了题目的初衷。 最小栈 题目就不复制过来了，可点击链接查看。 最小栈就是要自己实现一个名为最小栈的数据结构，这个数据结构与普通的栈不同的是，可以在常数时间内检测到栈中的最小元素，那么可利用两个栈来实现，从而降低时间复杂度。此题 java 代码如下： 12345678910111213141516171819202122232425262728293031class MinStack { Stack&lt;Integer&gt; stack; Stack&lt;Integer&gt; minStack; /** initialize your data structure here. */ public MinStack() { stack = new Stack&lt;Integer&gt;(); minStack = new Stack&lt;Integer&gt;(); } public void push(int x) { stack.push(x); if (minStack.empty() || x &lt;= minStack.peek()) minStack.push(x); } public void pop() { int tmp = stack.pop(); if (tmp == minStack.peek()) minStack.pop(); } public int top() { return stack.peek(); } public int getMin() { return minStack.peek(); }} stack 栈作为普通的栈使用，而 minStack 作为最小栈 逆波兰表达式求值 这是一个极为基础的栈题，可以说完全是一个基础的栈的练习，所以也不必进行太多的解释。 123456789101112131415161718192021222324class Solution { public int evalRPN(String[] tokens) { Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (String token : tokens) { if (token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\") || token.equals(\"/\")) { int one = stack.pop(); int two = stack.pop(); if (token.equals(\"-\")) stack.push(two-one); else if (token.equals(\"*\")) stack.push(two*one); else if (token.equals(\"/\")) stack.push(two/one); else if (token.equals(\"+\")) stack.push(two+one); } else stack.push(Integer.parseInt(token)); } return stack.peek(); }} 此题注意减数与除数是哪个 二叉树前序遍历 二叉树前序遍历可利用递归简单地写出，而如果不使用递归的话，就要利用栈来实现，java 代码如下： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(root); while (!stack.empty()) { if (stack.peek() == null) { stack.pop(); continue; } TreeNode tmp = stack.pop(); ret.add(tmp.val); stack.push(tmp.right); stack.push(tmp.left); } return ret; }} 利用栈 先进后出 的特性，先压右子树，再将左子树压入栈中即可。","link":"/2019/07/29/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E7%BB%83%E4%B9%A0/"},{"title":"特殊链表","text":"就链表而言，其不仅仅有单链表，相反其拥有更多种类，此文讲述一些特殊的链表。 静态链表 链表一定要用指针的方式来实现吗？脱离了指针之后，链表就没法实现吗？答案当然是否定的，链表还可以用数组代替指针来实现 定义： 用数组描述的链表叫做动态链表 首先要知道的肯定是如何实现，以及怎样实现了，如下： 代码： 12345#define MAXSIZE 1000typedef struct{ Element data ; int cur ; // 游标 为0时无指向} Component，StaticLinkList[MAXSIZE] ; 首先设计一个结构体，分为两个数据 —— data（用来存储链表节点的数据） cur（用来存储下一个结点在数组中的下标） 之后定义两个结构变量 —— Component （单个结点）StaticLinkList[MAXSIZE] （静态链表） 既然已经实现，就可以了解相关操作的实现方法了 此后所有描述均为在线性表中的操作 由于数组的空间是一次性申请的，因此我们可以将其简单地理解为数组包含着两个链表，一个为存有数据的链表，另一个为不存有数据的链表，我们称之为备用链表。 同时，为了更加方便地使用静态链表，我们将以下几个位置进行特殊处理。 首位：也就是下标为0的位置，使其 cur 值来存放备用链表第一个结点的下标 数组末位：也就是数组的最后一个元素的 cur 值来存放第一个有数值元素的下标，相当于头节点的作用。 链表末位：也就是存有数据的链表的末位，将其 cur 值指向数组首位，即将值设为0 初始化链表 初始化的方式，初始化之后的链表，其 cur 变得更加有秩序，每一个结点的 cur 值都是下一个结点的下标。如：1结点的 cur 值是2 2结点的 cur 值是3…… 代码： 12345678// 初始化静态链表status InitList (StaticLinkList space){ int i ; for (i = 0 ; i&lt;MAXSIZE - 1 ; i++) space[i].cur = i+1 ; // 依次赋值 进行初始化 space[MAXSIZE-1].cur = 0 ; // 初始化之后仍为空表 所以最后一个元素cur为0 return OK ;} 静态链表的插入 首先，找到有空余位置的地址，即所有未使用过的以及被删除的分量用游标链成一个备用的链表。而我们下标为0的结点的 cur 值刚好指向备用链表首结点下标。 之后，将元素插入并重新设置 cur 值 代码： 123456789int Malloc_SLL (StaticLinkList space){ int i = space[0].cur; // 用变量i临时存储备用链表的首结点下标 if (space[0].cur) space[0].cur = space[i].cur ; // 链表不为空 使0结点指向下标为i的结点的下一个结点 return i ;} 找到插入数据的位置之后，就可以进行插入了 代码： 12345678910111213141516Status ListInsert (StaticLinkList L , int i , ElemType e){ int j , k , l ; k = MAXSIZE - 1 ; if ( i &lt; 1 || i &gt; ListLength(L) + 1) // 判断插入结点的位置是否合理 return ERROR; j = Malloc_SSL(L) ; // 获得空闲分量的下标 if ( j ){ L[j].date = e ; // 直接将数据放入数组下标为j的位置 for (l = 1 ; l &lt;= i-1 ; l++) k = L[k].cur ; // 找到要插入结点的前一结点 L[j].cur = L[k].cur ; L[k].cur = j ; // 插入节点 return OK ; } return ERROR ;} 理解上述代码，首先要清楚一个概念： 静态链表的结点位置与其在数组上的下标无关，是两个独立的概念。在线性表的静态链表表示时，数据的存储是在数组中是一个接一个紧密排列的，而线性表的排列则是通过 cur 值链成一条。 所以，插入时最主要的两步就是： - 找出空余位置，将数据存储进数组 - 找到结点位置，在线性表中将结点插入 静态链表的删除 此条为根据链表位置进行删除。同样，首先应该想到删除之后的处理方法，也就是将删除结点的位置重新放入备用链表之中 代码： 1234void Fre_SSL(StaticLinkList space, int k ){ space[k].cur = space[0].cur ; // 将第一个元素的 cur值赋给要删除的分量 space[0].cur = k ; // 将要删除分量的线标赋值给第一个元素的 cur} 如上代码所示，并入备用链表时，首先将删除结点并入备用链表头部，然后将第一个元素的 cur 值为删除结点的下标。 删除操作如下所示： 代码： 12 注： 删除节点的关键步骤同样可分为两步： 从链表中删除结点，也就是将删除结点的前后节点连接起来（ListDelete函数中操作） 将删除后的结点并入备用链表之中（Fre_SSL函数进行操作） 循环链表 定义：将单链表中终端节点的指针端由空指针指向头节点，就使整个单链表形成一个环，这种头尾相接的链表就被称为单循环链表，简称循环链表 我们一般的单链表为了操作简单，往往给链表增加一个头结点，循环链表也可如此，以使空链表与非空链表处理一致。 我们如此设立循环链表（加头结点的方式），那么寻访第一个结点的时间复杂度为O(1) ，访问尾节点的时间复杂度为O(n)。为了提高寻访尾结点的效率，我们可以舍弃头结点，在链表尾部添加尾节点，尾指针指向链表尾结点，这也是一般设计循环链表的模式。 循环链表的相关操作实现与单链表并无不同，所以不再赘述 双向链表 定义： 双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域 首先需要知道双向链表实现的结构 代码： 12 双向链表的一些操作实现与单链表相同，如：获取长度，查找元素数据，获取元素位置等，所以不进行讨论，直接来学习与单链表有差异的操作，也就是插入与删除。 插入与删除的实现实际本质并无差别，只是多了一个反向指针的连接，注意顺序即可： 插入顺序： 新结点 prior 指针指向插入位置的前一个结点 新结点的 next 指针指向插入位置的后一个结点 将后一个结点的 prior 指针指向新结点 将前一个节点的 next 指针指向新结点 代码：依照上述顺序，3 4步的顺序不可改变 12345// s为新节点 p为从头节点开始找到的插入位置的之前的一个结点s-&gt;prior = p ; s-&gt;next = p-&gt;next ;p-&gt;next-&gt;prior = s ;p-&gt;next = s ; 删除顺序 不讲究顺序，简单操作即可 代码： 1234// p为要删除的结点p-&gt;prior-&gt;next = p-&gt;next ; // p结点前一个结点的 next 指针指向 p 结点后一个指针的地址p-&gt;next-&gt;prior = p-&gt;prior ; // p结点后一个结点的 prior 指针指向 p 结点的前一个结点地址free(p) ;","link":"/2018/08/09/%E7%89%B9%E6%AE%8A%E9%93%BE%E8%A1%A8/"},{"title":"由一道题重新审视排序","text":"今天闲得无聊，写了道题，写完后，我发现这道题让我对排序有了更加深刻的认识，如今在看来，排序的核心主要有两点： 比较函数（也就是比较的结果），决定了以何种方式进行排序：从大到小抑或是从小到大，甚至是其他更为特殊的方式 比较次数（也就是比较的方式），决定了排序的时间复杂度，也就是说，要想降低排序的时间复杂度，其重点就在于减少排序的次数。 排序总述 排序，在我看来，就是以给定的规则，对一组数（或者字符）进行重新排列，而规则是可变的，比如我们日常使用的：从大到小的顺序，从小到大的顺序，字典序等等等等。 那么，从底向上看排序，其最核心的部分，就在于两两比较，通过比较，就能确定两两之间的相对顺序——即谁先谁后。 而排序的效率，则取决于比较次数的多少，比如我们可以通过不重复比较，或者一些特殊的比较方式来缩短时间复杂度。 比较函数 总述 什么是比较函数？抽象来说，就是比较两个数，并确定其先后顺序的函数；具体来说，就是C语言 qsort() 函数中的 cmp 参数，是 java 中 Arrays.sort() 方法中的 Comparator 参数。 比较函数的一般写法是，对传入的两个参数（a, b）进行比较： a 大于 b 返回 1 a 大于 b 返回 -1 a 大于 b 返回 0 规则进行返回，通过控制两个参数的传入，来控制从大到小排列或者从小到大排列。 比较 比较可以自己写规则，比如最为简单的数字的 从大到小，从小到大 等等，但是一些时候就不仅仅是简单的的从大到小或是从小到大了，比如我今天写的这个题（leetcode 179）： 题目如下： 给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 12输入: [10,2]输出: 210 示例 2: 12输入: [3,30,34,5,9]输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 题目解答： 这题本质是一个排序问题，而排序的方式不再是简单的数字排序： 数字从大到小排序：98 肯定在 9前面，但是此题则应该将顺序置反 数字从小到大排序：2 肯定在 42 前面，但是此题则应该将顺序置反 所以此题的比较不能够按照常规方式写，而我们可以按照字符串的字典序来看，也就是说，将两个数字拼接，比较两种拼接方式的大小，从而选择排列顺序，比如：98 和 9 两个数只有两种拼接方式：998 明显大于 989 ，所以 9 应该在 98 前面 便是以此种方式，来进行排序，排序后，将之依次拼贴为一字符串即可, java代码（参考了 leetcode 官方题解）： 1234567891011121314151617181920212223242526class Solution { private class LargerNumberComparator implements Comparator&lt;String&gt; { @Override public int compare(String a, String b) { String order1 = a + b; String order2 = b + a; return order2.compareTo(order1); } } public String largestNumber(int[] nums) { String[] numsString = new String[nums.length]; for (int i = 0; i &lt; nums.length; i++) numsString[i] = String.valueOf(nums[i]); Arrays.sort(numsString, new LargerNumberComparator()); if (numsString[0].equals(\"0\")) return \"0\"; String ret = new String(); for (String numString:numsString) ret += numString; return ret; } } 比较次数 这部分内容不算是重点，所以，大致说明即可： 冒泡排序，每次循环都会比较，所以几乎每两个数字间都会进行比较，所以其时间复杂度为 \\(O(N^2)\\) 而比较高级的排序，比如归并，快排甚至桶排，都是降低了比较次数，从而降低了时间复杂度；","link":"/2019/08/14/%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E6%8E%92%E5%BA%8F/"},{"title":"简单排序","text":"排序可以说是相当常用的一类数据处理方式，而进行排序的方法也是多种多样的，此文主要记录经典的排序算法，并阐明基本原理 开始之前 所有的排序算法以函数形式展现，采用C语言编写 函数风格统一，命名规则同ASort，A为排序方法名称，首字母大写，传参均仅传入数组及其大小，函数类型为void，即直接将原数组进行排序 所有排序的终点，也就时排序后的结果，为从大到小排序 为了让排序更好的进行，首先编写交换函数，即Swap()函数 代码： 123456789#include &lt;stdio.h&gt;#define ELEMENT_TYPE intvoid Swap(ELEMENT_TYPE *x, ELEMENT_TYPE *y) { ELEMENT_TYPE temp = *x; *x = *y; *y = temp;} 冒泡排序 冒泡排序可谓是相当经典的一个排序算法，记得自己大一面试学校社团之时，学长让第一个去了解的排序算法就是冒泡算法 实现思路 冒泡，顾名思义，就是将需排序的元素，看作大小不同的泡泡进行处理 首先将数组进行一趟从头至尾的扫描，遇到后者比前者大的元素，就将二者交换，一趟扫描之后，最大的元素实现沉底 那么只需要扫描n趟，就可让数组排列整齐 结合上述思路，我们可以写出以下代码： 代码1 123456void BubbleSort (ELEMENT_TYPE a[], int n) { // 冒泡 for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (a[j] &gt; a[j+1]) Swap(&amp;a[j], &amp;a[j+1]);} 上述代码相当简单，但是还可进行优化 因为冒泡排序过程中，有可能只进行小于n趟就已经排序完成，之后的扫描都属于无用功，所以加一标记，使其在扫描一趟的过程中，若无元素交换，则直接结束循环 代码2 12345678910111213void BubbleSort (ELEMENT_TYPE a[], int n) { // 冒泡 for (int i = 0; i &lt; n; ++i) { int flag = 0; for (int j = 0; j &lt; n; ++j) { if (a[j] &gt; a[j+1]) { Swap(&amp;a[j], &amp;a[j+1]); flag = 1; } } if (flag == 0) break; }} 如此一来，其最好情况为O(N)，而最坏情况为O(N^2) 插入排序 插入排序也是简单排序的一种，也是比较常见的一种算法 实现思路 为了更好地理解插入算法，我们引入打牌时的实例 打牌时，为方便出牌，我们一般将牌有顺序地拿着，当摸一张牌时，我们会与手中已排序完成的牌进行比较，以插入到合适的位置 插入排序也是模拟了这一过程，首先假设数组中的首个元素已经 “拿在手中” ，之后将数组中的元素依次取出，进行插入 代码 123456789void InsertionSort(ELEMENT_TYPE a[], int n) { // 插入 int i, j; for (i = 1; i &lt; n; ++i) { ELEMENT_TYPE temp = a[i]; for (j = i; j &gt; 0 &amp;&amp; a[j-1] &gt; temp; j--) a[j] = a[j-1]; a[j] = temp; }} 代码在插入的时候是从后往前比较的，也就是从i到0 插入排序无需进行数字的交换，某种程度来说代码量是少于冒泡的 其最好情况为O(N)，而最坏情况为O(N^2) 选择排序 提到简单排序，就不得不说选择排序 实现思路 选择排序很好理解，就是首先遍历一遍数组，找到，该数组中最小的元素，与数组首位元素进行交换 这种交换需要进行n次，所以遍历也会进行n次 代码 12345678910void SelectionSort (ELEMENT_TYPE a[], int n) { // 选择 for (int i = 0; i &lt; n; ++i) { int min = i; for (int j = i; j &lt; n; ++j) { if (a[j] &lt; a[min]) min = j; } Swap(&amp;a[min], &amp;a[i]); }} 选择排序的时间复杂度是恒定的，无所谓最好最坏，均为 O(N^2)","link":"/2018/11/03/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"},{"title":"算法复杂度初探","text":"研究算法，研究什么？ 算法的原理：即此算法为何被提出来，其解决问题的原理是什么 算法的复杂度：即此算法快不快，有多快；需要的额外空间是多少，大不大。 而在研究之前，首先应知道相关基础知识。 算法分析是理论研究，是关于计算机程序性能和资源利用的研究。 Q： 既然算法与计算机程序性能有关，那么性能就必须放在第一位吗？ A： 对于有些问题的处理方案（即算法），以现在的技术，在计算机上进行运算或者处理，但时间是无限久远的，或者无法在短时间内解决，这时候就应该将算法置于首位，提升算法解决问题的速度。 对于有些问题，已有的算法已经能够在短时间解决问题，那么算法就不应该被摆在第一位，那么这时就会考虑其他因素：成本，简洁度，安全性，稳定度等等。 我们向往速度，所以我们总是在追求速度——更快的交通，更快的网络。或许这也是为什么算法会吸引这么多人学习的原因吧！ 符号说明 \\(O(g(n))\\) 大 \\(O\\) 符号，表示复杂度的上限为 \\(g(n)\\) 的 \\(c\\) 倍（ \\(c\\) 为常数） \\(\\Omega (g(n))\\) 大 \\(\\Omega\\) 符号，表示复杂度的下限为 \\(g(n)\\) 的 \\(c\\) 倍（ \\(c\\) 为常数） \\(\\Theta (g(n))\\) 大 $ $ 符号，表示复杂度的介于 \\(c_1 g(n)\\) 于 \\(c_2g(n)\\) 之间（ \\(c_1 c_2\\) 为常数） 从排序入手 输入一组数 \\((a_{1} a_{2} , ...... , a_{n})\\) 按需求重新排列后进行输出 \\(( a_{1}^{'} a_{2}^{'} , ...... , a_{n}^{'} )\\) 使得 \\(a_{1}^{'} \\le a_{2}^{'} \\le ...... \\le a_{n}^{'}\\) （使得大小单调递增） 插入排序 伪代码为： 12345678Insertion Sort(A,n) // Sorts A[1 , 2 , ...... , n] for j &lt;-- 2 to n do key &lt;-- A[j] i &lt;-- j-1 while i &gt; 0 and A[i] &gt; key do A[i+1] &lt;-- A[i] i &lt;-- i-1 A[i+1]&lt;-- key 顾名思义，该算法核心在于插入，从第二个数起开始插入，也就是上述伪码中的 j ，根据程序的运行可知，a[j] 之前的数均已经排序完成，所以只需不断插入即可！ 运行时间 输入的数据本身（如输入已经有序，那么进行的步骤将会非常少） 输入数据的规模（六百万数据和六亿数据运行的时间肯定不一样） —- 我们将输入数据的规模进行参数化，之后将运行时间看作是待排列数据规模的函数 硬件设备的种类（同样的算法在PC 和 超级计算机运行情况不同） 一般研究种类 最坏情况（最常研究的） —- T(n) = 输入规模为n时的最长运行时间 平均情况（有时研究） —- T(n) = 输入规模之下的所有可能期望时间 （也就是一种加权平均，即每种输入的运行时间乘以那种输入出现的概率） 但是输入出现的概率是不知道的，所以需要进行假设，如 每种输入出现的概率相等。 最好情况（假象 bogus：因为最好的情况往往不会出现，但可以骗人，有些算法对于特定的数据可能会有超级优秀的速率，但是这不具有普遍性，是无效的） 插入排序的最坏运行时间 由于不同设备因其性能不同，运行时间也会不同，那我们如何比较算法的运行时间呢？ —- 通常，我们比较算法时，比较的是其相对速度，即两个算法在同一机器上的时间。 但是一个算法一定会在所有计算机上都是优秀的吗？ —- 算法的BIG IDEA ! —— Asymptotic analysis Asymptotic analysis 忽略掉依赖于机器的常量，也就是不同机器对于算法的影响一般仅仅相当于时间的n倍 不是去检查实际的运行时间，而是去关注运行时间的增长 —- look at growth of T(n) as n –&gt; $$ Asymptotic notation \\(\\theta\\) ：弃去公式的低阶项，并忽略前面的常数因子 Ex：公式为 ： \\(3{n}^{3}+90{n}^{2}-5n+6046\\) = \\(\\theta\\) (\\({n}^{3}\\)) 当 \\(n\\) –&gt; $$ 时 , \\(\\theta\\) (\\({n}^{2}\\)) 的算法迟早会战胜一个\\(\\theta\\) (\\({n}^{3}\\))的算法 Insertion Sort analysis 最坏情况：即输入的数已经按照从大到小排列好 —- T(n) = \\(\\sum\\limits_{j=2}^{n}{\\theta (j)=\\theta ({n}^{2})}\\) 也就是一个常数级数 由上可见：当数据量小的时候，插入排序的速度是毋庸置疑的，但数据量大的时候，就不是那么快了 归并排序 伪码 123456Merge Sort A[1 , 2 , ... , n]1. if n = 1 , done2. Recursively sort A[1 , 2 , ..., [n/2]] A[[n/2]+1 , ... , n]3. Merge 2 sort lists \\(T_{1}\\) = \\(\\theta\\) (1) // 滥用 \\(\\theta\\) \\(T_{2}\\) = 2T(n/2) // 拆成两个数列（故乘2），每个是(n/2)个数 \\(T_{3}\\) = \\(\\theta\\) (n) // 将两个排好的数列进行归并，复杂度与输入规模成线性关系 \\[ T(n) = \\left\\{ \\begin{array}{ll} \\theta (1) &amp; \\textrm{if $ n=1 $}\\\\ 2T(\\frac{n}{2})+\\theta(n) &amp; \\textrm{if $n &gt; 1$}\\\\ \\end{array} \\right. \\] 采用递归树方法进行分析 T(n) = \\(2T(\\frac{n}{2}) + cn\\) (用 \\(cn\\) 替换了\\(\\theta\\)(n) )，如图： 递归树分析 可知树（这个树是倒放的）高 n 为\\(\\lg (n)\\)，实际为以二为底，n的对数。而将所有叶节点加起来为\\(\\theta\\)(n) 那么可知，\\({T_2}(n) = (cn)\\lg (n) + \\theta \\left( n \\right) = \\theta (n\\lg n)\\) 综上可知，归并排序优于插入排序！ 注：重点在于掌握分析算法复杂度的数学方法，\\(\\theta\\) 符号的意义，以及学会使用递归树进行分析递归算法","link":"/2018/07/20/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%9D%E6%8E%A2/"},{"title":"粗谈堆栈","text":"堆栈是一两种十分常用的数据结构，而在硬件中根据内存相关分区功能的不同，将和此两种数据结构功能相似的分区（不是物理意义上的分区）分别称之为堆区栈区，简称堆栈。 所以要搞清楚不同之处（我刚学C语言的时候一直搞不清楚）：堆栈在数据结构（软件）中来说是两种数据结构的名称；而在计算机内存中又表示两个不同的分区的名称 堆（Heap） 堆区在内存中占了相当大的一部分，这部分主要是为了储存程序中动态分配的数据，就C语言而言， malloc() realloc() calloc() 申请而来的空间就全部是堆中的空间，而动态申请的空间均需要利用 free() 手动释放掉。 当我们书写语句，在堆中申请空间：int* tmp = malloc(40 * sizeof(int)) ，可以计算出，我们申请的空间大小理论上应该为 \\(40 \\times 4 = 160\\) ，但是其在堆中实际申请的空间应该是大于理论值一到两个字节的，而申请完毕后传回的指针实际上也不是申请空间的首地址，而是类似一个如下图所示的结构： 粗谈堆栈1.png 申请的实际空间如最大的红色边界线所示，而理论空间则如阴影部分所示，申请的空间最前面的一到两个字节（视底层的具体代码决定）用来标识由此开始的xx字节内存已被占用，以及一些必要的信息，来方便其他操作（例如需要 free() 之时，只需要将此标记移除或者改动即可）。 谈谈realloc()： realloc() 进行内存扩展有两种方式： 可以向后延拓之时，直接在此空间之后连续追加至相应的字节数即可 无法延拓之时，寻找适合的位置，另辟空间，将原有的数据复制过去，返回新空间的指针 一个减小 malloc() 时间复杂度的方法： 将所有空闲的内存首地址之间利用链表连接起来，并注明此处闲余空间是多少，然后再次开辟之时，便可以直接跳转寻找合适的空间 栈（Stack） 栈是在程序运行时创立的一块内存，用于存放自动开辟的空间（在C语言中而言也就是声明的变量），其一般来说是可拓展空间的，可随着程序的执行自动进行扩展（就如同之前实现的那个栈一般）。 注意： int* tmp = malloc(40 * sizeof(int)) 在堆中存储 int tmp[40] 在栈中存储 关于此块内存，也就是遵循着先进后出的原则，就是说：其是随着程序运行来对内存进行动态分配的 ，非常好理解，在次不多赘述。","link":"/2019/09/20/%E7%B2%97%E8%B0%88%E5%A0%86%E6%A0%88/"},{"title":"线性表","text":"线性表 由同类数据元素构成有序序列的线性结构 表中元素个数称之为线性表的长度 线性表没有元素时称为空表 表起始位置称表头 ，表结束位置称表尾 类型名称 ：线性表(List) 数据对象集 ：线性表是n(&gt;=0)个元素构成的有序序列 操作集 ： List MakeEmpty() 初始化一个空表 ElementType FindKth() 根据位序K，返回相应元素 int Find(ElementType X, List Ptrl) 在线性表L中查找X的第一次出现位置 void Insert(ElementType X,int i,List Ptrl) 在位序i前插入一个新元素 void Delete(int i,List L) 删除指定位序i的元素 int Length(List L) 返回线性表L的长度 …… 线性表的顺序存储实现 用数组的连续储存空间顺序存放线性表的个元素 代码 1234567typedef struct LNode *List; //用*List指针代替LNodestruct LNode{ //定义LNode结构体 ElementType Data[MAXSIZE]; int Last; //数组最后一个元素的位置};struct LNode L; //声明L为LNode类型的结构体List PtrL; //ptrl为List型指针 访问下标为 i 的元素，L.Data[i] 或 PtrL-&gt;Data[i] 线性表的长度：L.Last + 1 或 PtrL-&gt;Last + 1 List MakeEmpty() 初始化一个空表 代码 123456List MakeEmpty(){ //初始化一个空表 List Ptrl; Ptrl = (List) malloc (sizeof(struct LNode)); //申请出一个空表的空间 Ptrl-&gt;Last = -1; return Ptrl;} Last = -1: 因为表长为Last + 1，所以Last = -1 表示空表。 ElementType FindKth() 根据位序K，返回相应元素 代码 12345678void ElementType_FindKth(int i){ //根据位序K，返回相应元素 if (i &lt; 0 || i &gt; Ptrl-&gt;Last + 1){ //检查输入位置的合法性 printf(\" 位置不合法 \"); return; } else return Ptrl-&gt;Data[i-1]; //位置合法，返回结果} int Find(ElementType X, List Ptrl) 在线性表L中查找X的第一次出现位置 代码 123456789int Find(ElementType X, List Ptrl){ //在线性表L中查找X的第一次出现位置 int i = 0; while (i &lt;= Ptrl-&gt;Last &amp;&amp; Ptrl-&gt;Data[i] != X) //限定查找条件(不越界，没找到) i++; if (i &gt; Ptrl-&gt;Last) return -1; //没找到，返回-1 else return i; //找到，返回位置i} void Insert(ElementType X,int i,List Ptrl) 在位序i前插入一个新元素 代码 12345678910111213141516void Insert(ElementType X,int i,List Ptrl){ //在位序i前插入一个新元素(先移动，再插入) int j; if (Ptrl-&gt;Last == MAXSIZE - 1){ //表空间已满，不能插入 printf(\" 表满 \"); return; } if (i &lt; 1 || i &gt; Ptrl-&gt;Last+2){ //检查插入位置的合法性 printf(\" 位置不合法 \"); return; } for (j = Ptrl-&gt;Last;j &gt;= i - 1;j--) Ptrl-&gt;Data[j + 1] = Ptrl-&gt;Data[j]; //将a[i]~a[n]倒序向后移动 Ptrl-&gt;Data[i - 1] = X; //插入新元素 Ptrl-&gt;Last++; //Last仍指向最后元素 return;} void Delete(int i,List L) 删除指定位序 i 的元素 代码 123456789101112void Delete(int i,List L){ //删除指定位序i的元素 int j; if (i &gt; Ptrl-&gt;Last + 1 || i &lt; 1){ //检查空表及删除位置的合法性 printf(\" 不存在第%d个元素 \",i); return; } for (j = i;j &lt;= Ptrl-&gt;Last;j++) Ptrl-&gt;Data[j - 1] = Ptrl-&gt;Data[j]; //将a[i + 1]~a[n]倒序向前移动 Ptrl-&gt;Last--; //Last仍指向最后元素 return;} int Length(List L) 返回线性表L的长度 代码 123int Length(List L){ //返回线性表L的长度 return L.Last + 1;} 线性表的链式储存实现 代码 1234567typedef struct LNode *List;struct LNode{ ElementType Data; // 节点所储存的数据 List Next; // 下一个节点的位置 List 指针};struct LNode L;List PtrL; 用链表实现： Data 用来储存结点的数据 Next 用来放下一节点的指针 int Length(List PtrL) 求表长 代码 123456789int Length(List PtrL){ // 求表长 List p = PtrL; // p 指向表的第一个结点 int j = 0; while (p){ // 遍历链表 直到p指针为null p = p-&gt;Next; j++; // 当前p指向第j个结点 } return j;} List FindKth(int K, List PtrL) 按序号查找 代码 123456789101112List FindKth(int K, List PtrL) { //按序号查找 List p = PtrL; int i = 1; while (p != NULL &amp;&amp; i &lt; K){ // 排除错误序号及遍历链表 直到第K个为止 p = p-&gt;Next; i++; } if (i == K) return p; // 找到第k个，返回指针 else return NULL; // 否则返回空} while循环条件： 指针不为空，且查找的序号小于要查找的序号 List Find(ElementType X,List PtrL) 按值查找 代码 123456List Find(ElementType X,List PtrL){ // 按值查找 List p = PtrL; while (p != NULL &amp;&amp; p-&gt;Data != X) // 遍历链表 p = p-&gt;Next; return p;} List Insert(ElementType X,int i,List PtrL) 插入结点 代码 123456789101112131415161718192021List Insert(ElementType X,int i,List PtrL){ // 插入结点 List p,s; if (i == 1){ // 新结点插在表头 s = (List)malloc(sizeof(struct LNode)); // 申请装填结点 s-&gt;Data = X; s-&gt;Next = PtrL; return s; // 返回表头指针 } p = FindKth(i - 1,PtrL); // 查找第i-1个结点 if (p == NULL){ // i-1个结点不存在 不能输入 printf(\" 参数i错误 \"); return NULL; } else{ s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = p-&gt;Next; // 新结点指向下一个结点 p-&gt;Next = s; // n-1个结点指向新结点 return PtrL; }} List Delete(int i,List PtrL) 删除结点 代码 123456789101112131415161718192021222324252627List Delete(int i,List PtrL){ // 删除结点 List s,p; if (i == 1){ // 如果删除第一个结点 s = PtrL; // s指向第一个结点 if (PtrL != NULL) // 删除该节点 PtrL = PtrL-&gt;Next; else return NULL; free(s); // 释放被删除结点 return PtrL; } p = FindKth(i-1, PtrL); // 查找第i-1个结点 if (p == NULL){ printf(\"第%d个结点不存在\",i-1); return NULL; } else if (p-&gt;Next == NULL){ printf(\"第%d个结点不存在\",i); return NULL; } else{ s = p-&gt;Next; // s指向第i个结点 p-&gt;Next = s-&gt;Next; // 从链表中删除 free(s); return PtrL; }} 1p-&gt;Next = s-&gt;Next s-&gt;Next 为n+1结点的指针 p-&gt;Next 为n-1结点的指针 直接将n-1点的指针指向n+1点，也就是删除掉了n结点","link":"/2018/05/21/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"title":"练习","text":"生成五个不重复的随机数 一道蛮有意思的练习 生成随机数储存在数组中，然后判断数组中元素是否重复，如果重复，则推倒重新生成 这是我刚开始的想法，后来发现思路用代码实现起来较为困难，而且效率不高，于是摒弃了这种实现方法。 每生成一个随机数，进行一次判断，数组中没有此元素，则存入数组，否则重新生成。 此方法为参照教程思路，效率比较高，而且代码实现也不是很困难，遂采用此种方法实现 代码 123456789101112131415161718192021222324252627282930313233import java.util.Random;public class Test02 { public static void main(String[] args) { int index = 0; int [] k = new int[5]; while (index &lt; 5){ Random r = new Random(); int temp; temp = r.nextInt(6); if (temp != 0 &amp;&amp; !contains(k,temp)){ // 生成元素不为零且不重复 k[index++] = temp; } } for (int i = 0; i &lt; k.length; i++) { System.out.println(k[i]); } } // 判断数组中是否包含temp元素 public static boolean contains(int k[],int temp){ for (int i = 0;i &lt; k.length;i++){ if (k[i] == temp) return true; } return false; }} 实现文件的复制粘贴 利用字节输入输出流实现对硬盘文件的复制粘贴 代码 1234567891011121314151617181920import java.io.FileInputStream;import java.io.FileOutputStream;public class Copy01 { public static void main(String[] args) throws Exception{ // 创建输入流 FileInputStream fis = new FileInputStream(\"E:\\\\图片\\\\壁纸\\\\0.jpg\"); // 创建输出流 FileOutputStream fos = new FileOutputStream(\"王昭君.jpg\"); byte[] bytes = new byte[1024]; // 创建数组 每次读取1KB int temp; // 一边读一边写 while ((temp=fis.read(bytes)) != -1){ // 读入 fos.write(bytes,0,temp); // 写入 } }} 上述代码是将图片0.jpg从E:\\图片\\壁纸目录复制到工程目录下并改名为王昭君.jpg","link":"/2018/06/05/%E7%BB%83%E4%B9%A0/"},{"title":"进阶查找","text":"当数组（或其他查找的对象）是杂乱无章之时，或许查找起来就会比较困难，甚至只能一个一个找。但是，当数据是有序的之后，查找数据就有更为省时的算法了 二分查找 二分查找也被称之为折半查找，其绝对是应用最为广泛也的查找算法了，其 \\(log(N)\\) 的时间复杂度也是相当优秀，所以其名声也是相当大，以至于我在很久之前就听说过此算法并写了一篇博文，可以点击链接直接跳转 插值查找 插值查找是在二分查找的基础上改进产生的，其大致思路如下：当我们查字典时，如果首字母为 a ，我们必然不会往中间翻，而是翻向靠前的页数，所以，当我们进行查找之时，也可以根据具体情况进行镶银的调整 1234567891011121314int BinarySearch(int a[],int size,int p) { int L = 0; int R = size - 1; while( L &lt;= R) { int mid = L + (R-L) * (p-a[L]) / a[R] - a[L]; if( p == a[mid] ) return mid; else if( p &gt; a[mid]) L = mid + 1; else R = mid - 1; } return -1;} 说明： 插值查找的实质就是 根据key值于表中最大最小值比较后的查找方法，其核心为插值计算公式——\\(\\frac {key-a[low]} {a[hight]- {a[long]}}\\) 其对于较为均匀排列的查找表有更好的效率，而对极端不均匀的数据来说可能不是很好的选择 斐波那契查找 既然有了二分查找这样的思路，二分查找是以中间作为划分的，插值查找是依据插值计算公式进行划分的，那么我们同样可以试图采用别的划分方法，比如：斐波那契数列 代码： 123456789101112131415161718192021222324int FibSearsh(int* a, int n, int key) { const int F[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89}; int low = 1, high = n, mid, i, k = 0; while (n &gt; F[k] - 1) k++; for (i = n; i &lt; F[k] - 1; i++) a[i] = a[n]; while (low &lt;= high) { mid = low + F[k-1] - 1; if (key &lt; a[mid]) { high = mid - 1; k -= 1; } else if (key &gt; a[mid]) { low = mid + 1; k -= 2; } else { if (mid &lt;= n) return mid; else return n; } } return -1;} 二叉搜索树 这是利用二叉树来进行查找的算法，相关内容可点击链接直接跳转","link":"/2018/11/25/%E8%BF%9B%E9%98%B6%E6%9F%A5%E6%89%BE/"},{"title":"链表之快慢指针","text":"链表是最为基本的数据结构之一，常与数组作比较。由于链表相较于数组更加优良的的增删性能，常利用于增删比较频繁场合，并且衍生出了许多特殊的链表结构——静态链表，循环链表，双向链表等等。 而链表操作具有较强的技巧性，双指针最为常见，而双指针中，又以快慢指针最为特殊。这篇文章将根据自己的理解，说明快慢指针的原理与常见应用。 链表的中间结点 题目说明 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 12345输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 题目解答 链表的中间结点是快慢指针最为基础的一个例子， java 代码如下 1234567891011121314151617181920/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode middleNode(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; }} 原理分析： 原理颇为简单，但很精妙： 声明两个指针，一个将之称为快指针，一个将之称为慢指针【快指针步长（一次经过的结点）相较慢指针更大，固有其名】 此处的快指针步长为2（一次两个结点），慢指针步长为 1 。当快指针到达链表末尾的时候，慢指针刚好到链表中间，由是一次循环便可以解决问题。 快慢指针的一般形式 由上题可见，快慢指针实质上就是两个步长不同的指针，步长大的称之为快指针，小的称之为慢指针。而解决问题的原理，在于利用两个指针步长不同所产生的差异，来进行问题的求解。 环形链表 题目描述 给定一个链表，判断链表中是否有环。环，即链表末尾并非指向 null ，而是指向链表中的任意一个结点。详情可点击超链接。 题目解答 此题依旧可以利用快慢指针的思想来解答，java代码如下： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public boolean hasCycle(ListNode head) { ListNode quick = head; ListNode slow = head; while(quick != null &amp;&amp; quick.next != null) { quick = quick.next.next; slow = slow.next; if (quick == slow) return true; } return false; }} 原理分析 同样是快慢指针，快指针步长为 2 ，慢指针步长为 1 。 如果两指针相遇，便说明链表中有环。 那为快慢指针一定会相遇呢？我看了知乎的同名问题，发现有好多都用了这样一个比喻：两个同学在操场跑步，一个快，一个慢，跑的快的同学总能追的上跑得慢的同学。乍一听，好像颇有道理，但是细思，这个比喻其实是相当不合理的，跑道可以看是连续的，但是环形链表不是，一个个结点不是，它是离散的。 所以，这样的比喻并没有任何说服力，而如要真正说明，便需要严谨的数学证明，也即此问题目前最高赞回答： 快指针与慢指针之间差一步：此时继续往后走，慢指针前进一步，快指针前进两步，两者相遇。 快指针与慢指针之间差两步：此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差一步，又变为第一种情况。 快指针与慢指针之间差N步：此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差N-1步。 所以，根据上述并不严谨的数学归纳法，便可清晰的说明原因。 但是若再深究，步长必须一个为 1 ，一个为 2 吗？ 那么为了说明这点，就需要一个较为普遍的证明： 一有环链表如下图所示： 指针之快慢指针2.png 参数说明： A B 分别为链表的头结点，环的入口结点 L1 为非环部分的链表长度 L2 为慢指针在环入口结点时候与快指针间的距离 链表环的周长为 C \\(S_s\\) 和 \\(S_f\\) 分别为快指针和慢指针所走的 “路径”（即经过的结点数） \\(N_1\\) 为正整数 \\(N_2\\) 为一任意实数数 证明： 当慢指针到达环的入口结点（即B点）之时，二者所经过的 “路程” 如下： \\(S_S = L1\\) \\(S_f = 2\\times L1 = L1 + N_1C + L2\\) 则：\\(L1 = N_1C + L2\\) 假设慢指针与快指针在慢指针走了 i 之后相遇（快指针为慢指针的 \\(N_2\\) 倍），可得方程如下： \\((S_s + i - L1)\\ mod\\ C =(S_f + N_2i -L1)\\ mod\\ C\\) 代入可得： \\(i\\ mod\\ C =(N_1C + N_2i + L2)\\ mod\\ C\\) 移向化简： \\([(N_2 - 1)i + L1]\\ mod\\ C = 0\\) 又因为 NC 是 C 的整数倍，可约去，所以最终等式为：\\([(N_2-1)i+L1]\\ mod\\ C = 0\\) 则说明，只要 \\((N_2-1)i+L1\\) 是 \\(C\\) 的整数倍，那么快慢指针一定能够相遇 \\(N_2\\) 应该如何取值呢？ 显然，如果 \\(N_2 = 1\\) （即两指针步长相同），那么等式就只有在 \\(L1\\) 是 \\(C\\) 整数倍的时候才能相遇 \\((N_2-1)i+L1 = KC\\) （\\(K\\) 为任意正整数），显然，\\(N_2\\) 取任意大于1的实数，均能够满足此等式 所以，有环链表中，理论上只要快指针的步长大于慢指针的步长，两指针就能相遇。 但是，快指针步长为2，慢指针步长为1之时，其时间复杂度是最低的，故一般如此使用。【关于时间复杂度最低问题，链表中，快指针虽然说是一次走两步，但是其仍旧是一个结点一个结点逐次访问的，所以步长越大，其所遍历的多余结点数就越多，当然时间复杂度也会相应提升】 环形链表 II 本题与环形链表不同的是，需要求出环形链表的入环结点。此题所采用的算法好像正规名叫 Floyd 判圈算法 ，是图论里的一种算法。 题目解答 这算法的详细描述是： 利用快慢指针判断是否有环 如果有，则将相遇的结点标记，同时设新指针指向链表头。 两个指针分别从相遇的结点和链表头开始移动，直至相遇，相遇后的结点便是入环结点。 java 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { private ListNode findIntersection(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return slow; } } return null; } public ListNode detectCycle(ListNode head) { ListNode intersection = findIntersection(head); if (intersection == null) return null; ListNode ptr1 = head; ListNode ptr2 = intersection; while (ptr1 != ptr2) { ptr1 = ptr1.next; ptr2 = ptr2.next; } return ptr1; }} 为了清晰起见，重新定义了一个函数。 原理分析 由上题之证明：二指针相遇之时，恰好满足 \\([(N_2 - 1)i + L1]\\ mod\\ C = 0\\) ； 又因为i 为慢指针走的步数，L1 为前无环部分的长度，二者之和刚好是 \\(C\\) 的整数倍。所以，可得 \\(C-i = L1\\)，故此方法定能找到入环结点。 参考文章： windsmoon的博客：判断单向链表是否有环及求环入口的算法数学证明 知乎问题：为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？ StackOverflow 提问：Proof of detecting the start of cycle in linked list 本文题目均来源于LeetCode","link":"/2019/09/06/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"title":"链表及其常用操作","text":"链表是什么？学过数据结构的人都很清楚，链表就是一种最最最基本的数据结构，基本到什么程度呢？基本到数据结构课上所学的数据结构都可以用链表来实现。 正因为其基础，我们更要了解链表的基本操作。 链表的构成及基本操作 首先了解链表（单向）的构成：链表由一个个统一的节点构成，节点一般由两个变量构成： 一个值，可以为各种类型 一个指向下一个节点的“指针” 链表的基本操作和多数数据结构相同，即插入，删除，查找等等。均很简单，也不再赘述，主要说说插入操作： 从头插入：新建的节点插入到链表头部 从尾插入：新建的节点插入到链表尾部 从任意位置插入：字面意思。 下面实现链表的构成及其基本操作（LeetCode 对应题目：707. 设计链表） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class MyLinkedList { private class Node{ int val; Node next; Node(int val){ this.val = val; this.next = null; } } private Node head,tail; private int size; /** Initialize your data structure here. */ public MyLinkedList() { Node node = new Node(0); this.head = node; this.tail = node; this.size = 0; } /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */ public int get(int index) { if (index &lt; 0 || index &gt;= this.size) return -1; Node node = head; for (int i = 0; i &lt; index; i++){ node = node.next; } return node.val; } /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */ public void addAtHead(int val) { if (this.size == 0) this.head.val = val; else { Node tmp = new Node(val); tmp.next = head; this.head = tmp; } this.size++; } /** Append a node of value val to the last element of the linked list. */ public void addAtTail(int val) { if (this.size == 0) this.tail.val = val; else { Node tmp = new Node(val); this.tail.next = tmp; this.tail = tmp; } this.size++; } /** * Add a node of value val before the index-th node in the linked list. * If index equals to the length of linked list, * the node will be appended to the end of linked list. * If index is greater than the length, the node will not be inserted. */ public void addAtIndex(int index, int val) { if (index &gt; this.size) return; if (index == this.size) { addAtTail(val); } else if (index &lt;= 0) { addAtHead(val); } else { Node node = new Node(val); Node tmp = head; for(int i = 1; i &lt; index; i++) { tmp = tmp.next; } node.next = tmp.next; tmp.next = node; this.size++; } } /** Delete the index-th node in the linked list, if the index is valid. */ public void deleteAtIndex(int index) { if (index &lt; 0 || index &gt;= this.size) return; if (index == 0) { this.head = this.head.next; } else { Node node = head; for (int i = 1; i &lt; index; i++) { node = node.next; } node.next = node.next.next; if (index == this.size-1) { tail = node; } } this.size--; }} 链表的反转 什么是反转，简单来说，就是将 12345 变为 54321 ，这便是反转。就链表而言，反转操作一般要求原地操作，尽可能减少空间使用，并且不允许直接改变链表的值。 表面来看反转好像很简单，但是实质上真正写起来也不是那么简单。链表操作的重难点，就是要防止链表断链丢失，所以，为了实现反转操作，我们需要三个节点指针，其过程如下图所示： 链表反转1.png 反转的代码如下： 12345678910private ListNode flipList(ListNode ptr, ListNode tail) { ListNode newHead = null; while (ptr != tail) { ListNode next = ptr.next; ptr.next = newHead; newHead = ptr; ptr = next; } return ptr;} 实质上就是将链表的箭头给翻转过来，而为了使链表不断链丢失，所以引入了三个指针。 LeetCode 相关问题： 206. 反转链表 92. 反转链表II 234. 回文链表 链表排序 链表排序可以直接将数组排序的算法代入其中，选择，归并啥的，只需要注意指针的完整性即可，下面附上链表的归并排序的函数（即：148. 排序链表）： 12345678910111213141516171819202122232425262728293031323334class Solution { public ListNode sortList(ListNode head) { if (head == null || head.next == null) return head; ListNode quick, slow; quick = head.next; slow = head; while (quick != null &amp;&amp; quick.next != null) { quick = quick.next.next; slow = slow.next; } ListNode mid = slow.next; slow.next = null; ListNode head1 = sortList(head); ListNode head2 = sortList(mid); ListNode newHead = new ListNode(-1); ListNode ptr = newHead; while (head1 != null &amp;&amp; head2 != null) { if (head1.val &lt; head2.val) { ptr.next = head1; head1 = head1.next; } else { ptr.next = head2; head2 = head2.next; } ptr = ptr.next; } ptr.next = head1 == null ? head2 : head1; return newHead.next; }} LeetCode 其余相关问题： 143. 重排链表 147. 对链表进行插入排序","link":"/2019/09/11/%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"练习（二）","text":"算法竞赛入门经典（第二版）—— 第二章习题 此为练手简单习题，觉得挺有意思，并且第一次处理之时想的过于简单或者处理有误，故贴出来作为提醒，并分享处理方案，仅供参考！ 习题 2-5：分数化小数 输入正整数a,b,c，输出a/b的小数形式，精确到小数点后c位。a,b ≤ \\(10 ^6\\) ，c ≤ 100。输入包含多组数据, 结束标记为a=b=c=0。 样例输入： 1 6 4 0 0 0 样例输出： Case 1: 0.1667 该题以普通想法来说，是直接进行输出，但是存在着两个问题： 输出的小数位数为c，不好直接进行输出 c ≤ 100 ，由于C语言小数位数的限定，就算 double 类型，其小数位数也不可能达到100位，具体位数可自己进行试验，所以直接进行输出时会有严重的精度损失 由以上，我们可以针对C语言整数除法的特点，间接计算小数的值 代码： 12345678910111213void Decimal(int a, int b, int c){ int i = 1; printf(\"%d.\", a/b); // 输出非小数位 a = a % b; while (i++ &lt; c){ // 小数点后前 c-1 位 a *= 10; printf(\"%d\", a/b); a = a % b; } a *= 10; /* 小数点后第 c 位进行四舍五入 */ printf(\"%d\\n\", ((a%b)*10)/b &gt;= 5 ? (a/b+1):(a/b));} 以上代码，直接采用函数方式进行分数转小数原理的实现，将多次输入省略 注：上述代码实现原理参考Artprog的CSDN博客C语言 分数化小数 习题2-6：排列 用1,2,3，……9组成3个三位数 abc , def 和 ghi，每个数字恰好使用一次，要求 abc:def:ghi=1:2:3。按照 “abc def ghi” 格式输出所有接。 样例输入 无 样例输出 abc def ghi 此题我基本想法确立之后：循环判断 abc 2abc 3abc 三个数各位 1~9 每个数字是否恰好使用一次，在判断是否使用之时，却遇到了一些困难，参考博客之后，有了如下解法： 采用一个布尔类型数组，下标表示数字，储存的值表示数字是否被用到(false or true)，如果数组下标1~9全部为储存的值全部为 true，就进行输出。 代码： 12345678910111213141516171819void Permutation(){ int i, j, k; bool isAppear[10]; // 定义判别数组 for (i = 123; i &lt; 330; i++){ memset(isAppear, false, sizeof(isAppear)); j = 2*i; k = 3*i; // 处理数组 isAppear[i/100] = isAppear[(i/10)%10] = isAppear[i%10] = true; isAppear[j/100] = isAppear[(j/10)%10] = isAppear[j%10] = true; isAppear[k/100] = isAppear[(k/10)%10] = isAppear[k%10] = true; // 判断 1-9 九个数是否都用到 for (int l = 1; l &lt; 10; l++) { if (isAppear[l] == false) break; if (l == 9) printf(\"%5d%5d%5d\\n\", i, j, k); } }} 注：上述代码参考Lecholin的博客《算法竞赛入门经典》习题2-6 三位数排列","link":"/2018/09/22/%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"队列","text":"队列是具有一定操作约束的线性表，只能在一端（队尾）进行插入，另一端（队头）进行删除。 简单地理解，按照字面意思，队列这种数据结构，就如同生活中排队的队列一般，后来的人（数据）只能跟在队尾，而队首的人（数据）首先接受服务（进行删除）。 数据插入：入队列 （addQueue） 数据删除：出队列 （deleteQueue） 而队列主要的特性如下： 先来先服务 先进先出：FIFO 类型名称：队列（Queue） 数据对象集：一个有0个或多个元素的有穷线性表 操作集：长度为 MaxSize 的队列 Q 属于 Queue， 队列元素 item 属于 ElementType 123451. Queue CreatQueue() 生成空队列2. int IsFullQ(Queue PtrQ) 判断队列Q是否已满3. void AddQ(Queue PtrQ, ElementType item) 将数据元素item插入队列Q中4. int IsEmptyQ(Queue PtrQ) 判断队列是否为空5. ElementType DeleteQ(Queue PtrQ) 将对头数据元素从队列中删除并返回 队列的顺序储存实现 利用数组来实现相关操作 直接利用数组实现 数组的一端作为头，另一端作为尾，这样的方式是比较容易实现的： 首先在空数组上的将队列头和尾均放在数组头的前一个位置，头和尾的标号为-1 添加元素之后，则将队尾保存的标号加一；同理删除元素之后，将队头的元素加一 存在的问题： 如果队放满，也就是队尾下标为 MaxSize-1 但此时队头由于删除元素的原因，还空有位置，因此会造成空间浪费。 利用环形数组实现 环形数组并不是物理意义上的环形，而是指队列如果放满之后（队尾下标为 MaxSize-1 ），数组头部如果还有空位，就将新加进来的元素，从数组头继续存放。这时，如何判断队列是否已满呢？ 判断队列空和满 空：队头下标等于队尾下标 满：队尾下标加一等于对头下标，但如果此时队尾下标而队头为0则无法用此法判断 改进：最大队尾下标加一除以 MaxSize 的余数等于队尾下标（除数大于被除数，余数为被除数本身） 正因为上述所说，平常所说的 顺序存储 实现均是以 指环形数组 的方式实现。 首先写出 Queue.h ，C语言代码如下： C语言代码： 1234567891011121314151617181920212223242526272829//// Created by wenmang on 2019/8/2.//#ifndef DATA_STRUCTURE_QUEUE_H#define DATA_STRUCTURE_QUEUE_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define BASE_SIZE 8typedef int elementType;typedef struct QNode *queue;struct QNode{ elementType* data; // 队列数据存储位置 int size; // data 数组大小 int rear; // 队尾 int front; // 队首};queue createQueue();bool isFull(queue q);bool isEmpty(queue q);void addQueue(queue q, elementType e);elementType deleteQueue(queue q);#endif //DATA_STRUCTURE_QUEUE_H 紧接着，我们在 Queue.c 文件中实现头文件中所申明的函数： C语言代码： 12345678910111213141516171819202122232425262728293031323334353637//// Created by wenmang on 2019/8/2.//#include &lt;assert.h&gt;#include \"Queue.h\"queue createQueue() { queue q = (queue) malloc(sizeof(struct QNode)); q-&gt;size = 8; q-&gt;data = (elementType*) malloc(q-&gt;size * sizeof(elementType)); q-&gt;front = q-&gt;rear = 0; return q;}bool isFull(queue q) { return (q-&gt;rear+1) % q-&gt;size == q-&gt;front;}bool isEmpty(queue q) { return q-&gt;rear == q-&gt;front;}void addQueue(queue q, elementType e) { if (isFull(q)) { q-&gt;size *= 2; q-&gt;data = (elementType*) realloc(q-&gt;data, q-&gt;size * sizeof(elementType)); } q-&gt;rear = (q-&gt;rear+1) % q-&gt;size; q-&gt;data[q-&gt;rear] = e;}elementType deleteQueue(queue q) { assert(!isEmpty(q)); q-&gt;front = (q-&gt;front+1) % q-&gt;size; return q-&gt;data[q-&gt;front];} 队列的链式储存实现 也就是使用链表存储 首先可以写出头文件 Queue.h 的内容： 12345678910111213141516171819202122232425262728//// Created by wenmang on 2019/8/2.//#ifndef DATA_STRUCTURE_QUEUE_H#define DATA_STRUCTURE_QUEUE_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef struct LQNode* lQueue;struct Node{ elementType data; struct Node* next;};struct LQNode{ struct Node* rear; struct Node* front;};lQueue createlQueue();void addlQueue(lQueue q, elementType e);elementType deletelQueue(lQueue q);bool islEmpty(lQueue q);#endif //DATA_STRUCTURE_QUEUE_H 用链表储存，设计了两个结构， Node 为队列中节点，指针指向下一个节点，data 储存节点数据 QNode 为队列头节点，两个指针分别指向队列头和队列尾 然后，在 Queue.c 文件中实现声明的函数： 1234567891011121314151617181920212223242526lQueue createlQueue() { lQueue q = (lQueue) malloc(sizeof(struct LQNode)); q-&gt;front = q-&gt;rear = NULL; return q;}void addlQueue(lQueue q, elementType e) { struct Node* tmp = (struct Node*) malloc(sizeof(struct Node)); tmp-&gt;data = e; if (q-&gt;front == NULL) q-&gt;front = q-&gt;rear = tmp; else q-&gt;rear = q-&gt;rear-&gt;next = tmp; q-&gt;rear-&gt;next = NULL;}elementType deletelQueue(lQueue q) { assert(!islEmpty(q)); struct Node* tmp = q-&gt;front; q-&gt;front = q-&gt;front-&gt;next; return tmp-&gt;data;}bool islEmpty(lQueue q) { return q-&gt;front == NULL;} 优点：链表储存无需判断是否队列已满","link":"/2019/08/02/%E9%98%9F%E5%88%97/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"底层","slug":"底层","link":"/tags/%E5%BA%95%E5%B1%82/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"模式识别","slug":"模式识别","link":"/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"有趣","slug":"有趣","link":"/tags/%E6%9C%89%E8%B6%A3/"},{"name":"练习","slug":"练习","link":"/tags/%E7%BB%83%E4%B9%A0/"},{"name":"小游戏","slug":"小游戏","link":"/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"算法思想","slug":"算法思想","link":"/tags/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"算法基础","slug":"算法基础","link":"/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"算法技巧","slug":"算法技巧","link":"/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"},{"name":"c","slug":"c","link":"/tags/c/"}],"categories":[]}