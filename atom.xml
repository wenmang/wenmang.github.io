<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>文的盲</title>
  
  
  <link href="https://wenmang.gitbub.io/atom.xml" rel="self"/>
  
  <link href="https://wenmang.gitbub.io/"/>
  <updated>2020-08-31T09:37:39.966Z</updated>
  <id>https://wenmang.gitbub.io/</id>
  
  <author>
    <name>文盲</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络传输层</title>
    <link href="https://wenmang.gitbub.io/2020/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://wenmang.gitbub.io/2020/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2020-08-30T07:36:13.000Z</published>
    <updated>2020-08-31T09:37:39.966Z</updated>
    
    <content type="html"><![CDATA[<p>传输层是计算机网络最为基本的一层，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;传输层是计算机网络最为基本的一层，&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://wenmang.gitbub.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://wenmang.gitbub.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络应用层</title>
    <link href="https://wenmang.gitbub.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://wenmang.gitbub.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-05-01T06:56:33.000Z</published>
    <updated>2020-08-31T09:37:21.511Z</updated>
    
    <content type="html"><![CDATA[<p>所谓应用层，便是指生活中一些基础的应用所处的层次，也就是我们日常所能够看到的，诸如 Web 网页，电子邮件等这些基础的应用所使用的协议。</p><p>本篇内容，主要说说最为重要、最为基础的 HTTP 协议。</p><a id="more"></a><h1 id="http协议">HTTP协议</h1><p>我们所浏览的 Web 网页，其主要是基于 HTTP 协议所搭建的。</p><p>HTTP 协议，英文全称为 Hyper Text Transfer Protocol （超文本传输协议），其是一种双端协议，也就是说，这个协议是有两个版本的，一个是服务端的协议一个是客户端的协议。</p><p>正如 <em>Computer Networking, A Top-Down Approach</em> 中所说的那样：HTTP defines how Web clients request Web pages from Web servers and how servers transfer Web pages to clients. HTTP 定义了 Web 客户端如何从 Web 服务器请求网页以及 Web 服务器<strong>如何</strong>向 Web 客户端传输结果。</p><h2 id="http报文格式">HTTP报文格式</h2><p>HTTP 规范包含了对HTTP报文格式的定义，正如上述所说，由于服务端与客户端的不同，共有两种报文。</p><h3 id="http-请求报文">HTTP 请求报文</h3><p>下面是一个典型的HTTP请求报文，来自我请求百度主页时候的报文复制（并未按顺序全部复制）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.135 Safari&#x2F;537.36</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br></pre></td></tr></table></figure><p>首先可知，报文时使用 ASCII 编码书写的；然后，可以按照规定，将请求报文分为三个部分：请求行（Request Line），请求头（Header Lines），请求体（Entity body）。</p><p>以上面的例子来说明上述几个部分：</p><ul><li><p>第一行也就是请求行，其对应关系为：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">请求方法 请求路径 请求协议&#x2F;协议版本</span><br></pre></td></tr></table></figure></p></li><li><p>然后便是请求头，其由冒号后加一空格将头和值隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host: www.baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>随着一个空行，之后的内容便是请求体，使用 <code>GET</code> 方法时，并没有请求体，所以上面的请求报文中并没有请求体。</p></li></ul><p>综上所述，其格式如下图所示：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/29/XVgCimrhkTYFjd6.jpg" alt="请求报文格式" /><figcaption>请求报文格式</figcaption></figure><ul><li>其中，<code>sp</code> 为空格，<code>cr</code> 为回车，<code>lf</code> 为换行。</li></ul><h3 id="http响应报文">HTTP响应报文</h3><p>既然有请求，那就会有响应，下面是一个典型的HTTP响应报文，也是来自我请求百度主页时候的报文复制（并未按顺序全部复制）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text&#x2F;html;charset&#x3D;utf-8</span><br><span class="line">Date: Fri, 01 May 2020 09:32:25 GMT</span><br><span class="line">Expires: Fri, 01 May 2020 09:32:25 GMT</span><br><span class="line">Server: BWS&#x2F;1.1</span><br></pre></td></tr></table></figure><p>同样，也可以按照规定，将响应报文分为三个部分：响应行（Status Line），响应头（Header Lines），响应体（Entity body）。</p><ul><li><p>第一行为响应行，其对应关系为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">协议名&#x2F;协议版本 状态码 描述状态码的短语</span><br></pre></td></tr></table></figure></li><li><p>之后的各行为响应头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>同样随着一个空行，之后的内容便是响应体，响应来的一般是一个 HTML 文件。</p></li></ul><p>综上所述，其格式如下图所示：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/29/jryFzWVZAkbqRL8.jpg" alt="响应报文格式.jpg" /><figcaption>响应报文格式.jpg</figcaption></figure><h2 id="cookies">Cookies</h2><p>由于 HTTP 服务是无状态的，但是日常中，Web 站点更希望能识别用户，提供个性化服务或者限制用户的访问，为了达到这个目的，HTTP 使用了cookie 。</p><p>Cookie 有四个重要的组件：</p><ul><li>HTTP 响应报文有一个 cookie 首部行</li><li>HTTP 请求报文有一个 cookie 首部行</li><li>用户端系统保存有一个 cookie 文件</li><li>Web 站点有一个后端数据库</li></ul><h3 id="首次访问">首次访问</h3><ul><li><p>首次使用浏览器访问某个 Web 网站，Web 站点产生一个唯一的识别码，以该索引码作为索引在后端数据库中产生一个新的表项。然后在响应报文中加入 <code>Set-cookie</code> 的头部，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie: 1678</span><br></pre></td></tr></table></figure></li><li><p>浏览器收到了 HTTP 响应报文，识别 <code>Set-cookie</code> 之后，会在其管理的 cookie 文件中添加一行（包括服务器的主机名和 <code>Set-cookie</code> 中的识别码）。</p></li></ul><p>此时，初次添加 cookie 便完成了，那么之后，你在该网站的一举一动都会被记录，无论是你浏览了什么还是点击了什么。</p><h3 id="再次访问">再次访问</h3><p>几天之后，你又一次访问该网站。</p><ul><li><p>浏览器会在 cookie 文件中检测是否有该网站的 cookie ；如果有，便会将保存的 cookie 作为请求报文的头发给服务端，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie: 1678</span><br></pre></td></tr></table></figure></li><li><p>服务端根据你的 cookie 读取你的信息，并根据此值查询数据库的信息，给你推荐相关产品或者广告。</p></li></ul><p>cookie 的本意是简化一些操作，但是经常被滥用，借此收集用户的信息，甚至收集后将信息卖给第三方，实实在在地侵害了用户的隐私。</p><h2 id="web-缓存">Web 缓存</h2><p>缓存服务器或者代理服务器，其实很容易理解，就是一个服务器与客户端之间的中转。而这部分的重心，我觉得是实实在在理解缓存带来的优势。</p><h3 id="缓存演示">缓存演示</h3><p>有这样一个简单的网络模型<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/29/vTFY7nsXmMgbW5f.jpg" alt="简单网络结构.jpg" /><figcaption>简单网络结构.jpg</figcaption></figure><p>假设，机构网络（Institutional network）中一个请求从发出到接收到共需要 2 秒，可将其非正式地称之为 “Internet delay”（因特网时延）；假设现在每秒发送 15 个请求，每个请求平均长度为 1Mbits 。</p><ul><li>首先估算机构局域网中的流量强度：<span class="math inline">\((15 请求/秒)⋅\frac{1 Mb/请求}{100 Mbps} =0.15\)</span></li><li>然后估算接入链路上的流量强度：<span class="math inline">\((15 请求/秒)⋅\frac{1 Mb/请求}{15 Mbps} = 1\)</span></li></ul><p>链路上流量强度达到了 1 ，网络时延会变得无限大，这显然是不行的。</p><p>于是使用一个 Web 缓存，将网络结构变为下图这种方式：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/29/qtw8e5kXIMrJEnN.jpg" alt="加入缓存的网络结构.jpg" /><figcaption>加入缓存的网络结构.jpg</figcaption></figure><p>和上面的假设一样，除此之外，假设命中率（一个缓存器所满足的请求的比率）为 0.4 。那么便会有 40% 的请求由缓存服务器处理，60% 的缓存由初始服务器满足。</p><p>由于原来的 100% 变为了现在的 60% ，流量强度也由 1.0 变为 0.6 ，一般来说，流量强度小于 0.8 的时候，时延约为几十毫秒。此时需要花费的时间为：</p><p><span class="math display">\[0.4 \times (0.010)秒 \ + \ 0.6 \times (2.01秒) = 1.21秒\]</span></p><p>效果可见一斑了。</p><h3 id="更新缓存">更新缓存</h3><p>缓存是会过期的，因为目标服务器不可能总时一成不变的，一旦服务器发生了更新，那么缓存还维持原来的内容便有点说不过去了。</p><p>更新缓存所使用的是 条件GET方法 ，条件 GET 为了减少传输的数据量，只发送一个包含简单几个头的GET请求，来询问服务器数据是否发生了改变，一般如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;fruit&#x2F;kiwi.gif HTTP&#x2F;1.1</span><br><span class="line">Host: www.exotiquecuisine.com</span><br><span class="line">If-modified-since: Wed, 9 Sep 2015 09:23:24</span><br></pre></td></tr></table></figure><p>其中 <code>If-modified-since</code> 头的日期数据，就是缓存服务器中数据的更新日期，如果并未发生改变，服务器会发送一个空的响应，并设置状态码为 304 ，并不会像普通的GET的响应一样，会发送网页或者请求的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 304 Not Modified</span><br><span class="line">Date: Sat, 10 Oct 2015 15:39:29</span><br><span class="line">Server: Apache&#x2F;1.3.0 (Unix)</span><br><span class="line"></span><br><span class="line">(empty entity body)</span><br></pre></td></tr></table></figure><h2 id="http版本">HTTP版本</h2><p>现行的 HTTP 协议经历了几个重要的版本更迭，分别是 <code>1.0</code> ，<code>1.1</code> 以及最新的 <code>2.0</code>。</p><p><code>HTTP 1.0</code> 是最为基础的版本，所以拥有最基本的 HTTP 功能，其至今仍被广泛采用，关于 <code>HTTP 1.0</code> 的相关内容，并不需要过于长篇大论的介绍。</p><p><code>HTTP 1.1</code> 是在 <code>1.0</code> 之后推出的一个版本，也是如今最为应用广泛的版本，所以重心应该集中在 <code>1.1</code> 对 <code>1.0</code> 的改进。在 <code>1.1</code> 中，引进了Persistent Connections等新特性，做出了重要改进。</p><h3 id="persistent-connections">Persistent Connections</h3><p>Persistent Connections（持久性连接）是在 <code>1.1</code> 之后加入的新特性。</p><p>在 <code>1.0</code> 的时候，一次连接只能发送和接收一次请求，也就是说，假如有一个网页，网页上有 10 张图片，那么这时候，便需要进行 11 次 TCP 连接，每个文件传输完毕之后都会关闭 TCP 连接，这就造成了极大的时间浪费。并且每个请求代对象都需要建立和维护一个全新的连接，在客户端和服务器中分配 TCP 缓冲区和保持 TCP 变量，这也会给 Web 服务器带来严重的负担。</p><p>而 <code>1.1</code> 之后，默认都是长连接，也就是在处理事务结束之后也不会将 TCP 连接关闭，而是继续保持以便复用，这就节省了很大一部分不必要的时间。</p><p>其实 <code>1.0</code> 中，添加请求头 <code>Connection: Keep-Alive</code> 也能够达到长连接的效果，但是随着互联网的发展，网页内容逐渐丰富，并不像 <code>1.0</code> 时代那样只有一个网页和几张图片了，所以干脆在 <code>1.1</code> 之后直接默认为持久性连接了。</p><p><strong>其实 <code>1.1</code> 还加入了不少新特性，只是我没有深入了解，就不再赘述了</strong>。</p><h3 id="http-2.0">HTTP 2.0</h3><p><code>HTTP 2.0</code> ，既然大版本号发生了更迭，那么就意味着 <code>2.0</code> 是下一代 HTTP 协议。当然，这个版本目前应用还非常少。</p><p><code>2.0</code> 版本最大的特点是加入了多路复用技术，在不改动原语义、方法等核心概念的基础上，增加了<strong>二进制分帧层</strong>。<code>HTTP 2.0</code> 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码 ，其中 <code>HTTP1.x</code> 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p><h2 id="https">HTTPS</h2><p>HTTP 协议在传送消息时，是明文发送的，如果有人截取传送的消息，那么你的一切将会暴露在他面前，包括你的信用卡号甚至密码。</p><p>网景公司于 1994 年首次提出，将HTTP的数据包利用 SSL/TLS 进行加密，从而提供对网站服务器的身份认证，以及保证资料交换的隐私性与完整性，后来才扩展到整个互联网上<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>。</p><h3 id="http-与-https3">HTTP 与 HTTPS<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></h3><ul><li>HTTP 默认使用 80 端口；HTTPS 默认使用 443 端口。</li><li>严格来说 HTTPS 并不是一个单独的协议，而是对工作在加密连接（TLS或SSL）上的常规 HTTP 协议的称呼。</li><li>要使一网络服务器准备好接受HTTPS连接，管理员必须创建一数字证书，并交由证书颁发机构签名以使浏览器接受。证书颁发机构会验证数字证书持有人和其声明的为同一人</li></ul><h1 id="参考链接">参考链接</h1><section class="footnotes"><hr /><ol><li id="fn1"><p>文中所有的图片都来源于教材 <em>Computer Networking, A Top-Down Approach</em> 英文版。<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p><a href="https://zhuanlan.zhihu.com/p/37387316">似水流年的知乎文章：HTTP协议几个版本的比较</a><a href="#fnref2" class="footnote-back">↩</a></p></li><li id="fn3"><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">维基百科：超文本传输协议</a><a href="#fnref3" class="footnote-back">↩</a></p></li><li id="fn4"><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">维基百科：超文本传输协议</a><a href="#fnref4" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;所谓应用层，便是指生活中一些基础的应用所处的层次，也就是我们日常所能够看到的，诸如 Web 网页，电子邮件等这些基础的应用所使用的协议。&lt;/p&gt;
&lt;p&gt;本篇内容，主要说说最为重要、最为基础的 HTTP 协议。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://wenmang.gitbub.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://wenmang.gitbub.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://wenmang.gitbub.io/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://wenmang.gitbub.io/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2020-04-27T06:11:39.000Z</published>
    <updated>2020-08-31T09:37:47.805Z</updated>
    
    <content type="html"><![CDATA[<p>所谓二十一世纪是生物的世纪，在生物的曙光还未照亮之际，我们的生活却实实在在地被计算机所改变，被计算机网络所改变。</p><p>计算机网络，现今，通过光纤将许许多多计算机组在一起，以联通你和世界；通过互联网协议，使数据可以“安全稳定”地传输、解析，将一条条信息送到你眼前。</p><a id="more"></a><h2 id="osi服务参考模型">OSI服务参考模型</h2><p>OSI参考模型是一种计算机网络的理论模型，其按照功能将计算机网络自上而下分为了 7 层：</p><ol type="1"><li>应用层：主要是一些服务/协议，用于完成某项特殊功能<ul><li>文件传输协议：<code>FTP</code></li><li>电子邮件协议：<code>SMTP</code></li></ul></li><li>表示层：用于处理两个系统之间交换信息的<strong>语法与语义</strong>问题<ul><li>信息的加密与解密</li><li>信息的压缩与解压</li></ul></li><li>会话层：用于会话控制<ul><li>建立、维护会话</li></ul></li><li>传输层：负责<strong>源-目的（端到端）（进程间）</strong>完整的报文传输<ul><li>分段与重组</li><li>连接、流量、差错控制等</li></ul></li><li>网络层：控制子网运行，将网络地址翻译为物理地址<ul><li>逻辑编址</li><li>分组传输，路由选择等</li></ul></li><li>数据链路层：负责节点到节点的数据传输<ul><li>物理寻址</li><li>连接、流量、差错控制等</li></ul></li><li>物理层：指定物理底层的标准<ul><li>接口标准：形状、电压等</li><li>编码方式、数据率等</li></ul></li></ol><h2 id="tcpip参考模型">TCP/IP参考模型</h2><p>虽然理论上给出了OSI参考模型，但是在实际设计的时候，并未采用OSI参考模型。而TCP/IP模型却是在拥有协议之后，总结出来的。</p><p>TCP/IP参考模型将OSI中的应用层、表示层、会话层和三为一，统称其为应用层，然后将数据链路层与物理层合并，称之为网络接口层（<strong>这两个也常不做合并</strong>）。</p><ol type="1"><li>应用层：支持各种网络应用（应用层，表示层，会话层的组合）<ul><li><code>FTP</code>、<code>SMTP</code>、<code>HTTP</code></li></ul></li><li>传输层：进程-进程之间的数据传输<ul><li><code>TCP</code>、<code>UDP</code></li></ul></li><li>网络层：源主机到目的主机的数据分组路由与转发<ul><li><code>IP</code> 协议、路由协议等</li></ul></li><li>网络层接口层（这层也常被展开，并看作5层参考模型）：<ul><li>物理层：比特传输</li><li>数据链路层：相邻网络元素的数据传输<ul><li>以太网</li><li>WIFI（802.11）</li></ul></li></ul></li></ol><h2 id="附言">附言</h2><p>建立了计算机网络体系结构，那么便可以清晰地逐层学习计算机网络了。</p><p>而学习计算机的两派——“自顶向下”和“自底向上”也便是这么产生的。由应用层学到物理层便是“自顶向下”；那么显然，由物理层学到应用层便是“自底向上”了。</p><p>我是结合哈工大的慕课学习的，其是采用“自顶向下”的学习步骤，我也就跟随这个脚步一起来学习了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;所谓二十一世纪是生物的世纪，在生物的曙光还未照亮之际，我们的生活却实实在在地被计算机所改变，被计算机网络所改变。&lt;/p&gt;
&lt;p&gt;计算机网络，现今，通过光纤将许许多多计算机组在一起，以联通你和世界；通过互联网协议，使数据可以“安全稳定”地传输、解析，将一条条信息送到你眼前。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://wenmang.gitbub.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://wenmang.gitbub.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>二分查找细则</title>
    <link href="https://wenmang.gitbub.io/2020/01/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E5%88%99/"/>
    <id>https://wenmang.gitbub.io/2020/01/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E5%88%99/</id>
    <published>2020-01-10T13:47:55.000Z</published>
    <updated>2020-04-12T06:05:13.225Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="关于二分查找">关于二分查找</h3><p>二分查找或许是很多人学习的第一个算法，其简洁明快，但是在实际应用中，你却会看到许多种写法的二分查找，而这些写法，仅是细节处的区别。</p><p>这些不同写法的二分查找，究竟哪一个才是正确的？还是，无论怎么写，达到目的便可以称之为二分查找？</p><a id="more"></a><h3 id="常规写法一">常规写法一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">        <span class="comment">// 防止溢位</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == key)<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法便是我所学习的，或许也是大多数人所学习的，如果存在，其查找过程如下：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/02/11/dtCQwWfY148glZG.png" alt="二分_1.png" /><figcaption>二分_1.png</figcaption></figure><p>如果目标不存在，则查找过程如下所示：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/02/11/1cM6yLYjxogOJ9A.png" alt="二分_2.png" /><figcaption>二分_2.png</figcaption></figure><p>如上种写法，注意，<strong>在参数传入的时候，数组的两边都是封闭的</strong>，也就是说，在传入数组的时候，需要传入 <code>length-1</code> ，使得 <code>end =length-1</code>。</p><h3 id="常规写法二">常规写法二</h3><p>但是，好多人可能还见到过另一种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">        <span class="comment">// 防止溢位</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == key)<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">            end = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= arr.length)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[start] == key ? start : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此种写法与上种写法的差异：</p><ul><li><code>start &lt;= end</code> 变为 <code>start &lt; end</code></li><li><code>end = mid - 1</code> 变为 <code>end = mid</code></li></ul><p>经过以上改动，其传参之时，便是一个<strong>左闭右开</strong>的区间了，如需传入整个数组，则直接传入 <code>length</code> 即可，</p><p>那么<strong>为何如此</strong>？</p><h3 id="一与二的差异">一与二的差异</h3><p>第一种与第二种写法，实质上是相同的，而所产生了写法上差异的原因，本质在于<strong>区间范围的不同。</strong></p><p>和所有算法一般，代码希望<strong>不重复，不遗漏地解决问题</strong>，故产生了两种不同的细节。</p><h4 id="写法一的细节">写法一的细节</h4><p>正如我在写法一最后所说，<strong>写法一的左右区间都是封闭的</strong>。</p><ul><li><code>end = mid - 1</code><ul><li>在搜索判断的时候，只要<code>arr[mid] &gt; key</code>的时候，我们接下来要做的便只是<strong>缩短区间</strong>，<strong>将区间缩为 <code>[start, mid-1]</code></strong></li><li>由于此区间便是左右封闭的，那么直接写为<code>end = mid - 1</code> 即可。</li></ul></li><li><code>start &lt;= end</code><ul><li>为何这么写？答为：<strong>为了方便</strong>。</li><li>如果写为 <code>start &lt; end</code>，那么，代码有可能在 <code>start == end</code> 的时候终止，而 <code>key</code> 有可能恰好就在 <code>start</code> 处，这时候，返回 <code>-1</code> 显然是不合适的。</li><li>写为 <code>start &lt; end</code> 可不可以？<ul><li><strong>可以</strong>，当然，你需要在跳出循环之后进一步判断，当然，此时不能单纯地使用 <code>arr[start]</code> ，可能会超出数组索引，比较麻烦。</li></ul></li></ul></li></ul><h4 id="写法二的细节">写法二的细节</h4><p><strong>第二种写法一开始便认为区间是左闭右开的。</strong></p><ul><li><code>end = mid - 1</code><ul><li>同样地，<code>arr[mid] &gt; key</code>之时，也需要缩短区间至 <code>[start, mid-1]</code></li><li>由于第二种写法是<strong>左闭右开</strong>的，也就是说要将区间缩为 <code>[start, mid)</code>，故需要写为 <code>end = mid</code></li></ul></li><li><code>start &lt; end</code><ul><li>为何这么写？答为：<strong>为了不陷入死循环。</strong></li><li>和上面为了方便不同，此处如果写为 <code>&lt;=</code> 便会直接出错<ul><li>如果写为 <code>&lt;=</code> 如果此时刚好 <code>mid == start == end</code> 并且 <code>arr[mid] &gt; key</code> ，便一直会执行 <code>end == mid</code>，从而导致 <code>start === end</code>，从而造成死循环！</li><li>第一种写法则不同，其是 <code>end = mid - 1</code> ，可以直接跳过。</li></ul></li></ul></li></ul><h3 id="查找左侧边界">查找左侧边界</h3><p>当数组有重复元素时，比如：<code>[1, 2, 2, 2, 2, 3, 4, 5]</code>，此时若需要寻找一个元素，我们更希望寻找到一个边界的元素，比如寻找 <code>2</code> ，我们更希望寻找到最左边的 <code>2</code> 或者是最右边的 <code>2</code>。</p><p>寻找左侧边界，便是这种寻找最左边元素的二分算法。</p><p>首先贴出代码让大家感受一番：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">        <span class="comment">// 防止溢位</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= key)</span><br><span class="line">            end = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面对于细节的描述，我想，现在便可以很容易地看出：</p><ul><li>上边的代码会停在最左边的元素上（如果有这个元素的话）。</li><li>上边的代码会停在小于查找的元素中最大的那个上（如果没有这个元素的话）</li></ul><h3 id="查找右侧边界">查找右侧边界</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">upperBound</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">        <span class="comment">// 防止溢位</span></span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">            end = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，可以看出：</p><ul><li>上述代码如果直接返回，那么查找的便是大于查找元素中最小的元素，即便数组中有所要查找的元素。</li><li>如果需要严格地查找右边界，那么可以返回 <code>start-1</code></li></ul><h3 id="附录">附录</h3><p>其实上面所说的，所写的都可以作为一个模板来使用，通过更改终止条件等方式达到自己想要的目的！</p><p>比如，<code>leetcode</code> 上一些打着二分搜索的题目！</p><h3 id="参考">参考</h3><p><a href="https://zhuanlan.zhihu.com/p/79553968">知乎专栏：二分查找细节详解</a></p><p><a href="https://www.bilibili.com/video/BV1yW411Z7um">花花酱：二分查找的视频</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;关于二分查找&quot;&gt;关于二分查找&lt;/h3&gt;
&lt;p&gt;二分查找或许是很多人学习的第一个算法，其简洁明快，但是在实际应用中，你却会看到许多种写法的二分查找，而这些写法，仅是细节处的区别。&lt;/p&gt;
&lt;p&gt;这些不同写法的二分查找，究竟哪一个才是正确的？还是，无论怎么写，达到目的便可以称之为二分查找？&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://wenmang.gitbub.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="细节" scheme="https://wenmang.gitbub.io/tags/%E7%BB%86%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>花里胡哨的位运算</title>
    <link href="https://wenmang.gitbub.io/2019/11/22/%E8%8A%B1%E9%87%8C%E8%83%A1%E5%93%A8%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://wenmang.gitbub.io/2019/11/22/%E8%8A%B1%E9%87%8C%E8%83%A1%E5%93%A8%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2019-11-22T10:45:25.000Z</published>
    <updated>2019-11-22T13:58:36.906Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>位运算，虽然说是一种十分精妙的算法技巧，但是除了花里胡哨好像并不能大幅提升时间复杂度。虽说如此，但不得不说，位运算的诸多技巧还是非常有趣的！</p><h3 id="初识位运算">初识位运算</h3><p>初次见到位运算的应用，那是在一个夏天的下午，有同学在班群问：“如何写交换函数？”不久，有人贴了这么段代码：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">    *a ^= *b;</span><br><span class="line">    *b ^= *a;</span><br><span class="line">    *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我一脸懵，这都行？这是怎么交换的？异或还能这么使？记得那天我在草稿纸上花了半天，才搞懂了个大概：</p><p>我们以 <code>3</code> 和 <code>6</code> 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始状态时：a &#x3D; 3 &#x3D; 011b &#x3D; 6 &#x3D; 110</span><br><span class="line">第一句执行：     a &#x3D; 101b &#x3D; 110</span><br><span class="line">第二句执行：a &#x3D; 101b &#x3D; 011 &#x3D; 3</span><br><span class="line">第三局执行：a &#x3D; 110 &#x3D; 6b &#x3D; 011 &#x3D; 3</span><br></pre></td></tr></table></figure><p>确实交换过来了，但为啥呢？但其实，我们可以将代码简单地变一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = (a ^ b) ^ b;</span><br></pre></td></tr></table></figure><p>使用交换律，也就是 <code>b = a ^ (b ^ b)</code> ，而这时，便可以清晰地看出来：因为一个数异或本身等于 <code>0</code> ，所以代码的前两句也便是 <code>b = a</code>。那 <code>a</code> 又是怎么变过来的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (a ^ b) ^ ((a ^ b) ^ b)</span><br></pre></td></tr></table></figure><p>同样，进行变换 <code>a = ((a ^ b) ^ (a ^ b)) ^ b</code> ，也就是 <code>a = b</code>，至此便完成了交换的操作。</p><h3 id="常见的位运算技巧">常见的位运算技巧</h3><p>位运算说是技巧，但实质上也是利用了逻辑运算的基本技巧：</p><ul><li>一个数异或自己本身为 <code>0</code></li><li>与或非的基本定义</li><li>……</li></ul><h4 id="只出现一次的数字-leetcode-136"><a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a> （<code>LeetCode 136</code>）</h4><p><strong>题目说明：</strong>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>题目解答：</strong>这道题便可以利用异或的性质，将数组元素挨个异或，便可以将所有成对的数据消去，最终剩下的，便是只出现了一次时数字。</p><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) </span><br><span class="line">            ret ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位1的个数leetcode-191"><a href="https://leetcode-cn.com/problems/number-of-1-bits/">位1的个数</a>（<code>LeetCode 191</code>）</h4><p><strong>题目说明：</strong> 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量">汉明重量</a>）。</p><p><strong>题目解答：</strong> 这题便是相当明显的需要利用位操作的题目，因为需要一位一位地判断。所以一边右移一边判断最右边那位是0还是1即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) ret++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 数字和1与，可以判断该数的奇偶！因为 1 的二进制是 <code>00...1</code> ，所以与完的结果便只有最后一位，<code>1</code> 为奇数，<code>0</code> 为偶数。</p><p>虽是如此，<a href="https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode/">官方</a>还给出来一个更为特殊的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>在二进制表示中，数字 <code>n</code> 中最低位的 <code>1</code> 总是对应 <code>n - 1</code> 中的 <code>0</code> 。因此，将 <code>n</code> 和 <code>n - 1</code> 与运算总是能把 <code>n</code> 中最低位的 <code>1</code> 变成 <code>0</code> ，并保持其他位不变。</p><p>所以，优化之后，只运算 <code>1</code> 的个数次即可！</p><h4 id="的幂leetcode-231"><a href="https://leetcode-cn.com/problems/power-of-two/">2的幂</a>（<code>LeetCode 231</code>）</h4><p><strong>题目说明：</strong> 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><p><strong>题目解答：</strong> 这题如果能想到 <code>位运算</code> 这仨字，那么便可以比较容易地想出算法，因为毕竟 2 的幂次在二进制中来看是“整”的，相当于十进制中的 <code>10...100...1000</code>等等！</p><p><strong>比如：</strong> 8的二进制表示为<code>1000</code>，<code>8-1</code> 也就是 <code>7</code> 的二进制为 <code>0111</code> 。如果把这俩数相与，不刚好是 <code>0</code> 吗？但是由于负数的补码问题，所以首先<strong>还需要判断是否正数</strong>。</p><p>所以可以<strong>写出代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; ((n &amp; (n-<span class="number">1</span>))== <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="的幂leetcode-342"><a href="https://leetcode-cn.com/problems/power-of-four/">4的幂</a>（<code>LeetCode 342</code>）</h4><p><strong>题目说明：</strong> 给定一个整数 (<code>32</code> 位有符号整数)，请编写一个函数来判断它是否是 <code>4</code> 的幂次方。</p><p><strong>题目解答：</strong> 这算是上题的进阶，如果熟悉二进制，便知道4的幂实质上用二进制来表示实质上为 <code>10</code> 间隔，<code>4 -&gt; 10</code> <code>16 -&gt; 10000</code> <code>64 -&gt; 1000000</code>。利用此特点，便可以发现这样一个数：<code>01010101010101010101...</code> ，也就是十六进制的 <code>0x55555555</code>，其和4的幂相与，不会改变 <code>0x55555555</code> 的值。</p><p>综上<strong>写出代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span> || (num &amp; (num-<span class="number">1</span>)) != <span class="number">0</span>)   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ((num &amp; <span class="number">0x55555555</span>) == num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> “<code>0x55555555</code>，其和4的幂相与，不会改变 <code>0x55555555</code> 的值”是一个充分条件，并非必要条件。故可能还有别的数和 <code>0x55555555</code>，其与4的幂相与，不会改变 <code>0x55555555</code> 的值，因此需要进行限制！即将非 <code>2</code> 的幂次和小于 <code>0</code> 的数除外。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;位运算，虽然说是一种十分精妙的算法技巧，但是除了花里胡哨好像并不能大幅提升时间复杂度。虽说如此，但不得不说，位运算的诸多技巧还是非常有趣的！&lt;/p&gt;
&lt;h3 id=&quot;初识位运算&quot;&gt;初识位运算&lt;/h3&gt;
&lt;p&gt;初次见到位运算的应用，那是在一个夏天的下午，有同学在班群问：“如何写交换函数？”不久，有人贴了这么段代码：&lt;/p&gt;</summary>
    
    
    
    
    <category term="博客" scheme="https://wenmang.gitbub.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="算法技巧" scheme="https://wenmang.gitbub.io/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>素数筛</title>
    <link href="https://wenmang.gitbub.io/2019/11/15/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <id>https://wenmang.gitbub.io/2019/11/15/%E7%B4%A0%E6%95%B0%E7%AD%9B/</id>
    <published>2019-11-15T11:49:46.000Z</published>
    <updated>2019-11-15T12:46:56.685Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>素数是一种作业或竞赛中较易考察的知识点，但好像在实际开发中用的不多【素数好像更多地用在网安领域】。总归，求取 <code>a~b</code> 之间的素数还是一种比较基本的算法技巧。</p><h3 id="新手求素数">新手求素数</h3><p>想当年，我刚学C语言的时候，便是这么写的，也就是直接暴力枚举：</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">int</span> prime[MAX_N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= b; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == i)</span><br><span class="line">            prime[count++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那时的我也还想到了比如 <code>2*3=6</code> 和 <code>3*2=6</code> 是等价的，所以判断素数的终止条件可以再压缩，也就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; ++j)</span><br></pre></td></tr></table></figure><h3 id="知道点啥之后">知道点啥之后</h3><p>后来我在看过某本书的序言之后，知道了只需要检测到 <span class="math inline">\(\sqrt i\)</span> 即可，可以将这种算法的时间复杂度可以进一步压缩 ，也就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= <span class="built_in">sqrt</span>(b); ++j)</span><br></pre></td></tr></table></figure><p>注意引入：<code>math.h</code></p><h3 id="素数筛">素数筛</h3><p>素数筛，顾名思义，就是将素数筛出来，而比较常见的有两种：</p><h4 id="eratosthenes筛法"><code>Eratosthenes</code>筛法</h4><p>埃氏筛是比较基本的一种筛法，其思想是：在处理掉所有不是质数的数（质数的倍数），然后，剩下的便全都是素数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(b, <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= b; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i*<span class="number">2</span>; j &lt;= b; j += i) &#123;</span><br><span class="line">            flag[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的埃氏筛都是返回一个布尔类型的数组，来得知是否质数的。</p><p>虽然此举将时间复杂度降为了 <span class="math inline">\(O(N log log N)\)</span>，但是可以发现，埃氏筛依旧具有重复操作，比如 <code>12</code> 在被 <code>2</code> 置 <code>false</code> 之后，还会被 <code>3</code> 置一遍，于是便有了改进之法。</p><h4 id="欧式筛法">欧式筛法</h4><p>欧式筛可以看作埃氏筛的一个改进，即不做重复操作，保证所有合数都是由其最小质因数标记的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[MAX_N] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> prime[MAX_N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= b; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">            prime[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count &amp;&amp; i*prime[j] &lt;= b; ++j) &#123;</span><br><span class="line">            flag[i*prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>C++</code> 的 <code>bool</code> 数组默认均为 <code>false</code>，所以索性用 <code>false</code> 标记质数（0和1在上述代码中并未置数为 <code>false</code>）。而最终的结果，储存在 <code>prime</code> 之中。</p><p>时间复杂度为：<span class="math inline">\(\omega (N)\)</span></p><h3 id="总结">总结</h3><p>可以发现，随着时间复杂度的降低，空间复杂度好像在升高了，尤其体现在两个筛法的实现之中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;素数是一种作业或竞赛中较易考察的知识点，但好像在实际开发中用的不多【素数好像更多地用在网安领域】。总归，求取 &lt;code&gt;a~b&lt;/code&gt; 之间的素数还是一种比较基本的算法技巧。&lt;/p&gt;
&lt;h3 id=&quot;新手求素数&quot;&gt;新手求素数&lt;/h3&gt;
&lt;p&gt;想当年，我刚学C语言的时候，便是这么写的，也就是直接暴力枚举：&lt;/p&gt;</summary>
    
    
    
    
    <category term="博客" scheme="https://wenmang.gitbub.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="算法技巧" scheme="https://wenmang.gitbub.io/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java集合概述</title>
    <link href="https://wenmang.gitbub.io/2019/11/04/Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/"/>
    <id>https://wenmang.gitbub.io/2019/11/04/Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/</id>
    <published>2019-11-04T14:33:40.000Z</published>
    <updated>2019-11-22T13:53:55.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>Java</code> 集合是一种非常常用的容器，就像数组那样，是为了储存各种各样的数据类型或者数据结构而设计的。其包含了各种已经封装好的数据结构，比如栈，队列，封装好的“数组”等等。</p><h3 id="collection-接口"><code>Collection</code> 接口</h3><p><code>Collection</code> 接口是最为基本的集合接口，也是相对比较高级的接口，其下又实现了一些子接口。</p><a id="more"></a><h4 id="set-子接口"><code>Set</code> 子接口</h4><p><code>Set</code> 子接口最显著的特征就是置入其中的数据是“无序”且不可重复的。这种无序指的是其中存储的数据可能并不是按照你输入的顺序存储的，而是以其独有的方式进行排列的。而 <code>Set</code> 中的一些数据结构，是直接利用了 <code>Map</code> 中的数据结构实现的。</p><h5 id="hashset-类"><code>HashSet</code> 类</h5><p><code>HashSet</code> 虽然是基于 <code>HashMap</code> 实现的，但其最底层所应用的便是我们数据结构中所学习的<strong>哈希表</strong>，有也就是说其底层实际上是利用哈希函数存储的，而这样的存储方式，也使得其查找，插入，删除等操作的时间复杂度可以降为 <span class="math inline">\(\Theta (1)\)</span> 。</p><p><strong>常见操作的示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    hashSet.add(<span class="number">1</span>);</span><br><span class="line">    hashSet.add(<span class="number">2</span>);</span><br><span class="line">    hashSet.add(<span class="number">3</span>);</span><br><span class="line">    hashSet.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(hashSet.size());</span><br><span class="line">    hashSet.clear();</span><br><span class="line">    System.out.println(hashSet.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：可以看出其不可重复</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h5 id="treeset-类"><code>TreeSet</code> 类</h5><p>同样，<code>TreeSet</code> 也是基于 <code>TreeMap</code> 实现的，但其最底层所使用的便是我们数据结构没学的<strong>红黑树</strong> ，由于其底层是利用红黑树实现的，所以其可以有序取出，存进去的元素可以以由大到小，或者由小到大的顺序逐个取出，由于是树形结构，所以其查取的时间复杂度是 <span class="math inline">\(O(logN)\)</span> 。</p><p><strong>常见操作的示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    treeSet.add(<span class="number">1</span>);</span><br><span class="line">    treeSet.add(<span class="number">2</span>);</span><br><span class="line">    treeSet.add(<span class="number">3</span>);</span><br><span class="line">    treeSet.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!treeSet.isEmpty()) &#123;</span><br><span class="line">        System.out.println(treeSet.size() + <span class="string">&quot; &quot;</span> + treeSet.first());</span><br><span class="line">        treeSet.remove(treeSet.first());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：可以看出其不可重复，并且按由小到大的顺序排列了</span></span><br><span class="line"><span class="comment">// 3 1</span></span><br><span class="line"><span class="comment">// 2 2</span></span><br><span class="line"><span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure><h5 id="enumset-类"><code>EnumSet</code> 类</h5><p>枚举集合，暂时还没用过，所以先列出来，待补……</p><h4 id="list-子接口"><code>List</code> 子接口</h4><p>与 <code>Set</code> 相反，<code>List</code> 子接口是“有序”可重复的。</p><h5 id="arraylist-类"><code>ArrayList</code> 类</h5><p>相当于一个可变数组（内部也是数组实现的），但是其是不同步的，也就是说其不是线程安全的！</p><p><strong>常见操作的示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    array.add(<span class="number">1</span>);</span><br><span class="line">    array.add(<span class="number">2</span>);</span><br><span class="line">    array.add(<span class="number">3</span>);</span><br><span class="line">    array.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(array.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:array) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：可以看出其是可重复，并且是按照输入顺序的</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h5 id="linkedlist-类"><code>LinkedList</code> 类</h5><p>相当于一个可变数组（内部也是链表实现的），但是其是不同步的，也就是说其不是线程安全的！</p><p><strong>常见操作的示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:list) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果同 ArrayList，不赘述</span></span><br></pre></td></tr></table></figure><h5 id="stack-类"><code>Stack</code> 类</h5><p>栈类，不多赘述！</p><p><strong>常见操作的示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    stack.push(<span class="number">1</span>);</span><br><span class="line">    stack.push(<span class="number">2</span>);</span><br><span class="line">    stack.push(<span class="number">3</span>);</span><br><span class="line">    stack.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(stack.size());</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：正常的栈！只是 Stack是 push 和 pop</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h5 id="vector-类"><code>Vector</code> 类</h5><p>可变数组，实现了 <code>List</code> 接口，线程安全的，但是没有 <code>ArrayList</code> 类快！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    vector.add(<span class="number">1</span>);</span><br><span class="line">    vector.add(<span class="number">2</span>);</span><br><span class="line">    vector.add(<span class="number">3</span>);</span><br><span class="line">    vector.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(vector.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:vector) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果同 ArrayList，不赘述</span></span><br></pre></td></tr></table></figure><h4 id="queue-子接口-和-deque-子接口"><code>Queue</code> 子接口 和 <code>Deque</code> 子接口</h4><p>队列接口和双端队列接口</p><h5 id="linkedlist-类-1"><code>LinkedList</code> 类</h5><p>如上述，不赘述！</p><h3 id="map-接口"><code>Map</code> 接口</h3><p>具有映射关系的 <code>key-value</code> 对的集合。</p><h5 id="hashmap-类"><code>HashMap</code> 类</h5><p>无序存放，<code>key</code> 不允许重复，基于哈希表 <code>Map</code> 接口的实现。</p><p><strong>常见操作的示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;文盲&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;文盲&quot;</span>, <span class="number">70</span>);</span><br><span class="line">map.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot;,Value = &quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：可见 key 不能重复，但是后面的会将前面的覆盖。同时key可以为null</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// key = null,Value = null</span></span><br><span class="line"><span class="comment">// key = 李四,Value = 100</span></span><br><span class="line"><span class="comment">// key = 张三,Value = 100</span></span><br><span class="line"><span class="comment">// key = 文盲,Value = 70</span></span><br></pre></td></tr></table></figure><h5 id="hashtable-类"><code>HashTable</code> 类</h5><p>无序存放，<code>key</code> 不允许重复。但是，与 <code>HashMap</code> 不同的是，不允许存在 <code>null</code> 的 <code>key</code> 和 <code>value</code>，并且是线程安全的！</p><p><strong>常见操作的示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Hashtable&lt;String, Integer&gt; map = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;文盲&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;李四&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;文盲&quot;</span>, <span class="number">70</span>);</span><br><span class="line">    map.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot;,Value = &quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：空指针异常，可见不可为 null！取消之后正常</span></span><br><span class="line"><span class="comment">// java.lang.NullPointerException</span></span><br></pre></td></tr></table></figure><h5 id="treemap-类"><code>TreeMap</code> 类</h5><p>有序<code>map</code></p><p><strong>常见操作的示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;String, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;John&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Ali&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;John&quot;</span>, <span class="number">70</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Lily&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot;,Value = &quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：key不能为null。同时可见是有序的，</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// key = Ali,Value = 100</span></span><br><span class="line"><span class="comment">// key = Bob,Value = 100</span></span><br><span class="line"><span class="comment">// key = John,Value = 70</span></span><br><span class="line"><span class="comment">// key = Lily,Value = null</span></span><br></pre></td></tr></table></figure><h3 id="iterator-接口"><code>Iterator</code> 接口</h3><p>迭代接口，可用来遍历所有集合类的数据！</p><p><strong>常见操作的示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    hashSet.add(<span class="number">1</span>);</span><br><span class="line">    hashSet.add(<span class="number">2</span>);</span><br><span class="line">    hashSet.add(<span class="number">3</span>);</span><br><span class="line">    hashSet.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; it = hashSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 集合是一种非常常用的容器，就像数组那样，是为了储存各种各样的数据类型或者数据结构而设计的。其包含了各种已经封装好的数据结构，比如栈，队列，封装好的“数组”等等。&lt;/p&gt;
&lt;h3 id=&quot;collection-接口&quot;&gt;&lt;code&gt;Collection&lt;/code&gt; 接口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt; 接口是最为基本的集合接口，也是相对比较高级的接口，其下又实现了一些子接口。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>堆的应用</title>
    <link href="https://wenmang.gitbub.io/2019/10/31/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://wenmang.gitbub.io/2019/10/31/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2019-10-31T05:21:29.000Z</published>
    <updated>2020-08-31T09:28:01.472Z</updated>
    
    <content type="html"><![CDATA[<p>书接上文，上篇博客中我说明了堆的定义，那么这一篇就谈谈堆的用法。由于堆快速的增删特性，所以往往有以下重要用途：</p><ul><li>实现优先队列，用于启发式搜索等内容。</li><li>一般用于贪心算法中辅助的数据结构。</li></ul><a id="more"></a><h3 id="堆的使用">堆的使用</h3><p>堆固然好用，但是也要清楚如何使用。</p><h4 id="快速手写堆">快速手写堆</h4><p>库固然好用，但是某些情况下你却可能不得不手写堆，那么这时候掌握快速手写堆的技巧便显得尤为重要。</p><p>数组是“万能的”，所以一般仅需要一个数组，便能够表示一个堆。众所周知，我们的堆是使用完全二叉树表示的，如下所示：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/31/wjWly7Oprn4e8xG.png" alt="最小堆.png" /><figcaption>最小堆.png</figcaption></figure><p>我们可以发现，可以将二叉树依次对应到数组中：</p><table><thead><tr class="header"><th>数组下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr class="odd"><td><strong>数组的值</strong></td><td>2</td><td>5</td><td>4</td><td>7</td><td>8</td></tr></tbody></table><p>可以发现，某个节点的根，实际上就是该节点下标的一半【这也是上个博客实现堆的时候使用的具体原理】。</p><p>知道了数组与完全二叉树的对应关系，那么便有可以自己实现最小堆，代码<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> heap[MAX_N], sz = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 堆的元素个数+1</span></span><br><span class="line"><span class="keyword">int</span> i = sz++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 调整堆 */</span></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 找出其父节点的编号 </span></span><br><span class="line"><span class="keyword">int</span> p = (i<span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  检查是否有大小颠倒</span></span><br><span class="line"><span class="keyword">if</span> (heap[p] &lt;= x)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父节点的数值放下来，将自己提上去</span></span><br><span class="line">heap[i] = heap[p];</span><br><span class="line">i = p;</span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获得堆顶元素</span></span><br><span class="line"><span class="keyword">int</span> ret = heap[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选取堆末尾的数，准备将其提到根</span></span><br><span class="line"><span class="keyword">int</span> x = heap[--sz];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根开始向下交换</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i*<span class="number">2</span> + <span class="number">1</span> &lt; sz) &#123;</span><br><span class="line"><span class="comment">// 比较儿子的值 </span></span><br><span class="line"><span class="keyword">int</span> a = i*<span class="number">2</span> + <span class="number">1</span>, b = i*<span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (b &lt; sz &amp;&amp; heap[b] &lt; heap[a])a = b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整完毕，则退出</span></span><br><span class="line"><span class="keyword">if</span> (heap[a] &gt; x)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将儿子的数值提上来</span></span><br><span class="line">heap[i] = heap[a];</span><br><span class="line">i = a; </span><br><span class="line">&#125;</span><br><span class="line">heap[i] = x;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，很多时候，我们都无需手写，直接调用库即可。</p><h4 id="c-中的堆"><code>C++</code> 中的堆</h4><p>在 <code>&lt;algorithm&gt;</code> 头文件之中，有着堆的模板，有 <code>make_heap()</code> 这样的函数来帮忙建一个堆。但是在实际问题中更为常用的反而是<code>优先队列</code>，优先队列位于 <code>&lt;queue&gt;</code> 头文件中，一段演示代码<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建优先队列</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; pque; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line">pque.push(<span class="number">3</span>);</span><br><span class="line">pque.push(<span class="number">5</span>);</span><br><span class="line">pque.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要队列不空就连续打印队首元素并出队</span></span><br><span class="line"><span class="keyword">while</span> (!pque.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pque.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">pque.pop();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>唯一需要注意的，就是优先队列每次弹出的都是最大的元素，也就是实质上是个最大堆</li></ul><h4 id="java-中的堆"><code>Java</code> 中的堆</h4><p><code>java</code> 中当然也有 <code>堆</code> 和 <code>优先队列</code>，其中优先队列演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">pq.add(<span class="number">5</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">System.out.println(pq.peek());</span><br><span class="line">pq.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>java</code> 中的优先队列经过验证是最小堆。。。</li></ul><h3 id="堆的应用">堆的应用</h3><p>有这样一道例题：<a href="http://poj.org/problem?id=2431"><code>poj 2431</code></a>，这道题便可以利用优先队列求解：</p><ul><li>首先将加油站到终点的距离转化为起点到加油站的距离</li><li>然后，可以抛去实际<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>来看待问题，我们可以采用贪心的思想，一直等到车完全没油之后再加油；而加油时候，选取前面已将路过的加油站中油量最大的油桶【此处可用优先队列节省时间】即可。</li></ul><p><strong>AC代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L, P, N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> _pair&amp; left, <span class="keyword">const</span> _pair&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left.a &lt; right.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    _pair *t = <span class="keyword">new</span> _pair[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;t[i].a, &amp;t[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;L, &amp;P);</span><br><span class="line">    <span class="comment">// 处理为距离起点的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        t[i].a = L - t[i].a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(t, t+N, cmp);</span><br><span class="line"></span><br><span class="line">    t[N].a = L;</span><br><span class="line">    t[N].b = <span class="number">0</span>;</span><br><span class="line">    N++;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, pos = <span class="number">0</span>, tank = P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> d = t[i].a - pos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tank - d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (que.empty()) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tank += que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tank -= d;</span><br><span class="line">        pos = t[i].a;</span><br><span class="line">        que.push(t[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明：</strong>注意排序，否则就会 <code>WA</code></li></ul><h3 id="引用">引用</h3><section class="footnotes"><hr /><ol><li id="fn1"><p>此处的代码来自《挑战程序设计竞赛》（第二版）<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>此处的代码来自《挑战程序设计竞赛》（第二版）<a href="#fnref2" class="footnote-back">↩</a></p></li><li id="fn3"><p>抛去实际才能以更优秀的算法来求解问题，不然只能永久进行模拟<a href="#fnref3" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;书接上文，上篇博客中我说明了堆的定义，那么这一篇就谈谈堆的用法。由于堆快速的增删特性，所以往往有以下重要用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现优先队列，用于启发式搜索等内容。&lt;/li&gt;
&lt;li&gt;一般用于贪心算法中辅助的数据结构。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wenmang.gitbub.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://wenmang.gitbub.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="刷题" scheme="https://wenmang.gitbub.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://wenmang.gitbub.io/2019/10/30/%E5%A0%86/"/>
    <id>https://wenmang.gitbub.io/2019/10/30/%E5%A0%86/</id>
    <published>2019-10-30T09:18:21.000Z</published>
    <updated>2020-08-31T09:27:21.556Z</updated>
    
    <content type="html"><![CDATA[<p><strong>引例：</strong>在搜索算法实现中，会遇到这样一个问题——我们并不希望按照入队的先后顺序出队，而是希望每次出队的都是队列中最大或最小的元素。</p><p>而要实现这样的方式，我们可以假设一种队列，取出元素的顺序以大小为准，我们往往将这样的队列称之为<strong>优先队列</strong>。</p><a id="more"></a><p><strong>优先队列（Priority Queue）：</strong>特殊的“队列”，依照元素的优先权（关键字）大小取出数据，而不是元素进入队列的先后顺序。</p><h3 id="选择合适的数据结构">选择合适的数据结构</h3><p>既然已经有了这样一个设想，那我们应该采用何种方式来实现呢？</p><h4 id="使用数组或者链表">使用数组或者链表</h4><p>我们首先会想到以前学过的基本内容，以数组，链表等方式来储存，为了方便判断各种储存方法的优劣，我们将几种方法的时间复杂度进行比较。</p><ul><li><p><strong>普通数组</strong></p><p><strong>插入：</strong>我们只需要将普通数组的尾部即可    —— 时间复杂度 <code>O(1)</code></p><p><strong>删除：</strong>需要从数组中查找最大或最小的元素，进行一次遍历即可    —— 时间复杂度为 <code>O(n)</code></p></li><li><p><strong>链表</strong></p><p><strong>插入：</strong>元素总是插在链表的头部(头插法)    —— 时间复杂度 <code>O(1)</code></p><p><strong>删除：</strong>同样需要遍历查找查找最大或最小元素    —— 时间复杂度 <code>O(1)</code></p></li><li><p><strong>有序数组：</strong>即在插入时就按照一定顺序插入</p><p><strong>插入：</strong>找到合适位置 —— 时间复杂度 <code>O(n)</code> 或者 <code>O(log n)</code> 【二分查找】         移动元素并插入    —— 时间复杂度 <code>O(n)</code></p><p><strong>删除：</strong>删去最后一个元素    —— 时间复杂度 <code>O(n)</code></p></li><li><p><strong>有序链表：</strong>同有序数组插入时按照一定顺序插入</p><p><strong>插入：</strong>找到合适的位置    —— 时间复杂度为 <code>O(n)</code>   插入元素    —— 时间复杂度 <code>O(1)</code></p><p><strong>删除：</strong>删除首元素或者最后的元素    —— 时间复杂度为 <code>O(1)</code></p></li></ul><p>我们发现，以上四种实现方式的时间复杂度基本都是 <code>O(n)</code> ，那么可不可以找得到一种数据结构，来降低其时间复杂度呢？</p><p><strong>那么就只有树了！</strong>我们可以用二叉树来实现，因为平衡二叉树的删除与插入时间复杂度都是与树高有关，时间复杂度是 <code>logN</code> 的。</p><h4 id="二叉搜索树">二叉搜索树</h4><p>二叉搜索树可以很好地进行插入与删除操作，删除时只需要将最左或者最右元素删除。<strong>但如果删除元素变多之后，可能会出现树”一边倒“ 的情况，这时会使时间复杂度变大，不再为 <code>O(logN)</code></strong>，所以使用二叉搜索树也不很合适。</p><h4 id="完全二叉树">完全二叉树</h4><p>将最大值或者最小值置于根结点处，用完全二叉树来存储，在删除之时就可以避免树出现“一边倒”的情况 。</p><hr /><p>而这种数据结构，便被称作堆。堆在中文维基百科中的定义如下：</p><blockquote><p><strong>堆</strong>（英语：Heap）是<a href="https://zh.wikipedia.org/wiki/计算机科学">计算机科学</a>中的一种特别的树状<a href="https://zh.wikipedia.org/wiki/数据结构">数据结构</a>。若是满足以下特性，即可称为堆：“给定堆中任意<a href="https://zh.wikipedia.org/wiki/節點">节点</a>P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值”。若母节点的值恒<strong>小于等于</strong>子节点的值，此堆称为<strong>最小堆</strong>（min heap）；反之，若母节点的值恒<strong>大于等于</strong>子节点的值，此堆称为<strong>最大堆</strong>（max heap）。</p></blockquote><h3 id="实现堆">实现堆</h3><p>堆的两个特性 ：</p><p><strong>结构性：</strong>用数组表示的完全二叉树； </p><p><strong>有序性：</strong>任一结点的关键字是其子树所有结点的最大值(或最小值) </p><ul><li>“最大堆(<code>MaxHeap</code>)”,也称“大顶堆”：最大值 </li><li>“最小堆(<code>MinHeap</code>)”,也称“小顶堆” ：最小值</li></ul><h4 id="堆的抽象数据类型描述">堆的抽象数据类型描述</h4><p><strong>类型名称：</strong>最大堆（<code>MaxHeap</code>） </p><p><strong>数据对象集：</strong>完全二叉树，每个结点的元素值不小于其子结点的元素值</p><p><strong>操作集：</strong>最大堆H 属于 <code>MaxHeap</code> ，元素item 属于 <code>ElementType</code></p><p><strong>主要操作有： </strong></p><ul><li><p><code>MaxHeap Create( int MaxSize )：</code> 创建一个空的最大堆。 </p></li><li><p><code>Boolean IsFull( MaxHeap H )：</code>判断最大堆<code>H</code>是否已满。</p></li><li><p><code>Insert( MaxHeap H, ElementType item )：</code>将元素 <code>item</code> 插入最大堆 <code>H</code>。 </p></li><li><p><code>Boolean IsEmpty( MaxHeap H )：</code>判断最大堆<code>H</code>是否为空。</p></li><li><p><code>ElementType DeleteMax( MaxHeap H )：</code>返回<code>H</code>中最大元素(高优先级)。</p></li></ul><h4 id="堆的构建">堆的构建</h4><p>首先应该了解怎样创建一个空的最大堆，但在这之前，我们首先应该设计出合适的结构体来表示堆 ：</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MaxHeap</span> ;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">ElementType  *Elements ;<span class="comment">// 存储堆元素的数组</span></span><br><span class="line"><span class="keyword">int</span>  Size ;<span class="comment">// 堆当前的元素个数</span></span><br><span class="line"><span class="keyword">int</span>  Capacity ;<span class="comment">// 堆的最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="堆中元素的插入">堆中元素的插入</h4><p><strong>插入分两步：</strong></p><ol type="1"><li>将元素插入到数组中元素之后，也就是末位，使之符合完全二叉树的结构</li><li>调整元素位置，使之成为堆</li></ol><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span> <span class="params">( MaxHeap H, ElementType item )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i ;</span><br><span class="line"><span class="keyword">if</span> ( isFull(H) )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最大堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// i 指向插入后 堆中最后一个元素的位置</span></span><br><span class="line">i = ++H-&gt;Size ;   </span><br><span class="line"><span class="keyword">for</span>  ( ; H-&gt;Elements[i] &gt; H-&gt;Elements[i/<span class="number">2</span>] ; i/=<span class="number">2</span> )</span><br><span class="line">        <span class="comment">// 向下过滤节点</span></span><br><span class="line">H-&gt;Elements[i] = H-&gt;Elements[i/<span class="number">2</span>] ;     </span><br><span class="line">H-&gt;Elements[i] = item ; <span class="comment">// 将item插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理解：</strong></p><ul><li>代码的主要部分为 <code>for</code> 循环及之后，<code>for</code> 循环在于将新插入至末尾的结点与其父节点进行比较，如新插入节点更大，则将其父节点与其交换位置，即可变为堆。</li></ul><p><strong>注意：</strong></p><ul><li>交换位置之时，在循环中直接将父节点覆盖子节点，而最后再将新需要插入的结点直接插入到相应位置之中，可以提高效率。</li><li>循环之时，如果在堆中不设哨兵，在循环之时还应进行判断，使其循环替换元素之时不能出堆</li></ul><h4 id="最大堆的删除">最大堆的删除</h4><p>最大堆的删除操作也就是删除掉堆中的最大元素（即树根），并将之返回出去</p><p>删除之后堆中会少一个元素，因此我们的思路是：</p><ul><li>在删除操作进行之时首先将树根元素复制并返回，之后直接将数组最后一个元素将树根元素直接覆盖。</li><li>然后就是将元素顺序再重新调整为一个堆。</li></ul><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType  <span class="title">DeleteMax</span><span class="params">( MaxHeap H )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  parent, child ;</span><br><span class="line">    ElementType  MaxItem, temp ;</span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty(H) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已空&quot;</span>) ；</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>] ;    <span class="comment">// 取出根节点的最大值</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;Size--] ;     <span class="comment">// 将最后一个元素赋给temp</span></span><br><span class="line">    <span class="keyword">for</span> ( parent = <span class="number">1</span> ; parent*<span class="number">2</span> &lt;= H-&gt;Size ; parent = child )&#123;</span><br><span class="line">        child = parent * <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span> ( (child != H-&gt;Size) &amp;&amp;</span><br><span class="line">            (H-&gt;Elements[child] &lt; H-&gt;Elements[child+<span class="number">1</span>]) )</span><br><span class="line">            child++ ;   <span class="comment">// 使 child 指向左右结点中较大者</span></span><br><span class="line">        <span class="keyword">if</span> ( temp &gt;= H-&gt;Elements[child] )   <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 将 temp 元素移动到下一层</span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child] ;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp ;</span><br><span class="line">    <span class="keyword">return</span> MaxItem ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>代码之中重点就在于重新调整元素，也就是 <code>for</code> 循环中内容——从根节点开始，依次与最大子结点比较，如果小于就与其交换位置，直至调整好为止。</p><p><strong>注：</strong><code>for</code> 循环的前一个if是用来调整 <code>child</code> 的，使 <code>child</code> 指向子结点中最大结点，之后就是调整结点元素的过程</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;引例：&lt;/strong&gt;在搜索算法实现中，会遇到这样一个问题——我们并不希望按照入队的先后顺序出队，而是希望每次出队的都是队列中最大或最小的元素。&lt;/p&gt;
&lt;p&gt;而要实现这样的方式，我们可以假设一种队列，取出元素的顺序以大小为准，我们往往将这样的队列称之为&lt;strong&gt;优先队列&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wenmang.gitbub.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="博客" scheme="https://wenmang.gitbub.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="数据结构" scheme="https://wenmang.gitbub.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>博客重新配置</title>
    <link href="https://wenmang.gitbub.io/2019/10/29/%E5%8D%9A%E5%AE%A2%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE/"/>
    <id>https://wenmang.gitbub.io/2019/10/29/%E5%8D%9A%E5%AE%A2%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE/</id>
    <published>2019-10-29T08:16:27.000Z</published>
    <updated>2019-10-30T13:46:17.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前用的 <code>yilia</code> 主题的作者跑路了，好久都没更新了，这导致我以前好不容易搞好的博客开始出现了一些有的没的小问题：标签搜索时有时无，赞赏二维码被压缩至一侧等等。但由于种种原因，也一直懒得再搞一个新主题，昨晚突然心血来潮，找了找新一点的主题，最终相中了 <code>icarus</code>。</p><p><a href="https://github.com/ppoffice/hexo-theme-icarus"><code>icarus</code></a> 是那种很干净的主题，虽然简洁度比着 <code>yilia</code> 差了一些，但也多了不少内容，加了许些动画。</p><a id="more"></a><h3 id="主题安装">主题安装</h3><p>根据 <code>gitbub</code> 上的说明，切换到主目录下执行下面命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-icarus.git themes&#x2F;icarus</span><br></pre></td></tr></table></figure><p>完成后，更改了 <code>_config.yml</code> 文件，将主题换了过来，并 <code>hexo g</code>。正在我拿起手机准备等待其配置的时候，不幸的故事发生了，是的，报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.SyncWriteStream is deprecated.</span><br></pre></td></tr></table></figure><p>就这么一句报错，我搜了一个晚上，经过数次尝试后未果。</p><p>第二天起了个大早——十点多就起了，我改变了我的思路，因为我发现那个报错是18年一个低版本的bug，那么我想给他更新了会不会解决问题？</p><p>于是，我将年久失修的 <code>npm</code> <code>node.js</code> ，<code>hexo</code> 都给更新了一遍，并且安装了一些报错中缺少的依赖，问题终于解决了。</p><h3 id="主题配置">主题配置</h3><p>任何主题都需要进行一些个性化的配置，小至修改 <code>_config.yml</code> 配置文件，大到修改一些网站配置文件。在修改的过程中，我参考了几个博客，将会在参考链接中列出：</p><h4 id="普通配置">普通配置</h4><p>首先，配置 <code>_config.yml</code> 文件<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">%</span> <span class="string">codeblock</span> <span class="string">_config.yml</span> <span class="string">%</span>&#125;</span><br><span class="line"><span class="comment"># Version of the Icarus theme that is currently used</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">2.6</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 我的网站图标</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/images/favicon.svg</span></span><br><span class="line"><span class="comment"># Additional HTML meta tags in an array.</span></span><br><span class="line"><span class="attr">meta:</span> </span><br><span class="line"><span class="comment"># Path or URL to RSS atom.xml</span></span><br><span class="line"><span class="attr">rss:</span> </span><br><span class="line"><span class="comment"># 导航栏左侧的网站logo</span></span><br><span class="line"><span class="attr">logo:</span> <span class="string">/images/logo.jpg</span></span><br><span class="line"><span class="comment"># Open Graph metadata</span></span><br><span class="line"><span class="comment"># https://hexo.io/docs/helpers.html#open-graph</span></span><br><span class="line"><span class="attr">open_graph:</span></span><br><span class="line">    <span class="comment"># Facebook App ID</span></span><br><span class="line">    <span class="attr">fb_app_id:</span> </span><br><span class="line">    <span class="comment"># Facebook Admin ID</span></span><br><span class="line">    <span class="attr">fb_admins:</span> </span><br><span class="line">    <span class="comment"># Twitter ID</span></span><br><span class="line">    <span class="attr">twitter_id:</span> </span><br><span class="line">    <span class="comment"># Twitter site</span></span><br><span class="line">    <span class="attr">twitter_site:</span> </span><br><span class="line">    <span class="comment"># Google+ profile link</span></span><br><span class="line">    <span class="attr">google_plus:</span> </span><br><span class="line"><span class="comment"># 导航栏</span></span><br><span class="line"><span class="attr">navbar:</span></span><br><span class="line">    <span class="comment"># 菜单</span></span><br><span class="line">    <span class="attr">menu:</span></span><br><span class="line">        <span class="string">主页:</span> <span class="string">/</span></span><br><span class="line">        <span class="string">归档:</span> <span class="string">/archives</span></span><br><span class="line">        <span class="string">分类:</span> <span class="string">/categories</span></span><br><span class="line">        <span class="string">标签:</span> <span class="string">/tags</span></span><br><span class="line">        <span class="string">关于:</span> <span class="string">/about</span></span><br><span class="line">    <span class="comment"># 导航栏右侧的图标链接</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">        <span class="attr">My GitHub:</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">&#x27;https://github.com/wenmang&#x27;</span></span><br><span class="line"><span class="comment"># Footer section link settings</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">    <span class="comment"># 页脚图标链接</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">        <span class="attr">Creative Commons:</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-creative-commons</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">&#x27;https://creativecommons.org/&#x27;</span></span><br><span class="line">        <span class="attr">Attribution 4.0 International:</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-creative-commons-by</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">&#x27;https://creativecommons.org/licenses/by/4.0/&#x27;</span></span><br><span class="line">        <span class="attr">Download on GitHub:</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">&#x27;https://github.com/wenmang&#x27;</span></span><br><span class="line"><span class="comment"># 文章显示设置</span></span><br><span class="line"><span class="attr">article:</span></span><br><span class="line">    <span class="comment"># Code highlight settings</span></span><br><span class="line">    <span class="attr">highlight:</span></span><br><span class="line">        <span class="comment"># https://github.com/highlightjs/highlight.js/tree/master/src/styles</span></span><br><span class="line">        <span class="comment"># 代码主题： atom-one-light亮色，atom-one-dark暗色</span></span><br><span class="line">        <span class="attr">theme:</span> <span class="string">atom-one-dark</span></span><br><span class="line">        <span class="comment"># 显示复制按钮</span></span><br><span class="line">        <span class="attr">clipboard:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># Default folding status of the code blocks. Can be &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot;</span></span><br><span class="line">        <span class="attr">fold:</span> <span class="string">unfolded</span></span><br><span class="line">    <span class="comment"># 是否显示文章主图</span></span><br><span class="line">    <span class="attr">thumbnail:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否显示估算阅读时间</span></span><br><span class="line">    <span class="attr">readtime:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 搜索插件设置</span></span><br><span class="line"><span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">    <span class="comment"># Name of the search plugin</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">insight</span></span><br><span class="line"><span class="comment"># 评论插件设置</span></span><br><span class="line"><span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">    <span class="comment"># Name of the comment plugin</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">valine</span></span><br><span class="line">    <span class="attr">app_id:</span> <span class="string">xxx</span>        <span class="comment"># (required) LeanCloud application id</span></span><br><span class="line">    <span class="attr">app_key:</span> <span class="string">xxx</span>       <span class="comment"># (required) LeanCloud application key</span></span><br><span class="line">    <span class="attr">notify:</span> <span class="literal">true</span>           <span class="comment"># (optional) receive email notification</span></span><br><span class="line">    <span class="attr">verify:</span> <span class="literal">false</span>           <span class="comment"># (optional) show verification code</span></span><br><span class="line">    <span class="attr">placeholder:</span> <span class="string">说点什么吧</span>   <span class="comment"># (optional) comment box placeholder text</span></span><br><span class="line">    <span class="attr">avatar:</span> <span class="string">retro</span>   <span class="comment"># 头像风格</span></span><br><span class="line">    <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">    <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 打赏功能</span></span><br><span class="line"><span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Donation/</span></span><br><span class="line"><span class="attr">donate:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">alipay</span></span><br><span class="line">        <span class="comment"># Qrcode image URL</span></span><br><span class="line">        <span class="attr">qrcode:</span> <span class="string">&#x27;/images/zhifubao.jpg&#x27;</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">wechat</span></span><br><span class="line">        <span class="comment"># Qrcode image URL</span></span><br><span class="line">        <span class="attr">qrcode:</span> <span class="string">&#x27;/images/weixin.png&#x27;</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="comment"># type: paypal</span></span><br><span class="line">        <span class="comment"># Paypal business ID or email address</span></span><br><span class="line">        <span class="comment"># business: &#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># Currency code</span></span><br><span class="line">        <span class="comment"># currency_code: USD</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="comment"># type: patreon</span></span><br><span class="line">        <span class="comment"># URL to the Patreon page</span></span><br><span class="line">        <span class="comment"># url: &#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 分享插件设置</span></span><br><span class="line"><span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share</span></span><br><span class="line"><span class="attr">share:</span></span><br><span class="line">    <span class="comment"># 插件类型</span></span><br><span class="line">    <span class="attr">type:</span> </span><br><span class="line"><span class="comment"># Sidebar settings.</span></span><br><span class="line"><span class="comment"># Please be noted that a sidebar is only visible when it has at least one widget</span></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">    <span class="comment"># 左侧边栏设置</span></span><br><span class="line">    <span class="attr">left:</span></span><br><span class="line">        <span class="comment"># 是否跟随页面滚动</span></span><br><span class="line">        <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line">        <span class="attr">sticky:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 右侧边栏设置</span></span><br><span class="line">    <span class="attr">right:</span></span><br><span class="line">        <span class="comment"># Whether the right sidebar is sticky when page scrolls</span></span><br><span class="line">        <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line">        <span class="attr">sticky:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Sidebar widget settings</span></span><br><span class="line"><span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 个人信息</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">profile</span></span><br><span class="line">        <span class="comment"># 部件位置</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">        <span class="comment"># 作者名</span></span><br><span class="line">        <span class="attr">author:</span> <span class="string">文盲</span></span><br><span class="line">        <span class="comment"># 作者身份描述</span></span><br><span class="line">        <span class="attr">author_title:</span> <span class="string">饱暖思淫欲</span></span><br><span class="line">        <span class="comment"># 当前居住地</span></span><br><span class="line">        <span class="attr">location:</span> <span class="string">西安</span></span><br><span class="line">        <span class="comment"># 头像</span></span><br><span class="line">        <span class="attr">avatar:</span> <span class="string">/images/logo.jpg</span></span><br><span class="line">        <span class="comment"># Email address for the Gravatar to be shown in the profile widget</span></span><br><span class="line">        <span class="attr">gravatar:</span> </span><br><span class="line">        <span class="comment"># 头像显示为圆还是方</span></span><br><span class="line">        <span class="attr">avatar_rounded:</span> <span class="literal">false</span> <span class="comment"># 方</span></span><br><span class="line">        <span class="comment"># 关注按钮的链接</span></span><br><span class="line">        <span class="attr">follow_link:</span> <span class="string">&#x27;https://github.com/wenmang&#x27;</span></span><br><span class="line">        <span class="comment"># Links to be shown on the bottom of the profile widget</span></span><br><span class="line">        <span class="attr">social_links:</span></span><br><span class="line">            <span class="attr">Github:</span></span><br><span class="line">                <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">&#x27;https://github.com/wenmang&#x27;</span></span><br><span class="line">            <span class="attr">envelope:</span> <span class="string">mailto:xdwenmang@gmail.com</span></span><br><span class="line">            <span class="comment"># Facebook:</span></span><br><span class="line">                <span class="comment"># icon: fab fa-facebook</span></span><br><span class="line">                <span class="comment"># url: &#x27;https://facebook.com&#x27;</span></span><br><span class="line">            <span class="attr">bilibili:</span></span><br><span class="line">                <span class="attr">icon:</span> <span class="string">/images/gmail.svg</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">&#x27;https://space.bilibili.com/192395573&#x27;</span></span><br><span class="line">            <span class="comment"># Dribbble:</span></span><br><span class="line">                <span class="comment"># icon: fab fa-dribbble</span></span><br><span class="line">                <span class="comment"># url: &#x27;https://dribbble.com&#x27;</span></span><br><span class="line">            <span class="attr">RSS:</span></span><br><span class="line">                <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-rss</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">/atom.xml</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 目录</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">toc</span></span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 外部链接</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">links</span></span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">        <span class="comment"># Links to be shown in the links widget</span></span><br><span class="line">        <span class="attr">links:</span></span><br><span class="line">            <span class="attr">Google:</span> <span class="string">&#x27;https://google.com&#x27;</span></span><br><span class="line">            <span class="attr">Baidu:</span> <span class="string">&#x27;https://baidu.com&#x27;</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 分类</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">category</span></span><br><span class="line">        <span class="comment"># 位置指定，左/右</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 标签云</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">tagcloud</span></span><br><span class="line">        <span class="comment"># 位置</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 近期文章</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">recent_posts</span></span><br><span class="line">        <span class="comment"># 位置</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 归档</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">archive</span></span><br><span class="line">        <span class="comment"># 位置</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 标签</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">tag</span></span><br><span class="line">        <span class="comment"># 位置</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line"><span class="comment"># Other plugin settings</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">    <span class="comment"># 启用页面动画</span></span><br><span class="line">    <span class="attr">animejs:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Enable the lightGallery and Justified Gallery plugins</span></span><br><span class="line">    <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/gallery-plugin/</span></span><br><span class="line">    <span class="attr">gallery:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Enable the Outdated Browser plugin</span></span><br><span class="line">    <span class="comment"># http://outdatedbrowser.com/</span></span><br><span class="line">    <span class="attr">outdated-browser:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Enable the MathJax plugin</span></span><br><span class="line">    <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/mathjax-plugin/</span></span><br><span class="line">    <span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show the back to top button on mobile devices</span></span><br><span class="line">    <span class="attr">back-to-top:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Google Analytics plugin settings</span></span><br><span class="line">    <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Google-Analytics</span></span><br><span class="line">    <span class="attr">google-analytics:</span></span><br><span class="line">        <span class="comment"># Google Analytics tracking id</span></span><br><span class="line">        <span class="attr">tracking_id:</span> </span><br><span class="line">    <span class="comment"># Baidu Analytics plugin settings</span></span><br><span class="line">    <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Baidu-Analytics</span></span><br><span class="line">    <span class="attr">baidu-analytics:</span></span><br><span class="line">        <span class="comment"># Baidu Analytics tracking id</span></span><br><span class="line">        <span class="attr">tracking_id:</span> </span><br><span class="line">    <span class="comment"># Hotjar user feedback plugin</span></span><br><span class="line">    <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Hotjar</span></span><br><span class="line">    <span class="comment"># hotjar:</span></span><br><span class="line">        <span class="comment"># Hotjar site id</span></span><br><span class="line">        <span class="comment"># site_id: </span></span><br><span class="line">    <span class="comment"># Show a loading progress bar at top of the page</span></span><br><span class="line">    <span class="attr">progressbar:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># BuSuanZi site/page view counter</span></span><br><span class="line">    <span class="comment"># https://busuanzi.ibruce.info</span></span><br><span class="line">    <span class="attr">busuanzi:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 51LA统计</span></span><br><span class="line">    <span class="attr">tj51la:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># CDN provider settings</span></span><br><span class="line"><span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/</span></span><br><span class="line"><span class="attr">providers:</span></span><br><span class="line">    <span class="comment"># Name or URL of the JavaScript and/or stylesheet CDN provider</span></span><br><span class="line">    <span class="attr">cdn:</span> <span class="string">jsdelivr</span></span><br><span class="line">    <span class="comment"># Name or URL of the webfont CDN provider</span></span><br><span class="line">    <span class="attr">fontcdn:</span> <span class="string">google</span></span><br><span class="line">    <span class="comment"># Name or URL of the webfont Icon CDN provider</span></span><br><span class="line">    <span class="attr">iconcdn:</span> <span class="string">fontawesome</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">codeblockend</span> <span class="string">_config.yml</span> <span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure><p>此处有一个小坑，就是 上述所有配置图片，需要放在 <code>blog\themes\icarus\source\images</code> 目录下，之后才能找得到。</p><h4 id="进阶配置">进阶配置</h4><p>进阶配置主要是对布局的更改，以及添加目录粘性布局等等<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。</p><p>由于是几乎完全照抄的，所以，直接在参考链接看人家的博客即可！</p><h3 id="添加插件">添加插件</h3><p>此主题的优点就是集成了比较多的各类插件，只需要修改配置文件即可成功添加：</p><h4 id="添加评论插件">添加评论插件</h4><p>我比较喜欢那种谁都能评论的系统，所以我选择了 <code>valine</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comment:</span></span><br><span class="line">    <span class="comment"># Name of the comment plugin</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">valine</span></span><br><span class="line">    <span class="attr">app_id:</span> <span class="string">xxx【填自己的】</span>       <span class="comment"># (required) LeanCloud application id</span></span><br><span class="line">    <span class="attr">app_key:</span> <span class="string">xxx【填自己的】</span>      <span class="comment"># (required) LeanCloud application key</span></span><br><span class="line">    <span class="attr">notify:</span> <span class="literal">true</span>           <span class="comment"># (optional) receive email notification</span></span><br><span class="line">    <span class="attr">verify:</span> <span class="literal">false</span>           <span class="comment"># (optional) show verification code</span></span><br><span class="line">    <span class="attr">placeholder:</span> <span class="string">say【自己改】</span> <span class="comment"># (optional) comment box placeholder text</span></span><br><span class="line">    <span class="attr">avatar:</span> <span class="string">retro【可自己查表】</span><span class="comment"># 头像风格</span></span><br><span class="line">    <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">    <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure><h4 id="添加分享插件">添加分享插件</h4><p>直接填写插件类型即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">share:</span><br><span class="line">    # 插件类型</span><br><span class="line">    type: sharejs</span><br></pre></td></tr></table></figure><h3 id="使搜索引擎可爬取">使搜索引擎可爬取</h3><p>搜索引擎可爬取意味着可以直接在搜索引擎上搜到自己的博客，而这也我很久之前也尝试过，但是并未成功，现在可以直接在自己网站中上传一个 <code>html</code> 文件，即可完成工作，但是有几个坑需要注意<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>：</p><ol type="1"><li>下载下来的文件需放置在 <code>blog\source</code> 文件夹中，以达到将其上传到网站根目录的目的。</li><li>存放之后，不可直接 <code>hexo g -d</code>，而是需要 <code>hexo g</code> 之后，将 <code>blog\public</code> 文件夹中生成的对应文件改得和下载下来的文件一模一样。</li><li>为省的每次提交都修改一次，可将 <code>blog\public</code> 中的对应文件改为 <code>只读</code></li></ol><h3 id="参考链接">参考链接</h3><section class="footnotes"><hr /><ol><li id="fn1"><p>此部分参考了<a href="https://www.ccyh.xyz/2019/04/29/Hexo+icarus主题配置">YH · Lin</a>的博客<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>此部分参考（划掉）照抄了 <a href="https://www.alphalxy.com/2019/03/customize-icarus/">Xinyu Liu</a>的博客<a href="#fnref2" class="footnote-back">↩</a></p></li><li id="fn3"><p>此部分来自<a href="%5Bhttp://pythonqi.com/2018/05/28/%E8%B0%B7%E6%AD%8C-%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF%E6%97%B6HTML%E9%AA%8C%E8%AF%81%E6%96%87%E4%BB%B6%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%5D(http://pythonqi.com/2018/05/28/谷歌-百度推广时HTML验证文件验证失败的解决方案/)">呆马屋</a>的博客<a href="#fnref3" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前用的 &lt;code&gt;yilia&lt;/code&gt; 主题的作者跑路了，好久都没更新了，这导致我以前好不容易搞好的博客开始出现了一些有的没的小问题：标签搜索时有时无，赞赏二维码被压缩至一侧等等。但由于种种原因，也一直懒得再搞一个新主题，昨晚突然心血来潮，找了找新一点的主题，最终相中了 &lt;code&gt;icarus&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ppoffice/hexo-theme-icarus&quot;&gt;&lt;code&gt;icarus&lt;/code&gt;&lt;/a&gt; 是那种很干净的主题，虽然简洁度比着 &lt;code&gt;yilia&lt;/code&gt; 差了一些，但也多了不少内容，加了许些动画。&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://wenmang.gitbub.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="教程" scheme="https://wenmang.gitbub.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分治</title>
    <link href="https://wenmang.gitbub.io/2019/10/09/%E5%88%86%E6%B2%BB/"/>
    <id>https://wenmang.gitbub.io/2019/10/09/%E5%88%86%E6%B2%BB/</id>
    <published>2019-10-09T10:35:45.000Z</published>
    <updated>2019-10-10T13:19:45.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>何为分治？简单来说，就是将大的问题分解成小问题进行求解，然后对每个小问题的解进行处理【一般是合并】为大问题的解，下面是分治较为官方的说明：</p><p><strong>分治：</strong> 把一个任务，分成形式和原任务相同，但规模更小的 几个部分任务（通常是两个部分），分别完成，或只需要选一部完成。然后再处理完成后的这一个或几个 部分的结果，实现整个任务的完成。</p><a id="more"></a><h3 id="斐波那契数列">斐波那契数列</h3><p>我想了很多，最后发现还是从这个例子开始说起更加便于理解。</p><p>斐波那契数列的定义很简单，其最早的历史来自于那个生兔子的问题。斐波那契数列的解法众多，详细描述可见<a href="https://zh.wikipedia.org/wiki/斐波那契数列">维基百科</a>，而如果使用数学公式来描述，那么就是这个样子的： <span class="math display">\[\begin{equation}  \left\{      \begin{array}{**lr**}          F_0 = 0 &amp;  \\          F_1 = 1 &amp;  \\          F_n = F_{n-1} + F_{n-2} &amp; \\        \end{array}  \right.  \end{equation}  \]</span> 他这种递归的定义方式，其实以初等数学使用暴力求解的思路来说，刚好是符合我们的分治思想的。因为你若将求解 <span class="math inline">\(F_4\)</span> 看作一个大问题，就必须将其分解为两个小一点的子问题，即求解 <span class="math inline">\(F_3\)</span> 和 <span class="math inline">\(F_2\)</span> ，然后再计算二者之和。</p><p>那么根据这个递归式，我想只要有点语言基础，都能很快写出一段递归的代码进行求解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>Fibonacci</code> 真正实现的时候不能这么写。</p><h3 id="分治范式">分治范式</h3><p>大致对分治这种思想有了一个整体认识之后，我们便可以总结出一个求解分治问题的范式：</p><p><strong>何时使用分治思想：</strong>问题规模太大或者其他原因导致难以直接求解，那么这时候便可以考虑将问题划分为子问题，通过求解子问题来实现原问题最终的求解。</p><p><strong>范式的一般步骤：</strong></p><ul><li><strong>划分：</strong>简单来说，此步骤就是将大问题分解为小问题【注：每个小问题的求解必须一致，不然分治就失去了其原本的意义】。</li><li><strong>治理：</strong><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>也就是对每一个子问题进行求解。</li><li><strong>组合：</strong>将所有子问题的结果进行合并，得到原问题的解。</li></ul><h4 id="分治的分析">分治的分析</h4><p>分治的性质决定了其与递归联系紧密，所以如果一个问题可以用分治的思想来解决，那么其必然可以转化为一个递归表达式，就如同最开始直接以递归定义的斐波那契数列的表达式一般。而此类问题时间复杂度的详细分析，也往往依靠求解这样的递归式来得到。</p><h3 id="归并排序">归并排序</h3><p>许多算法都是利用分治思想提出来的，而归并排序无疑是最具代表性的一个，我们可以根据分治范式来一步步分析求解，最终明确这个算法的原理。</p><h4 id="划分">划分</h4><ul><li>两个数之间如何排序【注：此后所说的排序均代表顺序排序】？很显然两两之间比较，小的放左边，大的放右边。</li><li>那三个数如何排序？选两个排好之后，再将第三个数与已经排好的两数比较，进而确定第三个数的位置。</li><li>四个？此时可以两两排好，然后再合并两个已排序的数组即可。</li><li>六十四个？可以分为俩三十二个的，每个三十二个的又可分为俩十六个的……</li></ul><p>如此，我们可以将大问题以对半划分的方式【注：奇数对半，一半比一半多1即可】层层划分，<strong>直至不可划分为止，也就是仅剩一个数的时候。</strong>而划分，也往往就是递归的过程。</p><h4 id="治理">治理</h4><p>治理，即解决划分后的子问题，划分后的子问题是什么呢？答案就是，一个数的排序。一个数显然无需排序，那么此步骤便无需进行处理。</p><h4 id="组合">组合</h4><p>将子问题的结果组合起来，在此问题中便是，<strong>将已排序的两个数组合并为一个已排序的数组。</strong></p><h4 id="具体实现">具体实现</h4><p>分析清楚之后便可自己尝试写出代码了，首先要写的，便是 <strong>组合</strong> 部分，C语言代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">- 将数组a的局部a[l,r-1]和a[r,rightEnd]合并到tmp</span></span><br><span class="line"><span class="comment">    - 然后再拷贝回a[l,rightEnd]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rightEnd, <span class="keyword">int</span> tmp[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> leftEnd = r - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> left = l, count = l;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt;= leftEnd &amp;&amp; r &lt;= rightEnd) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[l] &lt; a[r])</span><br><span class="line">tmp[count++] = a[l++];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">tmp[count++] = a[r++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt;= leftEnd)</span><br><span class="line">tmp[count++] = a[l++];</span><br><span class="line"><span class="keyword">while</span> (r &lt;= rightEnd)</span><br><span class="line">tmp[count++] = a[r++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; rightEnd+<span class="number">1</span>; i++) </span><br><span class="line">a[i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以完成划分部分，从而进行排序了。C语言代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> rightEnd, <span class="keyword">int</span> tmp[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; rightEnd) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (rightEnd-left)/<span class="number">2</span>;</span><br><span class="line">mergeSort(a, left, mid, tmp);<span class="comment">// 划分左半部分</span></span><br><span class="line">mergeSort(a, mid+<span class="number">1</span>, rightEnd, tmp);<span class="comment">// 划分右半部分</span></span><br><span class="line">merge(a, left, mid+<span class="number">1</span>, rightEnd, tmp);<span class="comment">// 组合子问题的解</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="汉诺塔问题">汉诺塔问题</h4><p>作为练习，可尝试自己实现一下汉诺塔问题！【待补】</p><section class="footnotes"><hr /><ol><li id="fn1"><p>此处按照教科书上（算法技巧与分析【沙特】）来说，此步骤实质上是一种优化复杂度的步骤，但在此，为了简便起见，直接将其写为了子问题的求解。<a href="#fnref1" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;何为分治？简单来说，就是将大的问题分解成小问题进行求解，然后对每个小问题的解进行处理【一般是合并】为大问题的解，下面是分治较为官方的说明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分治：&lt;/strong&gt; 把一个任务，分成形式和原任务相同，但规模更小的 几个部分任务（通常是两个部分），分别完成，或只需要选一部完成。然后再处理完成后的这一个或几个 部分的结果，实现整个任务的完成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="博客" scheme="https://wenmang.gitbub.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="算法思想" scheme="https://wenmang.gitbub.io/tags/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>C的编译与链接</title>
    <link href="https://wenmang.gitbub.io/2019/10/04/C%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
    <id>https://wenmang.gitbub.io/2019/10/04/C%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/</id>
    <published>2019-10-04T13:43:29.000Z</published>
    <updated>2019-10-05T05:58:34.042Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>曾经在初读 <code>CSAPP</code> 之时，我初步了解了 C 语言的全部<a href="%5Bhttps://github.com/wenmang/hello-world/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/SectionI/note/C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C.md%5D(https://github.com/wenmang/hello-world/blob/master/深入理解计算机系统（第二版）/SectionI/note/C语言代码的编译和执行.md)">编译</a>过程，即大概可分为以下三大步：</p><ul><li>预处理</li><li>编译</li><li>链接</li></ul><p>今天，又看了节公开课，对这部分有了相对较为深入的理解，并且知道了一些有意思的事情。</p><a id="more"></a><p>开始之前，我们应该有这样一个概念：在使用 <code>gcc</code> 编译器进行编译之时，以上三步在某种意义上来说是相互分离的。</p><h3 id="预处理阶段">预处理阶段</h3><p>对于此阶段，我之前所理解的全部，便是曾经所做的笔记：</p><blockquote><p>通过预处理器( <code>cpp</code> ) 处理之后，将其变成了 <code>.i</code> 文件，<code>.i</code> 文件实际上对你写的 <code>.c</code> 文件里以井号 <code>#</code> 开头的语句进行了处理，其发现你引入了某个头文件，于是预处理器便将头文件的内容插入到了你的代码之中。</p></blockquote><p>而如今，我想可以进一步扩展（或许不准确），预处理阶段所处理的内容，实质上就是对 C语言中的宏进行处理，而其中需要处理的部分，即通过宏语法限定的，在程序中<strong>有效的宏语言</strong><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。其中主要有两大类：</p><ul><li><code>#define</code> ：对以 <code>#define</code> 打头的宏定义部分进行替换。</li><li><code>#include</code>：对以 <code>#include</code> 格式引入的库文件进行添加。</li></ul><h4 id="define"><code>#define</code></h4><p>最为常见的宏定义，新手常常使用其表示变量，老手便会使用宏来表示一些简单的函数等等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159<span class="comment">// 新手</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b))?(a):(b)<span class="comment">// 老手</span></span></span><br></pre></td></tr></table></figure><p>一般来说，既然已经有了函数，但是还是有许多人使用宏来替代函数，那么必有原因，一般来说，宏的优点主要有以下几点：</p><ul><li>同函数一般，简单可复用！同时能够使代码含义更加清晰。</li><li>与函数相比，其直接在预处理阶段进行替换，所以其省去了函数调用的时间，所以，我觉得宏适合在下列情境下使用：<ul><li>函数功能较为简单，只有一行代码，函数调用所花时间对函数功能影响较大</li><li>函数需要多次重复使用（不适合有递归的情况）</li></ul></li></ul><h4 id="include"><code>#include</code></h4><p>只要学过C语言，想必就不会对此陌生，人生中第一个 <code>hello world</code> 就使用了这个语句，也就是所谓的头文件，头文件的格式有以下两种：</p><ul><li><code>#include&lt;&gt;</code> ：以 <code>&lt;&gt;</code> 引用的一般是系统自带的库文件</li><li><code>#include&quot;&quot;</code> ：以 <code>&quot;&quot;</code> 引用的一般是自己写的头文件</li></ul><p>此部分无需多叙。</p><h3 id="编译阶段">编译阶段</h3><p>所谓编译，就是将C语言文件编译为汇编文件，以方便计算机执行，而此阶段所做工作的<strong>目的是：</strong> 将C语言进行初步编译，并对程序进行语法上的一次检查，对不符合语法规则的，进行报错，也就是 <code>Error</code> ，并会停止程序的编译 ；对有争议，或是不明确的内容提出警告 <code>Warning</code> ，但是并不会停止编译，最终还是会生成可执行文件 。</p><p>既然如此，那么有这样一个有趣的问题：<strong>如果，我们在写代码的时候，不加上头文件，那么该代码是否能通过编译呢？</strong></p><h4 id="示例">示例</h4><p>有这样一段毫无意义的代码，其目的仅是为了说明上述问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;// printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;// malloc, free</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;// assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* mom = <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    assert(mom != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;yeah!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(mom);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先将 <code>#include&lt;stdio.h&gt;</code> 注释掉，那么此时，编译到 <code>printf</code> 语句的时候，编译器由于找不到 <code>printf</code> 的声明，于是会提出警告，并将 <code>printf</code> 以默认的方式进行编译——将之认为是一个函数（参数为字符串，返回值为 <code>int</code> ）。</p><p>所以在编译阶段，此代码即使去掉了 <code>#include&lt;stdio.h&gt;</code> 头文件，也依旧能够编译成功</p><h3 id="链接阶段">链接阶段</h3><p>链接阶段看似是根据编译的结果进行的，但是却不尽然，因为链接阶段是相对独立的，在链接阶段，编译器会根据编译之后的结果，在库中去依次寻找对应的函数。</p><p>所以，上述代码，在编译成功之后，进行链接之时，依旧能够从库中寻找到 <code>printf</code> 函数，并执行成功。也就是说，上述代码，去掉了 <code>#include&lt;stdio.h&gt;</code> 头文件，使用 <code>gcc</code> 编译，<strong>能够成功地编译并产生可执行文件</strong>，唯一的影响仅是：在编译过程中会产生一条警告信息。我自己实验的结果也同理论相同，结果如下图：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/05/JxjXuLgcdNYWkKr.png" alt="C的编译与链接1.png" /><figcaption>C的编译与链接1.png</figcaption></figure><p>可以看到，仅产生了一个 <code>warning</code>，并且能够执行成功。</p><h4 id="普适与特例">普适与特例</h4><p>同样地，在去掉 <code>#include&lt;stdlib.h&gt;</code> 之后，也如是。但是，正如上面所说，链接阶段会重新在库函数中寻找函数原型，那么<strong>对于所有的库函数，都能够如此吗？</strong> 答案当然是<strong>否定的！</strong></p><p><code>#include&lt;assert.h&gt;</code> 头文件之中，<code>assert()</code> 的实现，实质上并不是一个函数，<strong>而是一个宏定义</strong>，所以如果去掉此头文件，在编译阶段便会将 <code>assert()</code> 解释为一个函数。但是显然，<strong>其并非一个函数，那么链接之时便不可能找得到了</strong>，所以如此便会出错！验证结果如下：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/05/EuZRKoiCy4w7PlB.png" alt="C的编译与链接2.png" /><figcaption>C的编译与链接2.png</figcaption></figure><h4 id="意义">意义</h4><p>乍一看，这种写法好像没什么意义，但是，如果需要追求极度的精简，减小文件体积，这样的写法还是有意义的。事实上，我觉得这种写法，其实是远古时期，内存极度短缺时候的小技巧【实际测试中，其最后产生的可执行文件大小是一样的】。</p><p>至于为何会影响文件大小？<strong>因为加上头文件之后，在预处理阶段就会将头文件中的所有内容加到你的程序当中</strong>，而尽管你只使用了该头文件中的几个函数。而以现在大内存当道的现状，估计很少会有人这么写了。</p><p>所以，此技巧更多地还是体现了<strong>C语言的 ”自由“</strong>，并且还是蛮有趣的。</p><h3 id="深入">深入</h3><p>既然不加头文件，编译器会将其理解为一个函数，那么我们就会想到：我直接在自己的代码中以函数的方式进行声明，那么是不是就不会产生警告了？<strong>答案是可行的！</strong><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>验证如下：</p><p>代码改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;// malloc, free</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;// assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">char</span>* s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* mom = <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    assert(mom != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;yeah!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(mom);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/05/C5yD3Hw78dvmMUo.png" alt="C的编译与链接3.png" /><figcaption>C的编译与链接3.png</figcaption></figure><h3 id="拓展">拓展</h3><p>有个很有趣的事情，如果不加库，并且利用一个库函数中已有的函数，但是将其参数进行改变（传参数目变多或变少），那么此时程序又会如何被编译，或是产生何种后果？</p><p>比如下面一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">65</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>((<span class="keyword">char</span>*)&amp;num, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length = %d\n&quot;</span>, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>话不多说，首先来看编译结果：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/05/MUlkeT5Os2fPWQC.png" alt="C的编译和链接4.png" /><figcaption>C的编译和链接4.png</figcaption></figure><p>哈哈哈哈哈，报错了，本来还想着正确之后讲述一番教授的思路呢！看来时代变了啊，编译器是变得安全了不少！那这部分也只能提前结束了。</p><section class="footnotes"><hr /><ol><li id="fn1"><p>为何说是有效，因为宏拥有一套自己简单的语法，可以控制某段宏是否进行处理，处理几次等操作，所以在此使用了有效的宏语言一词<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>可以看到，最终编译结果和公开课教授所讲的还是有出入，可能是编译器进化了的缘故吧！毕竟是<code>10</code> 年的公开课<a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;曾经在初读 &lt;code&gt;CSAPP&lt;/code&gt; 之时，我初步了解了 C 语言的全部&lt;a href=&quot;%5Bhttps://github.com/wenmang/hello-world/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/SectionI/note/C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C.md%5D(https://github.com/wenmang/hello-world/blob/master/深入理解计算机系统（第二版）/SectionI/note/C语言代码的编译和执行.md)&quot;&gt;编译&lt;/a&gt;过程，即大概可分为以下三大步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理&lt;/li&gt;
&lt;li&gt;编译&lt;/li&gt;
&lt;li&gt;链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天，又看了节公开课，对这部分有了相对较为深入的理解，并且知道了一些有意思的事情。&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://wenmang.gitbub.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="底层" scheme="https://wenmang.gitbub.io/tags/%E5%BA%95%E5%B1%82/"/>
    
    <category term="C" scheme="https://wenmang.gitbub.io/tags/C/"/>
    
    <category term="有趣" scheme="https://wenmang.gitbub.io/tags/%E6%9C%89%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>C函数执行</title>
    <link href="https://wenmang.gitbub.io/2019/10/04/C%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/"/>
    <id>https://wenmang.gitbub.io/2019/10/04/C%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/</id>
    <published>2019-10-04T04:44:31.000Z</published>
    <updated>2019-10-28T06:25:59.700Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇博文根据斯坦福公开课 《编程范式》整理，来阐述C语言函数执行时，在内存中的简单过程，也算是一个简单的笔记。</p><a id="more"></a><h3 id="函数的活动记录">函数的活动记录</h3><p>所谓活动记录，便是C语言程序在调用过程中的储存分配方案的记录。即：当一个过程被调用时，就把它的活动记录推入运行时存储栈的栈顶，而在控制返回调用程序时，再从栈顶弹出相应的活动记录。如此反复，以执行整个程序。</p><p>我们首先将内存抽象为一个索引从 0 开始的庞大数组，然后为了方便说明函数的具体执行过程，我们以一段简单的代码作为说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们写下这样一个函数的时候，在编译过程中，在内存中会如下图这样分配空间：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/04/b5tiMoPpc6n9JG7.png" alt="C函数活动记录1.png" /><figcaption>C函数活动记录1.png</figcaption></figure><p>在该函数编译之时，以 <code>Save PC</code> 为分界线，内存上半部分依次为形参空间，下半部分为函数中所申明的变量的空间。</p><p><strong>注：<code>save PC</code> 我其实并没有搞得很懂，但是按照老师的说法，应当可以理解为函数本身的地址（此处存疑）</strong></p><h3 id="函数的执行">函数的执行</h3><p>为了较为顺畅地理解，我们依旧以示例代码来说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> foo(a<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    foo(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，编译之时，会像上边一般，在内存中以相同的方式分配空间，然后，函数开始执行：</p><p>执行过程会在内存的栈区进行，在调用 <code>foo</code> 函数之后，<code>PC</code> 会直接跳转到 <code>foo</code> 函数所在的内存空间之处，也就是 <code>Save PC</code> 所在，如下图所示：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/04/Vh3pWATvqNbDyF4.png" alt="C函数活动记录2.png" /><figcaption>C函数活动记录2.png</figcaption></figure><p>由于 <code>foo</code> 函数的形参刚好在其上，所以，参数传递就如此完成了。此后，便会执行 <code>foo</code> 函数中的语句。</p><h3 id="有趣的例子">有趣的例子</h3><p>利用上述原理，有这样一个有趣的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line"><span class="built_in">array</span>[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">createArray();</span><br><span class="line"><span class="comment">// printf(&quot;Hello&quot;);</span></span><br><span class="line">printArray();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到代码，你会有点懵，这不就是打印 <code>0-99</code> 吗？<strong>这代码有什么特别呢</strong>？然而，你再看看，便会发现两个 <code>array</code> 数组是在两个函数中，这时候你可能会记起当年学的C语言，<strong>不同函数中的声明是相互独立的啊</strong>？这样写不是脱裤子放屁吗？你就会心有疑虑，对这样是否能够实现相关功能而存疑。</p><p>然而，通过上述原理我们知道，函数调用结束之后，只是指针在内存中的跳转，而内容并不会被擦去，所以答案是肯定的，运行代码，会正常输出 <code>0 1 2 3 ...99</code> 。</p><p>那么如果在两次调用中加上一句呢？也就是将上面代码的的注释去掉。然后在运行你便会发现不成了，这是因为<strong>两次调用中间如果加入了其余语句，便会扰乱前一个函数所初始化的内存，从而使得第二个函数不能正常打印</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此篇博文根据斯坦福公开课 《编程范式》整理，来阐述C语言函数执行时，在内存中的简单过程，也算是一个简单的笔记。&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://wenmang.gitbub.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="C语言" scheme="https://wenmang.gitbub.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="底层" scheme="https://wenmang.gitbub.io/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Fisher线性判别</title>
    <link href="https://wenmang.gitbub.io/2019/09/28/Fisher%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB/"/>
    <id>https://wenmang.gitbub.io/2019/09/28/Fisher%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB/</id>
    <published>2019-09-28T05:53:59.000Z</published>
    <updated>2019-09-28T14:26:58.625Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="分类问题">分类问题</h3><p>现实世界中，我们常常需要对事物进行分类，而分类的所依据的标准往往是多样的，这尤其体现在使用电脑解决分类问题之时。</p><p>我们如果要使用电脑进行分类，首先需要的便是数据。比如：我们需要将两个不同品种的鱼进行分类，我们首先需要根据找不同的方式找出两种鱼在某些特征上的不一致之处（如：长度，宽度，鱼鳍数目、长度等等）。我们将找出来的这些特征构建为一个行向量，同时对每一类都选许多条鱼进行测量，每一条鱼都能得到这样个行向量，将所有行向量拼接起来，构成一个<span class="math inline">\(N\times M\)</span> 的矩阵（<span class="math inline">\(N\)</span> 为鱼的数目，<span class="math inline">\(M\)</span> 为依据的特征数目），这样就构成了一个简单的有标签的数据集。</p><a id="more"></a><p>有了数据集，接下来所要做的便是分类。什么是分类呢？现实生活中此概念很简单，比如我们买鱼时便有许多选择：鲤鱼，草鱼，带鱼等等等等，而用以区分这些鱼类的，大都是凭经验根据某些特征来区分。其实电脑也一样，分类要做的，就是将两类数据通过一个分类面区分开来，如下粗糙的图所示，分类所做的就是根据已有的数据，找出中间那条红线，将二者分开。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/28/ko2z9ISYOnjx3ma.png" alt="Fisher1.png" style="zoom:60%;" /></p><p>而所谓分类的方法，其归根到底就是利用各种方法，来找到这样一个最佳分类面。而这篇博客所介绍的，仅是所有方法中非常简单的一种——Fisher线性判别。</p><h3 id="fisher线性判别">Fisher线性判别</h3><p><code>Fisher</code> 线性判别 是一种<strong>简单的二分类</strong>方法，其主要思路就是将高维空间的数据进行降维投影至一维空间，从而降低分类的难度。其一般步骤如下：</p><ul><li>将高维数据投影到一维平面上</li><li>通过运算使得每一类之间更加紧凑（使同一类数据之间的距离变小），两类之间的距离尽可能远，从而方便将两类数据分开。</li><li>一般以两类数据中心点的中点最为分类面。</li></ul><h4 id="数学原理">数学原理</h4><p>显然，Fisher线性判别的重难点在于前两步，即如何找到一个投影面，使得类内距离尽可能小而类间距离尽可能大。</p><h5 id="基础概念">基础概念：</h5><p><strong>在 <code>d</code> 维的 <code>X</code> 空间中（样本空间）：</strong></p><ul><li><p><strong>各类样本的均值向量</strong><span class="math inline">\(m_i\)</span> ：<span class="math inline">\(m_i = \frac{1}{n_i}\sum_\limits{X\in D_i}{X},\ i=1,2\)</span></p></li><li><p><strong>样本类内离散矩阵</strong><span class="math inline">\(S_i\)</span>和<strong>总样本类内离散度矩阵</strong><span class="math inline">\(S_w\)</span> （其实可以看出来，所谓类内离散度矩阵便是<strong>每一个样本与样本均值向量之间的欧氏距离</strong>所构成的矩阵） <span class="math display">\[\begin{align*}  &amp; S_i = \sum_{X\in D_i}(x-m_i)(x-m_i)^T,\ i = 1, 2\\  &amp;S_w = S_1+S_2\\\end{align*}\]</span></p></li><li><p><strong>样本类间离散度矩阵</strong> $ S_b $ （即两类样本均值之间的欧氏距离） <span class="math display">\[S_b = (m_1-m_2)(m_1-m_2)^T\]</span></p></li></ul><p><strong>在 <code>1</code> 维的 <code>Y</code> 空间中（投影空间）：</strong></p><ul><li><p><strong>各类样本的均值</strong> <span class="math inline">\(\tilde{m_i}\)</span> ：<span class="math inline">\(\tilde{m_i} = \frac{1}{n_i}\sum_\limits{y\in D_i}{y},\ i=1,2\)</span></p></li><li><p><strong>样本类内离散度</strong> <span class="math inline">\(\tilde{S_i}\)</span> 和<strong>总样本类内离散度</strong> <span class="math inline">\(\tilde{S_w}\)</span> <span class="math display">\[\begin{align*}  \tilde{S_i} &amp;= \sum_{y\in D_i}(y- \tilde{m_i})(y- \tilde{m_i})^T,\ i = 1, 2\\  &amp;=\sum_{y\in D_i}(y- \tilde{m_i})^2,\ i = 1, 2\\  \tilde{S_w} &amp;= \tilde{S_1}+ \tilde{S_2}\\\end{align*}\]</span></p></li><li><p><strong>样本类间离散度：</strong> <span class="math display">\[\begin{align*}  \tilde{S_b} &amp;= (\tilde{m_1}-\tilde{m_2})(\tilde{m_1}-\tilde{m_2})^T\\  &amp;=(\tilde{m_1} - \tilde{m_2})^2\end{align*}\]</span></p></li></ul><p>接下来要让投影后的类内距离尽可能小而类间距离尽可能大，也就是要使得 <span class="math inline">\(\tilde{S_w}\)</span> 尽可能小， <span class="math inline">\(\tilde{S_b}\)</span> 尽可能大，换言之也就是令 <span class="math inline">\(\frac{\tilde{S_b}}{\tilde{S_w}}\)</span> 尽可能取得最大值，我们令其比值为 <span class="math inline">\(J(w)\)</span>，如下式子： <span class="math display">\[\begin{align*}    J(w) &amp;= \frac{\tilde{S_b}}{\tilde{S_w}}= \frac{(\tilde{m_1} - \tilde{m_2})^2}{\tilde{S_1}+ \tilde{S_2}}\end{align*}\]</span> 又因为，由各类样本均值可推出： <span class="math display">\[\begin{align*}    \tilde{m_i} &amp;= \frac{1}{n_i}\sum_\limits{y\in D_i}{y}\\    &amp;= \frac{1}{n_i}\sum_\limits{X\in D_i}{w^Tx}\\    &amp;= {w^T}(\frac{1}{n_i}\sum_\limits{X\in D_i}{x})\\    &amp;= w^Tm_i\end{align*}\]</span></p><p>则，投影样本均值之差可以展开为： <span class="math display">\[\begin{align*}    (\tilde{m_1} - \tilde{m_2})^2 &amp;= (w^Tm_1 - w^Tm_2)^2\\    &amp;= w^T(m_1-m_2)(m_1-m_2)^Tw\\    &amp;= w^TS_bw\end{align*}\]</span> 同理，可将 <span class="math inline">\(\tilde{S_i}\)</span> 以相同的方式进行变化： <span class="math display">\[\begin{align*}    \tilde{S_i} &amp;= \sum_{y\in D_i}(y- \tilde{m_i})^2\\    &amp;= \sum_{X\in D_i}{(w^Tx-w^Tm_i)^2}\\    &amp;= \sum_{X\in D_i}{w^T(x-m_2)(x-m_2)^Tw}\\    &amp;= w^TS_iw\end{align*}\]</span> 则 <span class="math inline">\(J(w)\)</span> 可化为： <span class="math display">\[\begin{align*}    J(w) &amp;= \frac{(\tilde{m_1} - \tilde{m_2})^2}{\tilde{S_1}+ \tilde{S_2}}\\    &amp;= \frac{w^TS_bw}{w^TS_ww}\end{align*}\]</span> 之后令分母为非零常数，然后采用<strong>拉格朗日乘子法</strong>确定最佳变换向量，定义拉格朗日函数如下： <span class="math display">\[\begin{align*}    L(w, \lambda) = w^TS_bw-\lambda (w^TS_ww-c)\end{align*}\]</span> 求解过程如下： <span class="math display">\[\begin{align*}    &amp;\frac{\partial L(w,\lambda)}{\partial w} = 2S_bw-2\lambda S_ww =0\\    \\    即：\qquad &amp;S_bw^* = \lambda S_ww^* \qquad S^{-1}_wS_bw^* = \lambda w^*\\    \\\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}    w^* &amp;= \frac{1}{\lambda}S^{-1}_wS_bw^*\\    &amp;= \frac{1}{\lambda}S^{-1}(m_1-m_2)(m_1-m_2)^Tw^*\\    &amp;= \frac{R}{\lambda}S^{-1}(m_1-m_2)\end{align*}\]</span></p><p>省去常数，则最后可得 <span class="math inline">\(w^* = S^{-1}(m_1-m_2)\)</span></p><p>数据便可通过向量 <span class="math inline">\(w^*\)</span> 投影至一维平面上，变成一个个点，而要将两类分开，便直接可以找出阈值点 <span class="math inline">\(w_0\)</span> ，将之分开。常用确定方法如下： <span class="math display">\[\begin{align*}    &amp;w^0 = \frac{\tilde{m_1} - \tilde{m_2}}{2}\\    &amp;w_0 = \frac{n_1\tilde{m_1} + n_2\tilde{m_2}}{n_1+n_2} = \tilde{m}\\    &amp;w^0 = \frac{\tilde{m_1} - \tilde{m_2}}{2}+\frac{ln[P(w_1)/P(w_2)]}{n_1+n_2-2}\end{align*}\]</span></p><h4 id="实例验证">实例验证</h4><p><strong>要求：</strong>在 <code>UCI</code> 数据集上的 <code>Iris</code>和 <code>sonar</code> 数据上验证算法的有效性。【<code>Iris</code> 数据3类，4维，150个数据；<code>Sonar</code> 数据2类，60维，208个样本】</p><p><strong>说明：</strong>训练和测试样本有三种方式进行划分：（三选一）</p><ol type="1"><li>将数据随机分训练和测试，多次平均求结果</li><li>k折交叉验证</li><li>留1法</li></ol><h5 id="下载数据集">下载数据集</h5><p>到 <a href="https://archive.ics.uci.edu/ml/index.php"><code>UCI</code></a> 官网上即可直接下载两个数据集</p><h5 id="零碎说明">零碎说明</h5><ul><li>我选择的是第一种划分方式</li><li>为了简便，我使用了 <code>MATLAB</code> 进行编程</li></ul><h5 id="开始验证">开始验证</h5><ul><li><p>首先将<strong>数据读入，并划分矩阵</strong>，此为基础问题，不再赘述</p></li><li><p>然后，<strong>利用 <code>mean()</code> 函数 求每一类样本的均值向量</strong></p></li><li><p>根据公式，求取训练数据的类内散度矩阵 <span class="math inline">\(S_i\)</span> 和 <span class="math inline">\(S_w\)</span> ，代码实现函数如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[s]</span> = <span class="title">getScatter</span><span class="params">(sample, size, m, n1, n2)</span></span></span><br><span class="line"><span class="comment">% getScatter</span></span><br><span class="line">    <span class="comment">%   计算数据的类内离散度矩阵</span></span><br><span class="line">    s = &#123;<span class="built_in">zeros</span>(<span class="built_in">size</span>), <span class="built_in">zeros</span>(<span class="built_in">size</span>), <span class="built_in">zeros</span>(<span class="built_in">size</span>)&#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n1</span><br><span class="line">        tmp = sample&#123;<span class="built_in">i</span>:<span class="built_in">i</span>&#125;;</span><br><span class="line">        mi = m&#123;<span class="built_in">i</span>:<span class="built_in">i</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n2</span><br><span class="line">            xj = tmp(<span class="built_in">j</span>:<span class="built_in">j</span>, :);</span><br><span class="line">            A = (xj-mi);</span><br><span class="line">            si = A&#x27; * A;</span><br><span class="line">            s&#123;<span class="built_in">i</span>:<span class="built_in">i</span>&#125; = s&#123;<span class="built_in">i</span>:<span class="built_in">i</span>&#125; + si;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>根据公式，求取最佳变换向量 <span class="math inline">\(w^*\)</span> 和阈值 <span class="math inline">\(w_0\)</span> ，代码实现函数如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[w, w0]</span> = <span class="title">bestVector</span><span class="params">(s1, s2, m1, m2)</span></span></span><br><span class="line">    <span class="comment">% bestVector </span></span><br><span class="line">    <span class="comment">%   求取最佳变换向量</span></span><br><span class="line">    sw = s1 + s2;</span><br><span class="line">    w = sw \ ((m1 - m2)&#x27;);</span><br><span class="line">    w0 = (w&#x27;*m1&#x27; + w&#x27;*m2&#x27;) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>将样本矩阵在投影方向上投影，以方便进行检验和画图，代码实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[D]</span> = <span class="title">rearProjection</span><span class="params">(sample, size, i1, i2, w1, n)</span></span></span><br><span class="line">    <span class="comment">% rearProjection</span></span><br><span class="line">    <span class="comment">%   计算投影后的点</span></span><br><span class="line">    D = &#123;<span class="built_in">zeros</span>(<span class="built_in">size</span>, <span class="number">1</span>), <span class="built_in">zeros</span>(<span class="built_in">size</span>, <span class="number">1</span>)&#125;;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = [i1 i2]</span><br><span class="line">        tmp = sample&#123;<span class="built_in">i</span>:<span class="built_in">i</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n(k)</span><br><span class="line">            xj = tmp(<span class="built_in">j</span>:<span class="built_in">j</span>, :);</span><br><span class="line">            Di = w1&#x27; * xj&#x27;;</span><br><span class="line">            D&#123;k:k&#125;(<span class="built_in">j</span>,<span class="number">1</span>) = Di;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        k = k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>进行检验，我写了两个函数，分别检验两类分的是否正确，代码实现如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[rate]</span> = <span class="title">testLeft</span><span class="params">(class, i, n, w1, w0)</span></span></span><br><span class="line">    <span class="comment">% test</span></span><br><span class="line">    <span class="comment">%   检验剩余测试用例</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="built_in">i</span>:n</span><br><span class="line">        xj = class(<span class="built_in">j</span>:<span class="built_in">j</span>, :);</span><br><span class="line">        Di = w1&#x27; * xj&#x27;;</span><br><span class="line">        <span class="keyword">if</span> Di &lt; w0</span><br><span class="line">            count = count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    rate = (count*<span class="number">100</span>)/(n+<span class="number">1</span>-<span class="built_in">i</span>);</span><br><span class="line">    fprintf(<span class="string">&quot;%d/%d = %.2f%%\n&quot;</span>, count, (n-<span class="built_in">i</span>+<span class="number">1</span>), rate);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[rate]</span> = <span class="title">testRight</span><span class="params">(class, i, n, w1, w0)</span></span></span><br><span class="line">    <span class="comment">% test</span></span><br><span class="line">    <span class="comment">%   检验剩余测试用例</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="built_in">i</span>:n</span><br><span class="line">        xj = class(<span class="built_in">j</span>:<span class="built_in">j</span>, :);</span><br><span class="line">        Di = w1&#x27; * xj&#x27;;</span><br><span class="line">        <span class="keyword">if</span> Di &gt; w0</span><br><span class="line">            count = count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    rate = (count*<span class="number">100</span>)/(n+<span class="number">1</span>-<span class="built_in">i</span>);</span><br><span class="line">    fprintf(<span class="string">&quot;%d/%d = %.2f%%\n&quot;</span>, count, (n-<span class="built_in">i</span>+<span class="number">1</span>), rate);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>将投影后的数据画出散点图，画图函数如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[]</span> = <span class="title">drawPicture</span><span class="params">(x1, x2, n, w0)</span></span></span><br><span class="line">    <span class="comment">% drawPicture</span></span><br><span class="line">    <span class="comment">%   画图函数，分类点为五角星</span></span><br><span class="line">    <span class="built_in">figure</span></span><br><span class="line">    <span class="built_in">scatter</span>(x1, <span class="built_in">zeros</span>(n(<span class="number">1</span>), <span class="number">1</span>), <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">scatter</span>(x2, <span class="built_in">zeros</span>(n(<span class="number">2</span>), <span class="number">1</span>), <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">scatter</span>(w0, <span class="number">0</span>, <span class="number">400</span>, <span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="结果展示">结果展示</h5><p>由于 <code>Fisher</code> 仅用于处理二分类问题，但是，<code>Iris</code> 数据集有三类，所以我仅在两两之间进行了分类。执行完毕后画出的三张散点图如下：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/28/uOcRG5ZjfFboWBx.png" alt="Iris1-2.png" /><figcaption>Iris1-2.png</figcaption></figure><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/28/DHgfhqzY49r2VLt.png" alt="Iris1-3.png" /><figcaption>Iris1-3.png</figcaption></figure><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/28/YqOwTsc1XZEdfzm.png" alt="Iris2-3.png" /><figcaption>Iris2-3.png</figcaption></figure><p><code>Sonar</code> 数据集只有两类，分类后的图像如下：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/28/Co9RzsWtPEgKXrS.png" alt="sonar.png" /><figcaption>sonar.png</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;分类问题&quot;&gt;分类问题&lt;/h3&gt;
&lt;p&gt;现实世界中，我们常常需要对事物进行分类，而分类的所依据的标准往往是多样的，这尤其体现在使用电脑解决分类问题之时。&lt;/p&gt;
&lt;p&gt;我们如果要使用电脑进行分类，首先需要的便是数据。比如：我们需要将两个不同品种的鱼进行分类，我们首先需要根据找不同的方式找出两种鱼在某些特征上的不一致之处（如：长度，宽度，鱼鳍数目、长度等等）。我们将找出来的这些特征构建为一个行向量，同时对每一类都选许多条鱼进行测量，每一条鱼都能得到这样个行向量，将所有行向量拼接起来，构成一个&lt;span class=&quot;math inline&quot;&gt;\(N\times M\)&lt;/span&gt; 的矩阵（&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 为鱼的数目，&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 为依据的特征数目），这样就构成了一个简单的有标签的数据集。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AI" scheme="https://wenmang.gitbub.io/tags/AI/"/>
    
    <category term="模式识别" scheme="https://wenmang.gitbub.io/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>粗谈堆栈</title>
    <link href="https://wenmang.gitbub.io/2019/09/20/%E7%B2%97%E8%B0%88%E5%A0%86%E6%A0%88/"/>
    <id>https://wenmang.gitbub.io/2019/09/20/%E7%B2%97%E8%B0%88%E5%A0%86%E6%A0%88/</id>
    <published>2019-09-20T06:10:05.000Z</published>
    <updated>2019-10-05T06:15:49.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>堆栈是一两种十分常用的数据结构，而在硬件中根据内存相关分区功能的不同，将和此两种数据结构功能相似的分区（不是物理意义上的分区）分别称之为堆区栈区，简称堆栈。</p><ul><li>所以要搞清楚不同之处（我刚学C语言的时候一直搞不清楚）：堆栈在数据结构（软件）中来说是两种数据结构的名称；而在计算机内存中又表示两个不同的分区的名称</li></ul><a id="more"></a><h4 id="堆heap">堆（Heap）</h4><p>堆区在内存中占了相当大的一部分，这部分主要是为了储存程序中动态分配的数据，就C语言而言， <code>malloc()</code> <code>realloc()</code> <code>calloc()</code> 申请而来的空间就全部是堆中的空间，而动态申请的空间均需要利用 <code>free()</code> 手动释放掉。</p><p>当我们书写语句，在堆中申请空间：<code>int* tmp = malloc(40 * sizeof(int))</code> ，可以计算出，我们申请的空间大小理论上应该为 <span class="math inline">\(40 \times 4 = 160\)</span> ，但是其在堆中实际申请的空间应该是<strong>大于理论值一到两个字节</strong>的，而申请完毕后传回的指针实际上也不是申请空间的首地址，而是类似一个如下图所示的结构：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/05/vVO5rUkajoeM2AG.png" alt="粗谈堆栈1.png" /><figcaption>粗谈堆栈1.png</figcaption></figure><p>申请的实际空间如最大的红色边界线所示，而理论空间则如阴影部分所示，申请的空间最前面的一到两个字节（视底层的具体代码决定）用来<strong>标识由此开始的xx字节内存已被占用</strong>，以及一些必要的信息，来方便其他操作（例如需要 <code>free()</code> 之时，只需要将此标记移除或者改动即可）。</p><p><strong>谈谈<code>realloc()</code>：</strong> <code>realloc()</code> 进行内存扩展有两种方式：</p><ul><li>可以向后延拓之时，直接在此空间之后连续追加至相应的字节数即可</li><li>无法延拓之时，寻找适合的位置，另辟空间，将原有的数据复制过去，返回新空间的指针</li></ul><p><strong>一个减小 <code>malloc()</code> 时间复杂度的方法：</strong> 将所有空闲的内存首地址之间利用链表连接起来，并注明此处闲余空间是多少，然后再次开辟之时，便可以直接跳转寻找合适的空间</p><h4 id="栈stack">栈（Stack）</h4><p>栈是在程序运行时创立的一块内存，用于存放自动开辟的空间（在C语言中而言也就是声明的变量），其一般来说是可拓展空间的，可随着程序的执行自动进行扩展（就如同之前实现的那个栈一般）。</p><p><strong>注意：</strong></p><ul><li><code>int* tmp = malloc(40 * sizeof(int))</code> 在堆中存储</li><li><code>int tmp[40]</code> 在栈中存储</li></ul><p>关于此块内存，也就是遵循着先进后出的原则，就是说：<strong>其是随着程序运行来对内存进行动态分配的</strong> ，非常好理解，在次不多赘述。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆栈是一两种十分常用的数据结构，而在硬件中根据内存相关分区功能的不同，将和此两种数据结构功能相似的分区（不是物理意义上的分区）分别称之为堆区栈区，简称堆栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所以要搞清楚不同之处（我刚学C语言的时候一直搞不清楚）：堆栈在数据结构（软件）中来说是两种数据结构的名称；而在计算机内存中又表示两个不同的分区的名称&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://wenmang.gitbub.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="C语言" scheme="https://wenmang.gitbub.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="底层" scheme="https://wenmang.gitbub.io/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>链表及其常用操作</title>
    <link href="https://wenmang.gitbub.io/2019/09/11/%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://wenmang.gitbub.io/2019/09/11/%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2019-09-11T15:21:20.000Z</published>
    <updated>2019-09-14T13:50:47.175Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>链表是什么？学过数据结构的人都很清楚，链表就是一种最最最基本的数据结构，基本到什么程度呢？基本到数据结构课上所学的数据结构都可以用链表来实现。</p><p>正因为其基础，我们更要了解链表的基本操作。</p><a id="more"></a><h4 id="链表的构成及基本操作">链表的构成及基本操作</h4><p>首先了解链表（单向）的构成：链表由一个个统一的节点构成，节点一般由两个变量构成：</p><ul><li>一个值，可以为各种类型</li><li>一个指向下一个节点的“指针”</li></ul><p>链表的基本操作和多数数据结构相同，即插入，删除，查找等等。均很简单，也不再赘述，主要说说插入操作：</p><ul><li>从头插入：新建的节点插入到链表头部</li><li>从尾插入：新建的节点插入到链表尾部</li><li>从任意位置插入：字面意思。</li></ul><p>下面实现链表的构成及其基本操作（<code>LeetCode</code> 对应题目：<a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">Node next;</span><br><span class="line">Node(<span class="keyword">int</span> val)&#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line"><span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">        <span class="keyword">this</span>.tail = node;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">this</span>.head.val = val;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node tmp = <span class="keyword">new</span> Node(val);</span><br><span class="line">            tmp.next = head;</span><br><span class="line">            <span class="keyword">this</span>.head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">this</span>.tail.val = val;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node tmp = <span class="keyword">new</span> Node(val);</span><br><span class="line">            <span class="keyword">this</span>.tail.next = tmp;</span><br><span class="line">            <span class="keyword">this</span>.tail = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add a node of value val before the index-th node in the linked list.</span></span><br><span class="line"><span class="comment">     * If index equals to the length of linked list, </span></span><br><span class="line"><span class="comment">     * the node will be appended to the end of linked list.</span></span><br><span class="line"><span class="comment">     * If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="keyword">this</span>.size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(val);        </span><br><span class="line">            Node tmp = head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = tmp.next;</span><br><span class="line">            tmp.next = node;</span><br><span class="line">            <span class="keyword">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node node = head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="keyword">this</span>.size-<span class="number">1</span>) &#123;</span><br><span class="line">                tail = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表的反转">链表的反转</h4><p>什么是反转，简单来说，就是将 <code>12345</code> 变为 <code>54321</code> ，这便是反转。就链表而言，反转操作一般要求原地操作，尽可能减少空间使用，并且不允许直接改变链表的值。</p><p>表面来看反转好像很简单，但是实质上真正写起来也不是那么简单。链表操作的重难点，就是要防止链表断链丢失，所以，为了实现反转操作，我们需要三个节点指针，其过程如下图所示：</p><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/14/NZxj5CKOygPqVMz.png" alt="链表反转1.png" /><figcaption>链表反转1.png</figcaption></figure><p>反转的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">flipList</span><span class="params">(ListNode ptr, ListNode tail)</span> </span>&#123;</span><br><span class="line">ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (ptr != tail) &#123;</span><br><span class="line">ListNode next = ptr.next;</span><br><span class="line">ptr.next = newHead;</span><br><span class="line">newHead = ptr;</span><br><span class="line">ptr = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实质上就是将链表的箭头给翻转过来，而为了使链表不断链丢失，所以引入了三个指针。</p><p><code>LeetCode</code> 相关问题：</p><ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/">206. 反转链表</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表II</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></li></ul><h4 id="链表排序">链表排序</h4><p>链表排序可以直接将数组排序的算法代入其中，选择，归并啥的，只需要注意指针的完整性即可，下面附上链表的归并排序的函数（即：<a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)  <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode quick, slow;</span><br><span class="line">        quick = head.next;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (quick != <span class="keyword">null</span> &amp;&amp; quick.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quick = quick.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode mid = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode head1 = sortList(head);</span><br><span class="line">        ListNode head2 = sortList(mid);</span><br><span class="line">        </span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode ptr = newHead;</span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">                ptr.next = head1;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ptr.next = head1 == <span class="keyword">null</span> ? head2 : head1; </span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LeetCode</code> 其余相关问题：</p><ul><li><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></li><li><a href="https://leetcode-cn.com/problems/insertion-sort-list/">147. 对链表进行插入排序</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表是什么？学过数据结构的人都很清楚，链表就是一种最最最基本的数据结构，基本到什么程度呢？基本到数据结构课上所学的数据结构都可以用链表来实现。&lt;/p&gt;
&lt;p&gt;正因为其基础，我们更要了解链表的基本操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://wenmang.gitbub.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法基础" scheme="https://wenmang.gitbub.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    <category term="链表" scheme="https://wenmang.gitbub.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表之快慢指针</title>
    <link href="https://wenmang.gitbub.io/2019/09/06/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    <id>https://wenmang.gitbub.io/2019/09/06/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</id>
    <published>2019-09-06T14:15:21.000Z</published>
    <updated>2019-09-07T08:53:51.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>链表是最为基本的数据结构之一，常与数组作比较。由于链表相较于数组更加优良的的增删性能，常利用于增删比较频繁场合，并且衍生出了许多特殊的链表结构——静态链表，循环链表，双向链表等等。</p><p>而链表操作具有较强的技巧性，双指针最为常见，而双指针中，又以快慢指针最为特殊。这篇文章将根据自己的理解，说明快慢指针的原理与常见应用。</p><a id="more"></a><h3 id="链表的中间结点"><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">链表的中间结点</a></h3><h4 id="题目说明">题目说明</h4><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><h4 id="题目解答">题目解答</h4><p>链表的中间结点是快慢指针最为基础的一个例子， <code>java</code> 代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理分析">原理分析：</h4><p>原理颇为简单，但很精妙：</p><ul><li>声明两个指针，一个将之称为快指针，一个将之称为慢指针【快指针步长（一次经过的结点）相较慢指针更大，固有其名】</li><li>此处的快指针步长为2（一次两个结点），慢指针步长为 1 。当快指针到达链表末尾的时候，慢指针刚好到链表中间，由是一次循环便可以解决问题。</li></ul><h4 id="快慢指针的一般形式">快慢指针的一般形式</h4><p>由上题可见，快慢指针实质上就是两个步长不同的指针，步长大的称之为快指针，小的称之为慢指针。而解决问题的原理，在于利用两个指针步长不同所产生的差异，来进行问题的求解。</p><h3 id="环形链表"><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></h3><h4 id="题目描述">题目描述</h4><p>给定一个链表，判断链表中是否有环。环，即链表末尾并非指向 <code>null</code> ，而是指向链表中的任意一个结点。详情可点击超链接。</p><h4 id="题目解答-1">题目解答</h4><p>此题依旧可以利用快慢指针的思想来解答，<code>java</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode quick = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(quick != <span class="keyword">null</span> &amp;&amp; quick.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quick = quick.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (quick == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理分析-1">原理分析</h4><ul><li>同样是快慢指针，快指针步长为 2 ，慢指针步长为 1 。</li><li>如果两指针相遇，便说明链表中有环。</li></ul><p>那为快慢指针一定会相遇呢？我看了知乎的<a href="https://www.zhihu.com/question/23208893">同名问题</a>，发现有好多都用了这样一个比喻：两个同学在操场跑步，一个快，一个慢，跑的快的同学总能追的上跑得慢的同学。乍一听，好像颇有道理，但是细思，这个比喻其实是相当不合理的，<strong>跑道可以看是连续的，但是环形链表不是，一个个结点不是，它是离散的。</strong></p><p>所以，这样的比喻并没有任何说服力，而如要真正说明，便需要严谨的<strong>数学证明</strong>，也即此问题目前最高赞回答：</p><ul><li>快指针与慢指针之间差一步：此时继续往后走，慢指针前进一步，快指针前进两步，两者相遇。</li><li>快指针与慢指针之间差两步：此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差一步，又变为第一种情况。</li><li>快指针与慢指针之间差N步：此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差N-1步。</li></ul><p>所以，根据上述并不严谨的数学归纳法，便可清晰的说明原因。</p><p>但是若再深究，<strong>步长必须一个为 1 ，一个为 2 吗？</strong> 那么为了说明这点，就需要一个较为普遍的证明：</p><ul><li>一有环链表如下图所示：</li></ul><figure><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/07/8uzHLWtjrJEVblX.png" alt="指针之快慢指针2.png" /><figcaption>指针之快慢指针2.png</figcaption></figure><p><strong>参数说明：</strong></p><ul><li><code>A B</code> 分别为链表的头结点，环的入口结点</li><li><p><code>L1</code> 为非环部分的链表长度</p></li><li><code>L2</code> 为慢指针在环入口结点时候与快指针间的距离</li><li>链表环的周长为 <code>C</code></li><li><span class="math inline">\(S_s\)</span> 和 <span class="math inline">\(S_f\)</span> 分别为快指针和慢指针所走的 “路径”（即经过的结点数）</li><li><span class="math inline">\(N_1\)</span> 为正整数</li><li><p><span class="math inline">\(N_2\)</span> 为一任意实数数</p></li></ul><p><strong>证明：</strong></p><ul><li><p>当慢指针到达环的入口结点（即B点）之时，二者所经过的 “路程” 如下：</p><p><span class="math inline">\(S_S = L1\)</span></p><p><span class="math inline">\(S_f = 2\times L1 = L1 + N_1C + L2\)</span></p><p>则：<span class="math inline">\(L1 = N_1C + L2\)</span></p></li><li><p>假设慢指针与快指针在慢指针走了 <code>i</code> 之后相遇（快指针为慢指针的 <span class="math inline">\(N_2\)</span> 倍），可得方程如下：</p><p><span class="math inline">\((S_s + i - L1)\ mod\ C =(S_f + N_2i -L1)\ mod\ C\)</span></p><p><strong>代入可得：</strong> <span class="math inline">\(i\ mod\ C =(N_1C + N_2i + L2)\ mod\ C\)</span></p><p><strong>移向化简：</strong> <span class="math inline">\([(N_2 - 1)i + L1]\ mod\ C = 0\)</span></p><p>又因为 <code>NC</code> 是 <code>C</code> 的整数倍，可约去，所以最终等式为：<span class="math inline">\([(N_2-1)i+L1]\ mod\ C = 0\)</span></p></li></ul><p>则说明，只要 <span class="math inline">\((N_2-1)i+L1\)</span> 是 <span class="math inline">\(C\)</span> 的整数倍，那么快慢指针一定能够相遇</p><p><span class="math inline">\(N_2\)</span> 应该如何取值呢？</p><ul><li>显然，如果 <span class="math inline">\(N_2 = 1\)</span> （即两指针步长相同），那么等式就只有在 <span class="math inline">\(L1\)</span> 是 <span class="math inline">\(C\)</span> 整数倍的时候才能相遇</li><li><span class="math inline">\((N_2-1)i+L1 = KC\)</span> （<span class="math inline">\(K\)</span> 为任意正整数），显然，<span class="math inline">\(N_2\)</span> 取任意大于1的实数，均能够满足此等式</li></ul><p>所以，有环链表中，<strong>理论上只要快指针的步长大于慢指针的步长，两指针就能相遇</strong>。</p><p>但是，快指针步长为2，慢指针步长为1之时，其<strong>时间复杂度是最低</strong>的，故一般如此使用。【关于时间复杂度最低问题，链表中，快指针虽然说是一次走两步，但是其仍旧是一个结点一个结点逐次访问的，所以步长越大，其所遍历的多余结点数就越多，当然时间复杂度也会相应提升】</p><h3 id="环形链表-ii"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II</a></h3><p>本题与环形链表不同的是，需要求出环形链表的入环结点。此题所采用的算法好像正规名叫 Floyd 判圈算法 ，是图论里的一种算法。</p><h4 id="题目解答-2">题目解答</h4><p>这算法的<strong>详细描述</strong>是：</p><ul><li>利用快慢指针判断是否有环</li><li>如果有，则将相遇的结点标记，同时设新指针指向链表头。</li><li>两个指针分别从相遇的结点和链表头开始移动，直至相遇，相遇后的结点便是入环结点。</li></ul><p><code>java</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">findIntersection</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode intersection = findIntersection(head);</span><br><span class="line">        <span class="keyword">if</span> (intersection == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersection;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了清晰起见，重新定义了一个函数。</p><h4 id="原理分析-2">原理分析</h4><p>由上题之证明：二指针相遇之时，恰好满足 <span class="math inline">\([(N_2 - 1)i + L1]\ mod\ C = 0\)</span> ；</p><p>又因为<code>i</code> 为慢指针走的步数，<code>L1</code> 为前无环部分的长度，二者之和刚好是 <span class="math inline">\(C\)</span> 的整数倍。所以，可得 <span class="math inline">\(C-i = L1\)</span>，故此方法定能找到入环结点。</p><hr /><h4 id="参考文章">参考文章：</h4><p><a href="http://windsmoon.com/2017/10/09/判断单向链表是否有环及求环入口的算法数学证明/#more">windsmoon的博客：判断单向链表是否有环及求环入口的算法数学证明</a></p><p><a href="https://www.zhihu.com/question/23208893">知乎问题：为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？</a></p><p><a href="https://stackoverflow.com/questions/3952805/proof-of-detecting-the-start-of-cycle-in-linked-list">StackOverflow 提问：Proof of detecting the start of cycle in linked list</a></p><hr /><p>本文题目均来源于<code>LeetCode</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表是最为基本的数据结构之一，常与数组作比较。由于链表相较于数组更加优良的的增删性能，常利用于增删比较频繁场合，并且衍生出了许多特殊的链表结构——静态链表，循环链表，双向链表等等。&lt;/p&gt;
&lt;p&gt;而链表操作具有较强的技巧性，双指针最为常见，而双指针中，又以快慢指针最为特殊。这篇文章将根据自己的理解，说明快慢指针的原理与常见应用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="博客" scheme="https://wenmang.gitbub.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="算法技巧" scheme="https://wenmang.gitbub.io/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
    <category term="链表" scheme="https://wenmang.gitbub.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://wenmang.gitbub.io/2019/08/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://wenmang.gitbub.io/2019/08/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2019-08-19T01:54:44.000Z</published>
    <updated>2020-08-31T09:27:51.908Z</updated>
    
    <content type="html"><![CDATA[<p>什么是并查集？可以近似地用数学的观点来看，就像数学中的集合一般。但是并不尽相同，并查集在维基百科中的定义如下：</p><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/计算机科学">计算机科学</a>中，<strong>并查集</strong>是一种树型的<a href="https://zh.wikipedia.org/wiki/数据结构">数据结构</a>，用于处理一些<a href="https://zh.wikipedia.org/wiki/不交集">不交集</a>（Disjoint Sets）的合并及查询问题。</p></blockquote><a id="more"></a><p>既然名字叫并查集，那么肯定有其原因，因为此数据结构中的两个操作便是并和查。</p><ul><li><code>Find</code>【查】：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li><code>Union</code>【并】：将两个子集合并成同一个集合。</li></ul><h3 id="初始化并查集">初始化并查集</h3><p>我们可以使用两个数组来简单地实现并查集：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[MAX_N];<span class="comment">// 父亲</span></span><br><span class="line"><span class="keyword">int</span> rank[MAX_N];<span class="comment">// 树高</span></span><br></pre></td></tr></table></figure><p>有了以上定义，便可以实现并查集的初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">rank[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="并查集-查">并查集 —— 查</h3><ul><li>由于 <code>par[]</code> 数组储存的就是父节点下标，所以依次上诉，直至 <code>par[i]=i</code></li><li>在上寻过程中，可进行路径压缩，也就是将查找的结点直接挂接在根结点上</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询树的根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (par[x] == x) &#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> par[x] = find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集-并">并查集 —— 并</h3><ul><li>合并过程需要依次上溯，直至到根节点，然后比较二者所属集合的树高，将低的一方挂接在高的一方即可【这是为了使树相对平衡】。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并x和y所属的集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = find(x);</span><br><span class="line">y = find(y);</span><br><span class="line"><span class="keyword">if</span> (x == y)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rank[x] &lt; rank[y]) &#123;</span><br><span class="line">par[x] = y;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">par[y] = x;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y])rank[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是并查集？可以近似地用数学的观点来看，就像数学中的集合一般。但是并不尽相同，并查集在维基百科中的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/计算机科学&quot;&gt;计算机科学&lt;/a&gt;中，&lt;strong&gt;并查集&lt;/strong&gt;是一种树型的&lt;a href=&quot;https://zh.wikipedia.org/wiki/数据结构&quot;&gt;数据结构&lt;/a&gt;，用于处理一些&lt;a href=&quot;https://zh.wikipedia.org/wiki/不交集&quot;&gt;不交集&lt;/a&gt;（Disjoint Sets）的合并及查询问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wenmang.gitbub.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="博客" scheme="https://wenmang.gitbub.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="数据结构" scheme="https://wenmang.gitbub.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>由一道题重新审视排序</title>
    <link href="https://wenmang.gitbub.io/2019/08/14/%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://wenmang.gitbub.io/2019/08/14/%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E6%8E%92%E5%BA%8F/</id>
    <published>2019-08-14T11:31:44.000Z</published>
    <updated>2019-10-04T13:10:50.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天闲得无聊，写了道题，写完后，我发现这道题让我对排序有了更加深刻的认识，如今在看来，排序的核心主要有两点：</p><ul><li>比较函数（也就是比较的结果），决定了以何种方式进行排序：从大到小抑或是从小到大，甚至是其他更为特殊的方式</li><li>比较次数（也就是比较的方式），决定了排序的时间复杂度，也就是说，要想降低排序的时间复杂度，其重点就在于减少排序的次数。</li></ul><a id="more"></a><h3 id="排序总述">排序总述</h3><p>排序，在我看来，就是<strong>以给定的规则，对一组数（或者字符）进行重新排列</strong>，而规则是可变的，比如我们日常使用的：从大到小的顺序，从小到大的顺序，字典序等等等等。</p><p>那么，<strong>从底向上</strong>看排序，其最核心的部分，就在于两两比较，通过比较，就能确定两两之间的相对顺序——即谁先谁后。</p><p>而排序的效率，则取决于比较次数的多少，比如我们可以通过<strong>不重复比较</strong>，或者一些特殊的比较方式来缩短时间复杂度。</p><h3 id="比较函数">比较函数</h3><h4 id="总述">总述</h4><p>什么是比较函数？抽象来说，就是比较两个数，并确定其先后顺序的函数；具体来说，就是C语言 <code>qsort()</code> 函数中的 <code>cmp</code> 参数，是 <code>java</code> 中 <code>Arrays.sort()</code> 方法中的 <code>Comparator</code> 参数。</p><p>比较函数的一般写法是，对传入的两个参数（<code>a, b</code>）进行比较：</p><ul><li><code>a</code> 大于 <code>b</code> 返回 <code>1</code></li><li><code>a</code> 大于 <code>b</code> 返回 <code>-1</code></li><li><code>a</code> 大于 <code>b</code> 返回 <code>0</code></li></ul><p>规则进行返回，通过控制两个参数的传入，来控制从大到小排列或者从小到大排列。</p><h4 id="比较">比较</h4><p>比较可以自己写规则，比如最为简单的数字的 从大到小，从小到大 等等，但是一些时候就不仅仅是简单的的从大到小或是从小到大了，比如我今天写的这个题（<a href="https://leetcode-cn.com/problems/largest-number/"><code>leetcode 179</code></a>）：</p><p><strong>题目如下：</strong></p><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: 210</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: 9534330</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p><strong>题目解答：</strong></p><p>这题本质是一个排序问题，而排序的方式不再是简单的数字排序：</p><ul><li>数字从大到小排序：<code>98</code> 肯定在 <code>9</code>前面，但是此题则应该将顺序置反</li><li>数字从小到大排序：<code>2</code> 肯定在 <code>42</code> 前面，但是此题则应该将顺序置反</li></ul><p>所以此题的比较不能够按照常规方式写，而我们可以按照字符串的字典序来看，也就是说，将两个数字拼接，比较两种拼接方式的大小，从而选择排列顺序，比如：<code>98</code> 和 <code>9</code></p><ul><li>两个数只有两种拼接方式：<code>998</code> 明显大于 <code>989</code> ，所以 <code>9</code> 应该在 <code>98</code> 前面</li></ul><p>便是以此种方式，来进行排序，排序后，将之依次拼贴为一字符串即可, <code>java</code>代码（参考了 <code>leetcode</code> 官方题解）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LargerNumberComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">            String order1 = a + b;</span><br><span class="line">            String order2 = b + a;</span><br><span class="line">            <span class="keyword">return</span> order2.compareTo(order1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] numsString = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            numsString[i] = String.valueOf(nums[i]);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(numsString, <span class="keyword">new</span> LargerNumberComparator());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (numsString[<span class="number">0</span>].equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        String ret = <span class="keyword">new</span> String();</span><br><span class="line">        <span class="keyword">for</span> (String numString:numsString)</span><br><span class="line">            ret += numString;   </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较次数">比较次数</h3><p>这部分内容不算是重点，所以，大致说明即可：</p><ul><li>冒泡排序，每次循环都会比较，所以几乎每两个数字间都会进行比较，所以其时间复杂度为 <span class="math inline">\(O(N^2)\)</span></li><li>而比较高级的排序，比如归并，快排甚至桶排，都是降低了比较次数，从而降低了时间复杂度；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天闲得无聊，写了道题，写完后，我发现这道题让我对排序有了更加深刻的认识，如今在看来，排序的核心主要有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较函数（也就是比较的结果），决定了以何种方式进行排序：从大到小抑或是从小到大，甚至是其他更为特殊的方式&lt;/li&gt;
&lt;li&gt;比较次数（也就是比较的方式），决定了排序的时间复杂度，也就是说，要想降低排序的时间复杂度，其重点就在于减少排序的次数。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://wenmang.gitbub.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="算法" scheme="https://wenmang.gitbub.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="https://wenmang.gitbub.io/2019/08/02/%E9%98%9F%E5%88%97/"/>
    <id>https://wenmang.gitbub.io/2019/08/02/%E9%98%9F%E5%88%97/</id>
    <published>2019-08-02T08:58:43.000Z</published>
    <updated>2020-08-31T09:36:37.694Z</updated>
    
    <content type="html"><![CDATA[<p><strong>队列是具有一定操作约束的线性表，只能在一端（队尾）进行插入，另一端（队头）进行删除。</strong></p><p>简单地理解，按照字面意思，队列这种数据结构，就如同生活中排队的队列一般，后来的人（数据）只能跟在队尾，而队首的人（数据）首先接受服务（进行删除）。</p><ul><li>数据插入：入队列 （<code>addQueue</code>）</li><li>数据删除：出队列 （<code>deleteQueue</code>）</li></ul><a id="more"></a><p>而队列主要的<strong>特性</strong>如下：</p><ul><li>先来先服务</li><li>先进先出：FIFO</li></ul><p><strong>类型名称：</strong>队列（Queue）</p><p><strong>数据对象集：</strong>一个有0个或多个元素的有穷线性表</p><p><strong>操作集：</strong>长度为 <code>MaxSize</code> 的队列 <code>Q</code> 属于 <code>Queue</code>， 队列元素 <code>item</code> 属于 <code>ElementType</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Queue CreatQueue()生成空队列</span><br><span class="line">2. int IsFullQ(Queue PtrQ)判断队列Q是否已满</span><br><span class="line">3. void AddQ(Queue PtrQ, ElementType item)将数据元素item插入队列Q中</span><br><span class="line">4. int IsEmptyQ(Queue PtrQ)判断队列是否为空</span><br><span class="line">5. ElementType DeleteQ(Queue PtrQ)将对头数据元素从队列中删除并返回</span><br></pre></td></tr></table></figure><h3 id="队列的顺序储存实现">队列的顺序储存实现</h3><p>利用数组来实现相关操作</p><ul><li><h4 id="直接利用数组实现">直接利用数组实现</h4><p>数组的一端作为头，另一端作为尾，这样的方式是比较容易<strong>实现</strong>的：</p><ul><li>首先在空数组上的将队列头和尾均放在数组头的前一个位置，头和尾的标号为-1</li></ul></li><li><p>添加元素之后，则将队尾保存的标号加一；同理删除元素之后，将队头的元素加一</p></li></ul><p><strong>存在的问题：</strong></p><ul><li><p>如果队放满，也就是队尾下标为 <code>MaxSize-1</code> 但此时队头由于删除元素的原因，还空有位置，因此会造成空间浪费。</p></li><li><h4 id="利用环形数组实现">利用环形数组实现</h4><p>环形数组并不是物理意义上的环形，而是指队列如果放满之后（队尾下标为 <code>MaxSize-1</code> ），数组头部如果还有空位，就将新加进来的元素，从数组头继续存放。这时，如何判断队列是否已满呢？</p><p><strong>判断队列空和满</strong></p><ul><li><strong>空：</strong>队头下标等于队尾下标</li></ul></li><li><p><strong>满：</strong>队尾下标加一等于对头下标，但如果此时队尾下标而队头为0则无法用此法判断</p></li></ul><p><strong>改进：</strong>最大队尾下标加一除以 <code>MaxSize</code> 的余数等于队尾下标（除数大于被除数，余数为被除数本身）</p><p>正因为上述所说，平常所说的 <strong>顺序存储</strong> 实现均是以 <strong>指环形数组</strong> 的方式实现。</p><p>首先写出 <code>Queue.h</code> ，C语言代码如下：</p><p><strong>C语言代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by wenmang on 2019/8/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATA_STRUCTURE_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_STRUCTURE_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE_SIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> elementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    elementType* data;<span class="comment">// 队列数据存储位置</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">// data 数组大小</span></span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">// 队尾</span></span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">// 队首</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">queue</span> <span class="title">createQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(<span class="built_in">queue</span> q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="built_in">queue</span> q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="built_in">queue</span> q, elementType e)</span></span>;</span><br><span class="line"><span class="function">elementType <span class="title">deleteQueue</span><span class="params">(<span class="built_in">queue</span> q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//DATA_STRUCTURE_QUEUE_H</span></span></span><br></pre></td></tr></table></figure><p>紧接着，我们在 <code>Queue.c</code> 文件中实现头文件中所申明的函数：</p><p><strong>C语言代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by wenmang on 2019/8/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">queue</span> <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> q = (<span class="built_in">queue</span>) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">    q-&gt;size = <span class="number">8</span>;</span><br><span class="line">    q-&gt;data = (elementType*) <span class="built_in">malloc</span>(q-&gt;size * <span class="keyword">sizeof</span>(elementType));</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(<span class="built_in">queue</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;rear+<span class="number">1</span>) % q-&gt;size == q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="built_in">queue</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;rear == q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="built_in">queue</span> q, elementType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(q)) &#123;</span><br><span class="line">        q-&gt;size *= <span class="number">2</span>;</span><br><span class="line">        q-&gt;data = (elementType*) <span class="built_in">realloc</span>(q-&gt;data, q-&gt;size * <span class="keyword">sizeof</span>(elementType));</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear = (q-&gt;rear+<span class="number">1</span>) % q-&gt;size;</span><br><span class="line">    q-&gt;data[q-&gt;rear] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">elementType <span class="title">deleteQueue</span><span class="params">(<span class="built_in">queue</span> q)</span> </span>&#123;</span><br><span class="line">    assert(!isEmpty(q));</span><br><span class="line">    q-&gt;front = (q-&gt;front+<span class="number">1</span>) % q-&gt;size;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式储存实现">队列的链式储存实现</h3><p>也就是使用链表存储</p><p>首先可以写出头文件 <code>Queue.h</code> 的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by wenmang on 2019/8/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATA_STRUCTURE_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_STRUCTURE_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LQNode</span>* <span class="title">lQueue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    elementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LQNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">rear</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">front</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">lQueue <span class="title">createlQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addlQueue</span><span class="params">(lQueue q, elementType e)</span></span>;</span><br><span class="line"><span class="function">elementType <span class="title">deletelQueue</span><span class="params">(lQueue q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">islEmpty</span><span class="params">(lQueue q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//DATA_STRUCTURE_QUEUE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用链表储存，设计了两个结构，</p><p><code>Node</code> 为队列中节点，指针指向下一个节点，<code>data</code> 储存节点数据</p><p><code>QNode</code> 为队列头节点，两个指针分别指向队列头和队列尾</p><p>然后，在 <code>Queue.c</code> 文件中实现声明的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">lQueue <span class="title">createlQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lQueue q = (lQueue) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LQNode));</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addlQueue</span><span class="params">(lQueue q, elementType e)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">tmp</span> = (<span class="title">struct</span> <span class="title">Node</span>*) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">    tmp-&gt;data = e;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">        q-&gt;front = q-&gt;rear = tmp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q-&gt;rear = q-&gt;rear-&gt;next = tmp;</span><br><span class="line">    q-&gt;rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">elementType <span class="title">deletelQueue</span><span class="params">(lQueue q)</span> </span>&#123;</span><br><span class="line">    assert(!islEmpty(q));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">tmp</span> = <span class="title">q</span>-&gt;<span class="title">front</span>;</span></span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> tmp-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">islEmpty</span><span class="params">(lQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>链表储存无需判断是否队列已满</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;队列是具有一定操作约束的线性表，只能在一端（队尾）进行插入，另一端（队头）进行删除。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单地理解，按照字面意思，队列这种数据结构，就如同生活中排队的队列一般，后来的人（数据）只能跟在队尾，而队首的人（数据）首先接受服务（进行删除）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据插入：入队列 （&lt;code&gt;addQueue&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;数据删除：出队列 （&lt;code&gt;deleteQueue&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://wenmang.gitbub.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://wenmang.gitbub.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
