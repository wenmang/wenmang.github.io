<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>文的盲</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-10T13:19:45.766Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>文盲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分治</title>
    <link href="http://yoursite.com/2019/10/09/%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2019/10/09/分治/</id>
    <published>2019-10-09T10:35:45.000Z</published>
    <updated>2019-10-10T13:19:45.766Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>何为分治？简单来说，就是将大的问题分解成小问题进行求解，然后对每个小问题的解进行处理【一般是合并】为大问题的解，下面是分治较为官方的说明：</p><p><strong>分治：</strong> 把一个任务，分成形式和原任务相同，但规模更小的 几个部分任务（通常是两个部分），分别完成，或只需要选一部完成。然后再处理完成后的这一个或几个 部分的结果，实现整个任务的完成。</p><a id="more"></a><h3 id="斐波那契数列">斐波那契数列</h3><p>我想了很多，最后发现还是从这个例子开始说起更加便于理解。</p><p>斐波那契数列的定义很简单，其最早的历史来自于那个生兔子的问题。斐波那契数列的解法众多，详细描述可见<a href="https://zh.wikipedia.org/wiki/斐波那契数列" target="_blank" rel="noopener">维基百科</a>，而如果使用数学公式来描述，那么就是这个样子的： <span class="math display">\[\begin{equation}  \left\{      \begin{array}{**lr**}          F_0 = 0 &amp;  \\          F_1 = 1 &amp;  \\          F_n = F_{n-1} + F_{n-2} &amp; \\        \end{array}  \right.  \end{equation}  \]</span> 他这种递归的定义方式，其实以初等数学使用暴力求解的思路来说，刚好是符合我们的分治思想的。因为你若将求解 <span class="math inline">\(F_4\)</span> 看作一个大问题，就必须将其分解为两个小一点的子问题，即求解 <span class="math inline">\(F_3\)</span> 和 <span class="math inline">\(F_2\)</span> ，然后再计算二者之和。</p><p>那么根据这个递归式，我想只要有点语言基础，都能很快写出一段递归的代码进行求解：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> Fibonacci(n<span class="hljs-number">-1</span>) + Fibonacci(n<span class="hljs-number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>Fibonacci</code> 真正实现的时候不能这么写。</p><h3 id="分治范式">分治范式</h3><p>大致对分治这种思想有了一个整体认识之后，我们便可以总结出一个求解分治问题的范式：</p><p><strong>何时使用分治思想：</strong>问题规模太大或者其他原因导致难以直接求解，那么这时候便可以考虑将问题划分为子问题，通过求解子问题来实现原问题最终的求解。</p><p><strong>范式的一般步骤：</strong></p><ul><li><strong>划分：</strong>简单来说，此步骤就是将大问题分解为小问题【注：每个小问题的求解必须一致，不然分治就失去了其原本的意义】。</li><li><strong>治理：</strong><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>也就是对每一个子问题进行求解。</li><li><strong>组合：</strong>将所有子问题的结果进行合并，得到原问题的解。</li></ul><h4 id="分治的分析">分治的分析</h4><p>分治的性质决定了其与递归联系紧密，所以如果一个问题可以用分治的思想来解决，那么其必然可以转化为一个递归表达式，就如同最开始直接以递归定义的斐波那契数列的表达式一般。而此类问题时间复杂度的详细分析，也往往依靠求解这样的递归式来得到。</p><h3 id="归并排序">归并排序</h3><p>许多算法都是利用分治思想提出来的，而归并排序无疑是最具代表性的一个，我们可以根据分治范式来一步步分析求解，最终明确这个算法的原理。</p><h4 id="划分">划分</h4><ul><li>两个数之间如何排序【注：此后所说的排序均代表顺序排序】？很显然两两之间比较，小的放左边，大的放右边。</li><li>那三个数如何排序？选两个排好之后，再将第三个数与已经排好的两数比较，进而确定第三个数的位置。</li><li>四个？此时可以两两排好，然后再合并两个已排序的数组即可。</li><li>六十四个？可以分为俩三十二个的，每个三十二个的又可分为俩十六个的……</li></ul><p>如此，我们可以将大问题以对半划分的方式【注：奇数对半，一半比一半多1即可】层层划分，<strong>直至不可划分为止，也就是仅剩一个数的时候。</strong>而划分，也往往就是递归的过程。</p><h4 id="治理">治理</h4><p>治理，即解决划分后的子问题，划分后的子问题是什么呢？答案就是，一个数的排序。一个数显然无需排序，那么此步骤便无需进行处理。</p><h4 id="组合">组合</h4><p>将子问题的结果组合起来，在此问题中便是，<strong>将已排序的两个数组合并为一个已排序的数组。</strong></p><h4 id="具体实现">具体实现</h4><p>分析清楚之后便可自己尝试写出代码了，首先要写的，便是 <strong>组合</strong> 部分，C语言代码如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">- 将数组a的局部a[l,r-1]和a[r,rightEnd]合并到tmp</span></span><br><span class="line"><span class="hljs-comment">    - 然后再拷贝回a[l,rightEnd]</span></span><br><span class="line"><span class="hljs-comment">**/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rightEnd, <span class="hljs-keyword">int</span> tmp[])</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> leftEnd = r - <span class="hljs-number">1</span>; </span><br><span class="line"><span class="hljs-keyword">int</span> left = l, count = l;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> (l &lt;= leftEnd &amp;&amp; r &lt;= rightEnd) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (a[l] &lt; a[r])</span><br><span class="line">tmp[count++] = a[l++];</span><br><span class="line"><span class="hljs-keyword">else</span> </span><br><span class="line">tmp[count++] = a[r++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> (l &lt;= leftEnd)</span><br><span class="line">tmp[count++] = a[l++];</span><br><span class="line"><span class="hljs-keyword">while</span> (r &lt;= rightEnd)</span><br><span class="line">tmp[count++] = a[r++];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt; rightEnd+<span class="hljs-number">1</span>; i++) </span><br><span class="line">a[i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以完成划分部分，从而进行排序了。C语言代码如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> rightEnd, <span class="hljs-keyword">int</span> tmp[])</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (left &lt; rightEnd) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> mid = left + (rightEnd-left)/<span class="hljs-number">2</span>;</span><br><span class="line">mergeSort(a, left, mid, tmp);<span class="hljs-comment">// 划分左半部分</span></span><br><span class="line">mergeSort(a, mid+<span class="hljs-number">1</span>, rightEnd, tmp);<span class="hljs-comment">// 划分右半部分</span></span><br><span class="line">merge(a, left, mid+<span class="hljs-number">1</span>, rightEnd, tmp);<span class="hljs-comment">// 组合子问题的解</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="汉诺塔问题">汉诺塔问题</h4><p>作为练习，可尝试自己实现一下汉诺塔问题！【待补】</p><section class="footnotes"><hr><ol><li id="fn1"><p>此处按照教科书上（算法技巧与分析【沙特】）来说，此步骤实质上是一种优化复杂度的步骤，但在此，为了简便起见，直接将其写为了子问题的求解。<a href="#fnref1" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;何为分治？简单来说，就是将大的问题分解成小问题进行求解，然后对每个小问题的解进行处理【一般是合并】为大问题的解，下面是分治较为官方的说明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分治：&lt;/strong&gt; 把一个任务，分成形式和原任务相同，但规模更小的 几个部分任务（通常是两个部分），分别完成，或只需要选一部完成。然后再处理完成后的这一个或几个 部分的结果，实现整个任务的完成。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="算法思想" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>C的编译与链接</title>
    <link href="http://yoursite.com/2019/10/04/C%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2019/10/04/C的编译与链接/</id>
    <published>2019-10-04T13:43:29.000Z</published>
    <updated>2019-10-05T05:58:34.042Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>曾经在初读 <code>CSAPP</code> 之时，我初步了解了 C 语言的全部<a href="%5Bhttps://github.com/wenmang/hello-world/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/SectionI/note/C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C.md%5D(https://github.com/wenmang/hello-world/blob/master/深入理解计算机系统（第二版）/SectionI/note/C语言代码的编译和执行.md)">编译</a>过程，即大概可分为以下三大步：</p><ul><li>预处理</li><li>编译</li><li>链接</li></ul><p>今天，又看了节公开课，对这部分有了相对较为深入的理解，并且知道了一些有意思的事情。</p><a id="more"></a><p>开始之前，我们应该有这样一个概念：在使用 <code>gcc</code> 编译器进行编译之时，以上三步在某种意义上来说是相互分离的。</p><h3 id="预处理阶段">预处理阶段</h3><p>对于此阶段，我之前所理解的全部，便是曾经所做的笔记：</p><blockquote><p>通过预处理器( <code>cpp</code> ) 处理之后，将其变成了 <code>.i</code> 文件，<code>.i</code> 文件实际上对你写的 <code>.c</code> 文件里以井号 <code>#</code> 开头的语句进行了处理，其发现你引入了某个头文件，于是预处理器便将头文件的内容插入到了你的代码之中。</p></blockquote><p>而如今，我想可以进一步扩展（或许不准确），预处理阶段所处理的内容，实质上就是对 C语言中的宏进行处理，而其中需要处理的部分，即通过宏语法限定的，在程序中<strong>有效的宏语言</strong><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。其中主要有两大类：</p><ul><li><code>#define</code> ：对以 <code>#define</code> 打头的宏定义部分进行替换。</li><li><code>#include</code>：对以 <code>#include</code> 格式引入的库文件进行添加。</li></ul><h4 id="define"><code>#define</code></h4><p>最为常见的宏定义，新手常常使用其表示变量，老手便会使用宏来表示一些简单的函数等等：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.14159<span class="hljs-comment">// 新手</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(a,b) ((a)&gt;(b))?(a):(b)<span class="hljs-comment">// 老手</span></span></span><br></pre></td></tr></table></figure><p>一般来说，既然已经有了函数，但是还是有许多人使用宏来替代函数，那么必有原因，一般来说，宏的优点主要有以下几点：</p><ul><li>同函数一般，简单可复用！同时能够使代码含义更加清晰。</li><li>与函数相比，其直接在预处理阶段进行替换，所以其省去了函数调用的时间，所以，我觉得宏适合在下列情境下使用：<ul><li>函数功能较为简单，只有一行代码，函数调用所花时间对函数功能影响较大</li><li>函数需要多次重复使用（不适合有递归的情况）</li></ul></li></ul><h4 id="include"><code>#include</code></h4><p>只要学过C语言，想必就不会对此陌生，人生中第一个 <code>hello world</code> 就使用了这个语句，也就是所谓的头文件，头文件的格式有以下两种：</p><ul><li><code>#include&lt;&gt;</code> ：以 <code>&lt;&gt;</code> 引用的一般是系统自带的库文件</li><li><code>#include&quot;&quot;</code> ：以 <code>&quot;&quot;</code> 引用的一般是自己写的头文件</li></ul><p>此部分无需多叙。</p><h3 id="编译阶段">编译阶段</h3><p>所谓编译，就是将C语言文件编译为汇编文件，以方便计算机执行，而此阶段所做工作的<strong>目的是：</strong> 将C语言进行初步编译，并对程序进行语法上的一次检查，对不符合语法规则的，进行报错，也就是 <code>Error</code> ，并会停止程序的编译 ；对有争议，或是不明确的内容提出警告 <code>Warning</code> ，但是并不会停止编译，最终还是会生成可执行文件 。</p><p>既然如此，那么有这样一个有趣的问题：<strong>如果，我们在写代码的时候，不加上头文件，那么该代码是否能通过编译呢？</strong></p><h4 id="示例">示例</h4><p>有这样一段毫无意义的代码，其目的仅是为了说明上述问题：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;// printf</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;// malloc, free</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;// assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">void</span>* mom = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);</span><br><span class="line">    assert(mom != <span class="hljs-literal">NULL</span>);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"yeah!\n"</span>);</span><br><span class="line">    <span class="hljs-built_in">free</span>(mom);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先将 <code>#include&lt;stdio.h&gt;</code> 注释掉，那么此时，编译到 <code>printf</code> 语句的时候，编译器由于找不到 <code>printf</code> 的声明，于是会提出警告，并将 <code>printf</code> 以默认的方式进行编译——将之认为是一个函数（参数为字符串，返回值为 <code>int</code> ）。</p><p>所以在编译阶段，此代码即使去掉了 <code>#include&lt;stdio.h&gt;</code> 头文件，也依旧能够编译成功</p><h3 id="链接阶段">链接阶段</h3><p>链接阶段看似是根据编译的结果进行的，但是却不尽然，因为链接阶段是相对独立的，在链接阶段，编译器会根据编译之后的结果，在库中去依次寻找对应的函数。</p><p>所以，上述代码，在编译成功之后，进行链接之时，依旧能够从库中寻找到 <code>printf</code> 函数，并执行成功。也就是说，上述代码，去掉了 <code>#include&lt;stdio.h&gt;</code> 头文件，使用 <code>gcc</code> 编译，<strong>能够成功地编译并产生可执行文件</strong>，唯一的影响仅是：在编译过程中会产生一条警告信息。我自己实验的结果也同理论相同，结果如下图：</p><figure><img src="https://i.loli.net/2019/10/05/JxjXuLgcdNYWkKr.png" alt="C的编译与链接1.png"><figcaption>C的编译与链接1.png</figcaption></figure><p>可以看到，仅产生了一个 <code>warning</code>，并且能够执行成功。</p><h4 id="普适与特例">普适与特例</h4><p>同样地，在去掉 <code>#include&lt;stdlib.h&gt;</code> 之后，也如是。但是，正如上面所说，链接阶段会重新在库函数中寻找函数原型，那么<strong>对于所有的库函数，都能够如此吗？</strong> 答案当然是<strong>否定的！</strong></p><p><code>#include&lt;assert.h&gt;</code> 头文件之中，<code>assert()</code> 的实现，实质上并不是一个函数，<strong>而是一个宏定义</strong>，所以如果去掉此头文件，在编译阶段便会将 <code>assert()</code> 解释为一个函数。但是显然，<strong>其并非一个函数，那么链接之时便不可能找得到了</strong>，所以如此便会出错！验证结果如下：</p><figure><img src="https://i.loli.net/2019/10/05/EuZRKoiCy4w7PlB.png" alt="C的编译与链接2.png"><figcaption>C的编译与链接2.png</figcaption></figure><h4 id="意义">意义</h4><p>乍一看，这种写法好像没什么意义，但是，如果需要追求极度的精简，减小文件体积，这样的写法还是有意义的。事实上，我觉得这种写法，其实是远古时期，内存极度短缺时候的小技巧【实际测试中，其最后产生的可执行文件大小是一样的】。</p><p>至于为何会影响文件大小？<strong>因为加上头文件之后，在预处理阶段就会将头文件中的所有内容加到你的程序当中</strong>，而尽管你只使用了该头文件中的几个函数。而以现在大内存当道的现状，估计很少会有人这么写了。</p><p>所以，此技巧更多地还是体现了<strong>C语言的 ”自由“</strong>，并且还是蛮有趣的。</p><h3 id="深入">深入</h3><p>既然不加头文件，编译器会将其理解为一个函数，那么我们就会想到：我直接在自己的代码中以函数的方式进行声明，那么是不是就不会产生警告了？<strong>答案是可行的！</strong><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>验证如下：</p><p>代码改为：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;// malloc, free</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;// assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">void</span>* mom = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);</span><br><span class="line">    assert(mom != <span class="hljs-literal">NULL</span>);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"yeah!\n"</span>);</span><br><span class="line">    <span class="hljs-built_in">free</span>(mom);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure><img src="https://i.loli.net/2019/10/05/C5yD3Hw78dvmMUo.png" alt="C的编译与链接3.png"><figcaption>C的编译与链接3.png</figcaption></figure><h3 id="拓展">拓展</h3><p>有个很有趣的事情，如果不加库，并且利用一个库函数中已有的函数，但是将其参数进行改变（传参数目变多或变少），那么此时程序又会如何被编译，或是产生何种后果？</p><p>比如下面一段代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> num = <span class="hljs-number">65</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> length = <span class="hljs-built_in">strlen</span>((<span class="hljs-keyword">char</span>*)&amp;num, num);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"length = %d\n"</span>, length);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>话不多说，首先来看编译结果：</p><figure><img src="https://i.loli.net/2019/10/05/MUlkeT5Os2fPWQC.png" alt="C的编译和链接4.png"><figcaption>C的编译和链接4.png</figcaption></figure><p>哈哈哈哈哈，报错了，本来还想着正确之后讲述一番教授的思路呢！看来时代变了啊，编译器是变得安全了不少！那这部分也只能提前结束了。</p><section class="footnotes"><hr><ol><li id="fn1"><p>为何说是有效，因为宏拥有一套自己简单的语法，可以控制某段宏是否进行处理，处理几次等操作，所以在此使用了有效的宏语言一词<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p>可以看到，最终编译结果和公开课教授所讲的还是有出入，可能是编译器进化了的缘故吧！毕竟是<code>10</code> 年的公开课<a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾经在初读 &lt;code&gt;CSAPP&lt;/code&gt; 之时，我初步了解了 C 语言的全部&lt;a href=&quot;%5Bhttps://github.com/wenmang/hello-world/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/SectionI/note/C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C.md%5D(https://github.com/wenmang/hello-world/blob/master/深入理解计算机系统（第二版）/SectionI/note/C语言代码的编译和执行.md)&quot;&gt;编译&lt;/a&gt;过程，即大概可分为以下三大步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理&lt;/li&gt;
&lt;li&gt;编译&lt;/li&gt;
&lt;li&gt;链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天，又看了节公开课，对这部分有了相对较为深入的理解，并且知道了一些有意思的事情。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="底层" scheme="http://yoursite.com/tags/%E5%BA%95%E5%B1%82/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="有趣" scheme="http://yoursite.com/tags/%E6%9C%89%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>C函数执行</title>
    <link href="http://yoursite.com/2019/10/04/C%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/"/>
    <id>http://yoursite.com/2019/10/04/C函数执行/</id>
    <published>2019-10-04T04:44:31.000Z</published>
    <updated>2019-10-28T06:25:59.700Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>此篇博文根据斯坦福公开课 《编程范式》整理，来阐述C语言函数执行时，在内存中的简单过程，也算是一个简单的笔记。</p><a id="more"></a><h3 id="函数的活动记录">函数的活动记录</h3><p>所谓活动记录，便是C语言程序在调用过程中的储存分配方案的记录。即：当一个过程被调用时，就把它的活动记录推入运行时存储栈的栈顶，而在控制返回调用程序时，再从栈顶弹出相应的活动记录。如此反复，以执行整个程序。</p><p>我们首先将内存抽象为一个索引从 0 开始的庞大数组，然后为了方便说明函数的具体执行过程，我们以一段简单的代码作为说明：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> c[<span class="hljs-number">4</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们写下这样一个函数的时候，在编译过程中，在内存中会如下图这样分配空间：</p><figure><img src="https://i.loli.net/2019/10/04/b5tiMoPpc6n9JG7.png" alt="C函数活动记录1.png"><figcaption>C函数活动记录1.png</figcaption></figure><p>在该函数编译之时，以 <code>Save PC</code> 为分界线，内存上半部分依次为形参空间，下半部分为函数中所申明的变量的空间。</p><p><strong>注：<code>save PC</code> 我其实并没有搞得很懂，但是按照老师的说法，应当可以理解为函数本身的地址（此处存疑）</strong></p><h3 id="函数的执行">函数的执行</h3><p>为了较为顺畅地理解，我们依旧以示例代码来说明：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> foo(a<span class="hljs-number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>;</span><br><span class="line">    foo(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，编译之时，会像上边一般，在内存中以相同的方式分配空间，然后，函数开始执行：</p><p>执行过程会在内存的栈区进行，在调用 <code>foo</code> 函数之后，<code>PC</code> 会直接跳转到 <code>foo</code> 函数所在的内存空间之处，也就是 <code>Save PC</code> 所在，如下图所示：</p><figure><img src="https://i.loli.net/2019/10/04/Vh3pWATvqNbDyF4.png" alt="C函数活动记录2.png"><figcaption>C函数活动记录2.png</figcaption></figure><p>由于 <code>foo</code> 函数的形参刚好在其上，所以，参数传递就如此完成了。此后，便会执行 <code>foo</code> 函数中的语句。</p><h3 id="有趣的例子">有趣的例子</h3><p>利用上述原理，有这样一个有趣的例子：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createArray</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">100</span>];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) </span><br><span class="line"><span class="hljs-built_in">array</span>[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">100</span>];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, <span class="hljs-built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">createArray();</span><br><span class="line"><span class="hljs-comment">// printf("Hello");</span></span><br><span class="line">printArray();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到代码，你会有点懵，这不就是打印 <code>0-99</code> 吗？<strong>这代码有什么特别呢</strong>？然而，你再看看，便会发现两个 <code>array</code> 数组是在两个函数中，这时候你可能会记起当年学的C语言，<strong>不同函数中的声明是相互独立的啊</strong>？这样写不是脱裤子放屁吗？你就会心有疑虑，对这样是否能够实现相关功能而存疑。</p><p>然而，通过上述原理我们知道，函数调用结束之后，只是指针在内存中的跳转，而内容并不会被擦去，所以答案是肯定的，运行代码，会正常输出 <code>0 1 2 3 ...99</code> 。</p><p>那么如果在两次调用中加上一句呢？也就是将上面代码的的注释去掉。然后在运行你便会发现不成了，这是因为<strong>两次调用中间如果加入了其余语句，便会扰乱前一个函数所初始化的内存，从而使得第二个函数不能正常打印</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇博文根据斯坦福公开课 《编程范式》整理，来阐述C语言函数执行时，在内存中的简单过程，也算是一个简单的笔记。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="底层" scheme="http://yoursite.com/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Fisher线性判别</title>
    <link href="http://yoursite.com/2019/09/28/Fisher%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB/"/>
    <id>http://yoursite.com/2019/09/28/Fisher线性判别/</id>
    <published>2019-09-28T05:53:59.000Z</published>
    <updated>2019-09-28T14:26:58.625Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="分类问题">分类问题</h3><p>现实世界中，我们常常需要对事物进行分类，而分类的所依据的标准往往是多样的，这尤其体现在使用电脑解决分类问题之时。</p><p>我们如果要使用电脑进行分类，首先需要的便是数据。比如：我们需要将两个不同品种的鱼进行分类，我们首先需要根据找不同的方式找出两种鱼在某些特征上的不一致之处（如：长度，宽度，鱼鳍数目、长度等等）。我们将找出来的这些特征构建为一个行向量，同时对每一类都选许多条鱼进行测量，每一条鱼都能得到这样个行向量，将所有行向量拼接起来，构成一个<span class="math inline">\(N\times M\)</span> 的矩阵（<span class="math inline">\(N\)</span> 为鱼的数目，<span class="math inline">\(M\)</span> 为依据的特征数目），这样就构成了一个简单的有标签的数据集。</p><a id="more"></a><p>有了数据集，接下来所要做的便是分类。什么是分类呢？现实生活中此概念很简单，比如我们买鱼时便有许多选择：鲤鱼，草鱼，带鱼等等等等，而用以区分这些鱼类的，大都是凭经验根据某些特征来区分。其实电脑也一样，分类要做的，就是将两类数据通过一个分类面区分开来，如下粗糙的图所示，分类所做的就是根据已有的数据，找出中间那条红线，将二者分开。</p><p><img src="https://i.loli.net/2019/09/28/ko2z9ISYOnjx3ma.png" alt="Fisher1.png" style="zoom:60%;"></p><p>而所谓分类的方法，其归根到底就是利用各种方法，来找到这样一个最佳分类面。而这篇博客所介绍的，仅是所有方法中非常简单的一种——Fisher线性判别。</p><h3 id="fisher线性判别">Fisher线性判别</h3><p><code>Fisher</code> 线性判别 是一种<strong>简单的二分类</strong>方法，其主要思路就是将高维空间的数据进行降维投影至一维空间，从而降低分类的难度。其一般步骤如下：</p><ul><li>将高维数据投影到一维平面上</li><li>通过运算使得每一类之间更加紧凑（使同一类数据之间的距离变小），两类之间的距离尽可能远，从而方便将两类数据分开。</li><li>一般以两类数据中心点的中点最为分类面。</li></ul><h4 id="数学原理">数学原理</h4><p>显然，Fisher线性判别的重难点在于前两步，即如何找到一个投影面，使得类内距离尽可能小而类间距离尽可能大。</p><h5 id="基础概念">基础概念：</h5><p><strong>在 <code>d</code> 维的 <code>X</code> 空间中（样本空间）：</strong></p><ul><li><p><strong>各类样本的均值向量</strong><span class="math inline">\(m_i\)</span> ：<span class="math inline">\(m_i = \frac{1}{n_i}\sum_\limits{X\in D_i}{X},\ i=1,2\)</span></p></li><li><p><strong>样本类内离散矩阵</strong><span class="math inline">\(S_i\)</span>和<strong>总样本类内离散度矩阵</strong><span class="math inline">\(S_w\)</span> （其实可以看出来，所谓类内离散度矩阵便是<strong>每一个样本与样本均值向量之间的欧氏距离</strong>所构成的矩阵） <span class="math display">\[\begin{align*}  &amp; S_i = \sum_{X\in D_i}(x-m_i)(x-m_i)^T,\ i = 1, 2\\  &amp;S_w = S_1+S_2\\\end{align*}\]</span></p></li><li><p><strong>样本类间离散度矩阵</strong> $ S_b $ （即两类样本均值之间的欧氏距离） <span class="math display">\[S_b = (m_1-m_2)(m_1-m_2)^T\]</span></p></li></ul><p><strong>在 <code>1</code> 维的 <code>Y</code> 空间中（投影空间）：</strong></p><ul><li><p><strong>各类样本的均值</strong> <span class="math inline">\(\tilde{m_i}\)</span> ：<span class="math inline">\(\tilde{m_i} = \frac{1}{n_i}\sum_\limits{y\in D_i}{y},\ i=1,2\)</span></p></li><li><p><strong>样本类内离散度</strong> <span class="math inline">\(\tilde{S_i}\)</span> 和<strong>总样本类内离散度</strong> <span class="math inline">\(\tilde{S_w}\)</span> <span class="math display">\[\begin{align*}  \tilde{S_i} &amp;= \sum_{y\in D_i}(y- \tilde{m_i})(y- \tilde{m_i})^T,\ i = 1, 2\\  &amp;=\sum_{y\in D_i}(y- \tilde{m_i})^2,\ i = 1, 2\\  \tilde{S_w} &amp;= \tilde{S_1}+ \tilde{S_2}\\\end{align*}\]</span></p></li><li><p><strong>样本类间离散度：</strong> <span class="math display">\[\begin{align*}  \tilde{S_b} &amp;= (\tilde{m_1}-\tilde{m_2})(\tilde{m_1}-\tilde{m_2})^T\\  &amp;=(\tilde{m_1} - \tilde{m_2})^2\end{align*}\]</span></p></li></ul><p>接下来要让投影后的类内距离尽可能小而类间距离尽可能大，也就是要使得 <span class="math inline">\(\tilde{S_w}\)</span> 尽可能小， <span class="math inline">\(\tilde{S_b}\)</span> 尽可能大，换言之也就是令 <span class="math inline">\(\frac{\tilde{S_b}}{\tilde{S_w}}\)</span> 尽可能取得最大值，我们令其比值为 <span class="math inline">\(J(w)\)</span>，如下式子： <span class="math display">\[\begin{align*}    J(w) &amp;= \frac{\tilde{S_b}}{\tilde{S_w}}= \frac{(\tilde{m_1} - \tilde{m_2})^2}{\tilde{S_1}+ \tilde{S_2}}\end{align*}\]</span> 又因为，由各类样本均值可推出： <span class="math display">\[\begin{align*}    \tilde{m_i} &amp;= \frac{1}{n_i}\sum_\limits{y\in D_i}{y}\\    &amp;= \frac{1}{n_i}\sum_\limits{X\in D_i}{w^Tx}\\    &amp;= {w^T}(\frac{1}{n_i}\sum_\limits{X\in D_i}{x})\\    &amp;= w^Tm_i\end{align*}\]</span></p><p>则，投影样本均值之差可以展开为： <span class="math display">\[\begin{align*}    (\tilde{m_1} - \tilde{m_2})^2 &amp;= (w^Tm_1 - w^Tm_2)^2\\    &amp;= w^T(m_1-m_2)(m_1-m_2)^Tw\\    &amp;= w^TS_bw\end{align*}\]</span> 同理，可将 <span class="math inline">\(\tilde{S_i}\)</span> 以相同的方式进行变化： <span class="math display">\[\begin{align*}    \tilde{S_i} &amp;= \sum_{y\in D_i}(y- \tilde{m_i})^2\\    &amp;= \sum_{X\in D_i}{(w^Tx-w^Tm_i)^2}\\    &amp;= \sum_{X\in D_i}{w^T(x-m_2)(x-m_2)^Tw}\\    &amp;= w^TS_iw\end{align*}\]</span> 则 <span class="math inline">\(J(w)\)</span> 可化为： <span class="math display">\[\begin{align*}    J(w) &amp;= \frac{(\tilde{m_1} - \tilde{m_2})^2}{\tilde{S_1}+ \tilde{S_2}}\\    &amp;= \frac{w^TS_bw}{w^TS_ww}\end{align*}\]</span> 之后令分母为非零常数，然后采用<strong>拉格朗日乘子法</strong>确定最佳变换向量，定义拉格朗日函数如下： <span class="math display">\[\begin{align*}    L(w, \lambda) = w^TS_bw-\lambda (w^TS_ww-c)\end{align*}\]</span> 求解过程如下： <span class="math display">\[\begin{align*}    &amp;\frac{\partial L(w,\lambda)}{\partial w} = 2S_bw-2\lambda S_ww =0\\    \\    即：\qquad &amp;S_bw^* = \lambda S_ww^* \qquad S^{-1}_wS_bw^* = \lambda w^*\\    \\\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}    w^* &amp;= \frac{1}{\lambda}S^{-1}_wS_bw^*\\    &amp;= \frac{1}{\lambda}S^{-1}(m_1-m_2)(m_1-m_2)^Tw^*\\    &amp;= \frac{R}{\lambda}S^{-1}(m_1-m_2)\end{align*}\]</span></p><p>省去常数，则最后可得 <span class="math inline">\(w^* = S^{-1}(m_1-m_2)\)</span></p><p>数据便可通过向量 <span class="math inline">\(w^*\)</span> 投影至一维平面上，变成一个个点，而要将两类分开，便直接可以找出阈值点 <span class="math inline">\(w_0\)</span> ，将之分开。常用确定方法如下： <span class="math display">\[\begin{align*}    &amp;w^0 = \frac{\tilde{m_1} - \tilde{m_2}}{2}\\    &amp;w_0 = \frac{n_1\tilde{m_1} + n_2\tilde{m_2}}{n_1+n_2} = \tilde{m}\\    &amp;w^0 = \frac{\tilde{m_1} - \tilde{m_2}}{2}+\frac{ln[P(w_1)/P(w_2)]}{n_1+n_2-2}\end{align*}\]</span></p><h4 id="实例验证">实例验证</h4><p><strong>要求：</strong>在 <code>UCI</code> 数据集上的 <code>Iris</code>和 <code>sonar</code> 数据上验证算法的有效性。【<code>Iris</code> 数据3类，4维，150个数据；<code>Sonar</code> 数据2类，60维，208个样本】</p><p><strong>说明：</strong>训练和测试样本有三种方式进行划分：（三选一）</p><ol type="1"><li>将数据随机分训练和测试，多次平均求结果</li><li>k折交叉验证</li><li>留1法</li></ol><h5 id="下载数据集">下载数据集</h5><p>到 <a href="https://archive.ics.uci.edu/ml/index.php" target="_blank" rel="noopener"><code>UCI</code></a> 官网上即可直接下载两个数据集</p><h5 id="零碎说明">零碎说明</h5><ul><li>我选择的是第一种划分方式</li><li>为了简便，我使用了 <code>MATLAB</code> 进行编程</li></ul><h5 id="开始验证">开始验证</h5><ul><li><p>首先将<strong>数据读入，并划分矩阵</strong>，此为基础问题，不再赘述</p></li><li><p>然后，<strong>利用 <code>mean()</code> 函数 求每一类样本的均值向量</strong></p></li><li><p>根据公式，求取训练数据的类内散度矩阵 <span class="math inline">\(S_i\)</span> 和 <span class="math inline">\(S_w\)</span> ，代码实现函数如下：</p><figure class="highlight matlab hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[s]</span> = <span class="hljs-title">getScatter</span><span class="hljs-params">(sample, size, m, n1, n2)</span></span></span><br><span class="line"><span class="hljs-comment">% getScatter</span></span><br><span class="line">    <span class="hljs-comment">%   计算数据的类内离散度矩阵</span></span><br><span class="line">    s = &#123;<span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>), <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>), <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>)&#125;;</span><br><span class="line">    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:n1</span><br><span class="line">        tmp = sample&#123;<span class="hljs-built_in">i</span>:<span class="hljs-built_in">i</span>&#125;;</span><br><span class="line">        mi = m&#123;<span class="hljs-built_in">i</span>:<span class="hljs-built_in">i</span>&#125;;</span><br><span class="line">        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:n2</span><br><span class="line">            xj = tmp(<span class="hljs-built_in">j</span>:<span class="hljs-built_in">j</span>, :);</span><br><span class="line">            A = (xj-mi);</span><br><span class="line">            si = A' * A;</span><br><span class="line">            s&#123;<span class="hljs-built_in">i</span>:<span class="hljs-built_in">i</span>&#125; = s&#123;<span class="hljs-built_in">i</span>:<span class="hljs-built_in">i</span>&#125; + si;</span><br><span class="line">        <span class="hljs-keyword">end</span></span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line"><span class="hljs-keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>根据公式，求取最佳变换向量 <span class="math inline">\(w^*\)</span> 和阈值 <span class="math inline">\(w_0\)</span> ，代码实现函数如下：</p><figure class="highlight matlab hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[w, w0]</span> = <span class="hljs-title">bestVector</span><span class="hljs-params">(s1, s2, m1, m2)</span></span></span><br><span class="line">    <span class="hljs-comment">% bestVector </span></span><br><span class="line">    <span class="hljs-comment">%   求取最佳变换向量</span></span><br><span class="line">    sw = s1 + s2;</span><br><span class="line">    w = sw \ ((m1 - m2)');</span><br><span class="line">    w0 = (w'*m1' + w'*m2') / <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>将样本矩阵在投影方向上投影，以方便进行检验和画图，代码实现如下：</p><figure class="highlight matlab hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[D]</span> = <span class="hljs-title">rearProjection</span><span class="hljs-params">(sample, size, i1, i2, w1, n)</span></span></span><br><span class="line">    <span class="hljs-comment">% rearProjection</span></span><br><span class="line">    <span class="hljs-comment">%   计算投影后的点</span></span><br><span class="line">    D = &#123;<span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>, <span class="hljs-number">1</span>)&#125;;</span><br><span class="line">    k = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = [i1 i2]</span><br><span class="line">        tmp = sample&#123;<span class="hljs-built_in">i</span>:<span class="hljs-built_in">i</span>&#125;;</span><br><span class="line">        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:n(k)</span><br><span class="line">            xj = tmp(<span class="hljs-built_in">j</span>:<span class="hljs-built_in">j</span>, :);</span><br><span class="line">            Di = w1' * xj';</span><br><span class="line">            D&#123;k:k&#125;(<span class="hljs-built_in">j</span>,<span class="hljs-number">1</span>) = Di;</span><br><span class="line">        <span class="hljs-keyword">end</span></span><br><span class="line">        k = k+<span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line"><span class="hljs-keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>进行检验，我写了两个函数，分别检验两类分的是否正确，代码实现如下：</p><figure class="highlight matlab hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[rate]</span> = <span class="hljs-title">testLeft</span><span class="hljs-params">(class, i, n, w1, w0)</span></span></span><br><span class="line">    <span class="hljs-comment">% test</span></span><br><span class="line">    <span class="hljs-comment">%   检验剩余测试用例</span></span><br><span class="line">    count = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-built_in">i</span>:n</span><br><span class="line">        xj = class(<span class="hljs-built_in">j</span>:<span class="hljs-built_in">j</span>, :);</span><br><span class="line">        Di = w1' * xj';</span><br><span class="line">        <span class="hljs-keyword">if</span> Di &lt; w0</span><br><span class="line">            count = count + <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">end</span></span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line">    rate = (count*<span class="hljs-number">100</span>)/(n+<span class="hljs-number">1</span>-<span class="hljs-built_in">i</span>);</span><br><span class="line">    fprintf(<span class="hljs-string">"%d/%d = %.2f%%\n"</span>, count, (n-<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>), rate);</span><br><span class="line"><span class="hljs-keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[rate]</span> = <span class="hljs-title">testRight</span><span class="hljs-params">(class, i, n, w1, w0)</span></span></span><br><span class="line">    <span class="hljs-comment">% test</span></span><br><span class="line">    <span class="hljs-comment">%   检验剩余测试用例</span></span><br><span class="line">    count = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-built_in">i</span>:n</span><br><span class="line">        xj = class(<span class="hljs-built_in">j</span>:<span class="hljs-built_in">j</span>, :);</span><br><span class="line">        Di = w1' * xj';</span><br><span class="line">        <span class="hljs-keyword">if</span> Di &gt; w0</span><br><span class="line">            count = count + <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">end</span></span><br><span class="line">    <span class="hljs-keyword">end</span></span><br><span class="line">    rate = (count*<span class="hljs-number">100</span>)/(n+<span class="hljs-number">1</span>-<span class="hljs-built_in">i</span>);</span><br><span class="line">    fprintf(<span class="hljs-string">"%d/%d = %.2f%%\n"</span>, count, (n-<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>), rate);</span><br><span class="line"><span class="hljs-keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>将投影后的数据画出散点图，画图函数如下：</p><figure class="highlight matlab hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[]</span> = <span class="hljs-title">drawPicture</span><span class="hljs-params">(x1, x2, n, w0)</span></span></span><br><span class="line">    <span class="hljs-comment">% drawPicture</span></span><br><span class="line">    <span class="hljs-comment">%   画图函数，分类点为五角星</span></span><br><span class="line">    <span class="hljs-built_in">figure</span></span><br><span class="line">    <span class="hljs-built_in">scatter</span>(x1, <span class="hljs-built_in">zeros</span>(n(<span class="hljs-number">1</span>), <span class="hljs-number">1</span>), <span class="hljs-string">'o'</span>);</span><br><span class="line">    <span class="hljs-built_in">hold</span> on</span><br><span class="line">    <span class="hljs-built_in">scatter</span>(x2, <span class="hljs-built_in">zeros</span>(n(<span class="hljs-number">2</span>), <span class="hljs-number">1</span>), <span class="hljs-string">'x'</span>);</span><br><span class="line">    <span class="hljs-built_in">hold</span> on</span><br><span class="line">    <span class="hljs-built_in">scatter</span>(w0, <span class="hljs-number">0</span>, <span class="hljs-number">400</span>, <span class="hljs-string">'p'</span>);</span><br><span class="line"><span class="hljs-keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="结果展示">结果展示</h5><p>由于 <code>Fisher</code> 仅用于处理二分类问题，但是，<code>Iris</code> 数据集有三类，所以我仅在两两之间进行了分类。执行完毕后画出的三张散点图如下：</p><figure><img src="https://i.loli.net/2019/09/28/uOcRG5ZjfFboWBx.png" alt="Iris1-2.png"><figcaption>Iris1-2.png</figcaption></figure><figure><img src="https://i.loli.net/2019/09/28/DHgfhqzY49r2VLt.png" alt="Iris1-3.png"><figcaption>Iris1-3.png</figcaption></figure><figure><img src="https://i.loli.net/2019/09/28/YqOwTsc1XZEdfzm.png" alt="Iris2-3.png"><figcaption>Iris2-3.png</figcaption></figure><p><code>Sonar</code> 数据集只有两类，分类后的图像如下：</p><figure><img src="https://i.loli.net/2019/09/28/Co9RzsWtPEgKXrS.png" alt="sonar.png"><figcaption>sonar.png</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分类问题&quot;&gt;分类问题&lt;/h3&gt;
&lt;p&gt;现实世界中，我们常常需要对事物进行分类，而分类的所依据的标准往往是多样的，这尤其体现在使用电脑解决分类问题之时。&lt;/p&gt;
&lt;p&gt;我们如果要使用电脑进行分类，首先需要的便是数据。比如：我们需要将两个不同品种的鱼进行分类，我们首先需要根据找不同的方式找出两种鱼在某些特征上的不一致之处（如：长度，宽度，鱼鳍数目、长度等等）。我们将找出来的这些特征构建为一个行向量，同时对每一类都选许多条鱼进行测量，每一条鱼都能得到这样个行向量，将所有行向量拼接起来，构成一个&lt;span class=&quot;math inline&quot;&gt;\(N\times M\)&lt;/span&gt; 的矩阵（&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 为鱼的数目，&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 为依据的特征数目），这样就构成了一个简单的有标签的数据集。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
      <category term="模式识别" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>粗谈堆栈</title>
    <link href="http://yoursite.com/2019/09/20/%E7%B2%97%E8%B0%88%E5%A0%86%E6%A0%88/"/>
    <id>http://yoursite.com/2019/09/20/粗谈堆栈/</id>
    <published>2019-09-20T06:10:05.000Z</published>
    <updated>2019-10-05T06:15:49.574Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>堆栈是一两种十分常用的数据结构，而在硬件中根据内存相关分区功能的不同，将和此两种数据结构功能相似的分区（不是物理意义上的分区）分别称之为堆区栈区，简称堆栈。</p><ul><li>所以要搞清楚不同之处（我刚学C语言的时候一直搞不清楚）：堆栈在数据结构（软件）中来说是两种数据结构的名称；而在计算机内存中又表示两个不同的分区的名称</li></ul><a id="more"></a><h4 id="堆heap">堆（Heap）</h4><p>堆区在内存中占了相当大的一部分，这部分主要是为了储存程序中动态分配的数据，就C语言而言， <code>malloc()</code> <code>realloc()</code> <code>calloc()</code> 申请而来的空间就全部是堆中的空间，而动态申请的空间均需要利用 <code>free()</code> 手动释放掉。</p><p>当我们书写语句，在堆中申请空间：<code>int* tmp = malloc(40 * sizeof(int))</code> ，可以计算出，我们申请的空间大小理论上应该为 <span class="math inline">\(40 \times 4 = 160\)</span> ，但是其在堆中实际申请的空间应该是<strong>大于理论值一到两个字节</strong>的，而申请完毕后传回的指针实际上也不是申请空间的首地址，而是类似一个如下图所示的结构：</p><figure><img src="https://i.loli.net/2019/10/05/vVO5rUkajoeM2AG.png" alt="粗谈堆栈1.png"><figcaption>粗谈堆栈1.png</figcaption></figure><p>申请的实际空间如最大的红色边界线所示，而理论空间则如阴影部分所示，申请的空间最前面的一到两个字节（视底层的具体代码决定）用来<strong>标识由此开始的xx字节内存已被占用</strong>，以及一些必要的信息，来方便其他操作（例如需要 <code>free()</code> 之时，只需要将此标记移除或者改动即可）。</p><p><strong>谈谈<code>realloc()</code>：</strong> <code>realloc()</code> 进行内存扩展有两种方式：</p><ul><li>可以向后延拓之时，直接在此空间之后连续追加至相应的字节数即可</li><li>无法延拓之时，寻找适合的位置，另辟空间，将原有的数据复制过去，返回新空间的指针</li></ul><p><strong>一个减小 <code>malloc()</code> 时间复杂度的方法：</strong> 将所有空闲的内存首地址之间利用链表连接起来，并注明此处闲余空间是多少，然后再次开辟之时，便可以直接跳转寻找合适的空间</p><h4 id="栈stack">栈（Stack）</h4><p>栈是在程序运行时创立的一块内存，用于存放自动开辟的空间（在C语言中而言也就是声明的变量），其一般来说是可拓展空间的，可随着程序的执行自动进行扩展（就如同之前实现的那个栈一般）。</p><p><strong>注意：</strong></p><ul><li><code>int* tmp = malloc(40 * sizeof(int))</code> 在堆中存储</li><li><code>int tmp[40]</code> 在栈中存储</li></ul><p>关于此块内存，也就是遵循着先进后出的原则，就是说：<strong>其是随着程序运行来对内存进行动态分配的</strong> ，非常好理解，在次不多赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆栈是一两种十分常用的数据结构，而在硬件中根据内存相关分区功能的不同，将和此两种数据结构功能相似的分区（不是物理意义上的分区）分别称之为堆区栈区，简称堆栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所以要搞清楚不同之处（我刚学C语言的时候一直搞不清楚）：堆栈在数据结构（软件）中来说是两种数据结构的名称；而在计算机内存中又表示两个不同的分区的名称&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="底层" scheme="http://yoursite.com/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>链表及其常用操作</title>
    <link href="http://yoursite.com/2019/09/11/%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/09/11/链表及其常用操作/</id>
    <published>2019-09-11T15:21:20.000Z</published>
    <updated>2019-09-14T13:50:47.175Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>链表是什么？学过数据结构的人都很清楚，链表就是一种最最最基本的数据结构，基本到什么程度呢？基本到数据结构课上所学的数据结构都可以用链表来实现。</p><p>正因为其基础，我们更要了解链表的基本操作。</p><a id="more"></a><h4 id="链表的构成及基本操作">链表的构成及基本操作</h4><p>首先了解链表（单向）的构成：链表由一个个统一的节点构成，节点一般由两个变量构成：</p><ul><li>一个值，可以为各种类型</li><li>一个指向下一个节点的“指针”</li></ul><p>链表的基本操作和多数数据结构相同，即插入，删除，查找等等。均很简单，也不再赘述，主要说说插入操作：</p><ul><li>从头插入：新建的节点插入到链表头部</li><li>从尾插入：新建的节点插入到链表尾部</li><li>从任意位置插入：字面意思。</li></ul><p>下面实现链表的构成及其基本操作（<code>LeetCode</code> 对应题目：<a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">707. 设计链表</a>）</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> val;</span><br><span class="line">Node next;</span><br><span class="line">Node(<span class="hljs-keyword">int</span> val)&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.val = val;</span><br><span class="line"><span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Node head,tail;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyLinkedList</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Node node = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-keyword">this</span>.head = node;</span><br><span class="line">        <span class="hljs-keyword">this</span>.tail = node;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size) </span><br><span class="line">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.size == <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">this</span>.head.val = val;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            Node tmp = <span class="hljs-keyword">new</span> Node(val);</span><br><span class="line">            tmp.next = head;</span><br><span class="line">            <span class="hljs-keyword">this</span>.head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.size == <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">this</span>.tail.val = val;</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            Node tmp = <span class="hljs-keyword">new</span> Node(val);</span><br><span class="line">            <span class="hljs-keyword">this</span>.tail.next = tmp;</span><br><span class="line">            <span class="hljs-keyword">this</span>.tail = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Add a node of value val before the index-th node in the linked list.</span></span><br><span class="line"><span class="hljs-comment">     * If index equals to the length of linked list, </span></span><br><span class="line"><span class="hljs-comment">     * the node will be appended to the end of linked list.</span></span><br><span class="line"><span class="hljs-comment">     * If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-keyword">this</span>.size) <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (index == <span class="hljs-keyword">this</span>.size) &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            Node node = <span class="hljs-keyword">new</span> Node(val);        </span><br><span class="line">            Node tmp = head;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = tmp.next;</span><br><span class="line">            tmp.next = node;</span><br><span class="line">            <span class="hljs-keyword">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size) <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.head.next;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            Node node = head;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="hljs-keyword">if</span> (index == <span class="hljs-keyword">this</span>.size-<span class="hljs-number">1</span>) &#123;</span><br><span class="line">                tail = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表的反转">链表的反转</h4><p>什么是反转，简单来说，就是将 <code>12345</code> 变为 <code>54321</code> ，这便是反转。就链表而言，反转操作一般要求原地操作，尽可能减少空间使用，并且不允许直接改变链表的值。</p><p>表面来看反转好像很简单，但是实质上真正写起来也不是那么简单。链表操作的重难点，就是要防止链表断链丢失，所以，为了实现反转操作，我们需要三个节点指针，其过程如下图所示：</p><figure><img src="https://i.loli.net/2019/09/14/NZxj5CKOygPqVMz.png" alt="链表反转1.png"><figcaption>链表反转1.png</figcaption></figure><p>反转的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">flipList</span><span class="hljs-params">(ListNode ptr, ListNode tail)</span> </span>&#123;</span><br><span class="line">ListNode newHead = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> (ptr != tail) &#123;</span><br><span class="line">ListNode next = ptr.next;</span><br><span class="line">ptr.next = newHead;</span><br><span class="line">newHead = ptr;</span><br><span class="line">ptr = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实质上就是将链表的箭头给翻转过来，而为了使链表不断链丢失，所以引入了三个指针。</p><p><code>LeetCode</code> 相关问题：</p><ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/" target="_blank" rel="noopener">206. 反转链表</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表II</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></li></ul><h4 id="链表排序">链表排序</h4><p>链表排序可以直接将数组排序的算法代入其中，选择，归并啥的，只需要注意指针的完整性即可，下面附上链表的归并排序的函数（即：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a>）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)  <span class="hljs-keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode quick, slow;</span><br><span class="line">        quick = head.next;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="hljs-keyword">while</span> (quick != <span class="hljs-keyword">null</span> &amp;&amp; quick.next != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            quick = quick.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode mid = slow.next;</span><br><span class="line">        slow.next = <span class="hljs-keyword">null</span>;</span><br><span class="line">        ListNode head1 = sortList(head);</span><br><span class="line">        ListNode head2 = sortList(mid);</span><br><span class="line">        </span><br><span class="line">        ListNode newHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);</span><br><span class="line">        ListNode ptr = newHead;</span><br><span class="line">        <span class="hljs-keyword">while</span> (head1 != <span class="hljs-keyword">null</span> &amp;&amp; head2 != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">                ptr.next = head1;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                ptr.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ptr.next = head1 == <span class="hljs-keyword">null</span> ? head2 : head1; </span><br><span class="line">        <span class="hljs-keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LeetCode</code> 其余相关问题：</p><ul><li><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></li><li><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">147. 对链表进行插入排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表是什么？学过数据结构的人都很清楚，链表就是一种最最最基本的数据结构，基本到什么程度呢？基本到数据结构课上所学的数据结构都可以用链表来实现。&lt;/p&gt;
&lt;p&gt;正因为其基础，我们更要了解链表的基本操作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法基础" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表之快慢指针</title>
    <link href="http://yoursite.com/2019/09/06/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2019/09/06/链表之快慢指针/</id>
    <published>2019-09-06T14:15:21.000Z</published>
    <updated>2019-09-07T08:53:51.899Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>链表是最为基本的数据结构之一，常与数组作比较。由于链表相较于数组更加优良的的增删性能，常利用于增删比较频繁场合，并且衍生出了许多特殊的链表结构——静态链表，循环链表，双向链表等等。</p><p>而链表操作具有较强的技巧性，双指针最为常见，而双指针中，又以快慢指针最为特殊。这篇文章将根据自己的理解，说明快慢指针的原理与常见应用。</p><a id="more"></a><h3 id="链表的中间结点"><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">链表的中间结点</a></h3><h4 id="题目说明">题目说明</h4><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><h4 id="题目解答">题目解答</h4><p>链表的中间结点是快慢指针最为基础的一个例子， <code>java</code> 代码如下</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="hljs-comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="hljs-comment"> *     int val;</span></span><br><span class="line"><span class="hljs-comment"> *     ListNode next;</span></span><br><span class="line"><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="hljs-comment"> * &#125;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理分析">原理分析：</h4><p>原理颇为简单，但很精妙：</p><ul><li>声明两个指针，一个将之称为快指针，一个将之称为慢指针【快指针步长（一次经过的结点）相较慢指针更大，固有其名】</li><li>此处的快指针步长为2（一次两个结点），慢指针步长为 1 。当快指针到达链表末尾的时候，慢指针刚好到链表中间，由是一次循环便可以解决问题。</li></ul><h4 id="快慢指针的一般形式">快慢指针的一般形式</h4><p>由上题可见，快慢指针实质上就是两个步长不同的指针，步长大的称之为快指针，小的称之为慢指针。而解决问题的原理，在于利用两个指针步长不同所产生的差异，来进行问题的求解。</p><h3 id="环形链表"><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a></h3><h4 id="题目描述">题目描述</h4><p>给定一个链表，判断链表中是否有环。环，即链表末尾并非指向 <code>null</code> ，而是指向链表中的任意一个结点。详情可点击超链接。</p><h4 id="题目解答-1">题目解答</h4><p>此题依旧可以利用快慢指针的思想来解答，<code>java</code>代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="hljs-comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="hljs-comment"> *     int val;</span></span><br><span class="line"><span class="hljs-comment"> *     ListNode next;</span></span><br><span class="line"><span class="hljs-comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="hljs-comment"> *         val = x;</span></span><br><span class="line"><span class="hljs-comment"> *         next = null;</span></span><br><span class="line"><span class="hljs-comment"> *     &#125;</span></span><br><span class="line"><span class="hljs-comment"> * &#125;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode quick = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">while</span>(quick != <span class="hljs-keyword">null</span> &amp;&amp; quick.next != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            quick = quick.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="hljs-keyword">if</span> (quick == slow)</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理分析-1">原理分析</h4><ul><li>同样是快慢指针，快指针步长为 2 ，慢指针步长为 1 。</li><li>如果两指针相遇，便说明链表中有环。</li></ul><p>那为快慢指针一定会相遇呢？我看了知乎的<a href="https://www.zhihu.com/question/23208893" target="_blank" rel="noopener">同名问题</a>，发现有好多都用了这样一个比喻：两个同学在操场跑步，一个快，一个慢，跑的快的同学总能追的上跑得慢的同学。乍一听，好像颇有道理，但是细思，这个比喻其实是相当不合理的，<strong>跑道可以看是连续的，但是环形链表不是，一个个结点不是，它是离散的。</strong></p><p>所以，这样的比喻并没有任何说服力，而如要真正说明，便需要严谨的<strong>数学证明</strong>，也即此问题目前最高赞回答：</p><ul><li>快指针与慢指针之间差一步：此时继续往后走，慢指针前进一步，快指针前进两步，两者相遇。</li><li>快指针与慢指针之间差两步：此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差一步，又变为第一种情况。</li><li>快指针与慢指针之间差N步：此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差N-1步。</li></ul><p>所以，根据上述并不严谨的数学归纳法，便可清晰的说明原因。</p><p>但是若再深究，<strong>步长必须一个为 1 ，一个为 2 吗？</strong> 那么为了说明这点，就需要一个较为普遍的证明：</p><ul><li>一有环链表如下图所示：</li></ul><figure><img src="https://i.loli.net/2019/09/07/8uzHLWtjrJEVblX.png" alt="指针之快慢指针2.png"><figcaption>指针之快慢指针2.png</figcaption></figure><p><strong>参数说明：</strong></p><ul><li><code>A B</code> 分别为链表的头结点，环的入口结点</li><li><p><code>L1</code> 为非环部分的链表长度</p></li><li><code>L2</code> 为慢指针在环入口结点时候与快指针间的距离</li><li>链表环的周长为 <code>C</code></li><li><span class="math inline">\(S_s\)</span> 和 <span class="math inline">\(S_f\)</span> 分别为快指针和慢指针所走的 “路径”（即经过的结点数）</li><li><span class="math inline">\(N_1\)</span> 为正整数</li><li><p><span class="math inline">\(N_2\)</span> 为一任意实数数</p></li></ul><p><strong>证明：</strong></p><ul><li><p>当慢指针到达环的入口结点（即B点）之时，二者所经过的 “路程” 如下：</p><p><span class="math inline">\(S_S = L1\)</span></p><p><span class="math inline">\(S_f = 2\times L1 = L1 + N_1C + L2\)</span></p><p>则：<span class="math inline">\(L1 = N_1C + L2\)</span></p></li><li><p>假设慢指针与快指针在慢指针走了 <code>i</code> 之后相遇（快指针为慢指针的 <span class="math inline">\(N_2\)</span> 倍），可得方程如下：</p><p><span class="math inline">\((S_s + i - L1)\ mod\ C =(S_f + N_2i -L1)\ mod\ C\)</span></p><p><strong>代入可得：</strong> <span class="math inline">\(i\ mod\ C =(N_1C + N_2i + L2)\ mod\ C\)</span></p><p><strong>移向化简：</strong> <span class="math inline">\([(N_2 - 1)i + L1]\ mod\ C = 0\)</span></p><p>又因为 <code>NC</code> 是 <code>C</code> 的整数倍，可约去，所以最终等式为：<span class="math inline">\([(N_2-1)i+L1]\ mod\ C = 0\)</span></p></li></ul><p>则说明，只要 <span class="math inline">\((N_2-1)i+L1\)</span> 是 <span class="math inline">\(C\)</span> 的整数倍，那么快慢指针一定能够相遇</p><p><span class="math inline">\(N_2\)</span> 应该如何取值呢？</p><ul><li>显然，如果 <span class="math inline">\(N_2 = 1\)</span> （即两指针步长相同），那么等式就只有在 <span class="math inline">\(L1\)</span> 是 <span class="math inline">\(C\)</span> 整数倍的时候才能相遇</li><li><span class="math inline">\((N_2-1)i+L1 = KC\)</span> （<span class="math inline">\(K\)</span> 为任意正整数），显然，<span class="math inline">\(N_2\)</span> 取任意大于1的实数，均能够满足此等式</li></ul><p>所以，有环链表中，<strong>理论上只要快指针的步长大于慢指针的步长，两指针就能相遇</strong>。</p><p>但是，快指针步长为2，慢指针步长为1之时，其<strong>时间复杂度是最低</strong>的，故一般如此使用。【关于时间复杂度最低问题，链表中，快指针虽然说是一次走两步，但是其仍旧是一个结点一个结点逐次访问的，所以步长越大，其所遍历的多余结点数就越多，当然时间复杂度也会相应提升】</p><h3 id="环形链表-ii"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a></h3><p>本题与环形链表不同的是，需要求出环形链表的入环结点。此题所采用的算法好像正规名叫 Floyd 判圈算法 ，是图论里的一种算法。</p><h4 id="题目解答-2">题目解答</h4><p>这算法的<strong>详细描述</strong>是：</p><ul><li>利用快慢指针判断是否有环</li><li>如果有，则将相遇的结点标记，同时设新指针指向链表头。</li><li>两个指针分别从相遇的结点和链表头开始移动，直至相遇，相遇后的结点便是入环结点。</li></ul><p><code>java</code> 代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="hljs-comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="hljs-comment"> *     int val;</span></span><br><span class="line"><span class="hljs-comment"> *     ListNode next;</span></span><br><span class="line"><span class="hljs-comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="hljs-comment"> *         val = x;</span></span><br><span class="line"><span class="hljs-comment"> *         next = null;</span></span><br><span class="line"><span class="hljs-comment"> *     &#125;</span></span><br><span class="line"><span class="hljs-comment"> * &#125;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">findIntersection</span><span class="hljs-params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="hljs-keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode intersection = findIntersection(head);</span><br><span class="line">        <span class="hljs-keyword">if</span> (intersection == <span class="hljs-keyword">null</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersection;</span><br><span class="line">        <span class="hljs-keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了清晰起见，重新定义了一个函数。</p><h4 id="原理分析-2">原理分析</h4><p>由上题之证明：二指针相遇之时，恰好满足 <span class="math inline">\([(N_2 - 1)i + L1]\ mod\ C = 0\)</span> ；</p><p>又因为<code>i</code> 为慢指针走的步数，<code>L1</code> 为前无环部分的长度，二者之和刚好是 <span class="math inline">\(C\)</span> 的整数倍。所以，可得 <span class="math inline">\(C-i = L1\)</span>，故此方法定能找到入环结点。</p><hr><h4 id="参考文章">参考文章：</h4><p><a href="http://windsmoon.com/2017/10/09/判断单向链表是否有环及求环入口的算法数学证明/#more" target="_blank" rel="noopener">windsmoon的博客：判断单向链表是否有环及求环入口的算法数学证明</a></p><p><a href="https://www.zhihu.com/question/23208893" target="_blank" rel="noopener">知乎问题：为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？</a></p><p><a href="https://stackoverflow.com/questions/3952805/proof-of-detecting-the-start-of-cycle-in-linked-list" target="_blank" rel="noopener">StackOverflow 提问：Proof of detecting the start of cycle in linked list</a></p><hr><p>本文题目均来源于<code>LeetCode</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表是最为基本的数据结构之一，常与数组作比较。由于链表相较于数组更加优良的的增删性能，常利用于增删比较频繁场合，并且衍生出了许多特殊的链表结构——静态链表，循环链表，双向链表等等。&lt;/p&gt;
&lt;p&gt;而链表操作具有较强的技巧性，双指针最为常见，而双指针中，又以快慢指针最为特殊。这篇文章将根据自己的理解，说明快慢指针的原理与常见应用。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="算法技巧" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>由一道题重新审视排序</title>
    <link href="http://yoursite.com/2019/08/14/%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/08/14/由一道题重新审视排序/</id>
    <published>2019-08-14T11:31:44.000Z</published>
    <updated>2019-10-04T13:10:50.400Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天闲得无聊，写了道题，写完后，我发现这道题让我对排序有了更加深刻的认识，如今在看来，排序的核心主要有两点：</p><ul><li>比较函数（也就是比较的结果），决定了以何种方式进行排序：从大到小抑或是从小到大，甚至是其他更为特殊的方式</li><li>比较次数（也就是比较的方式），决定了排序的时间复杂度，也就是说，要想降低排序的时间复杂度，其重点就在于减少排序的次数。</li></ul><a id="more"></a><h3 id="排序总述">排序总述</h3><p>排序，在我看来，就是<strong>以给定的规则，对一组数（或者字符）进行重新排列</strong>，而规则是可变的，比如我们日常使用的：从大到小的顺序，从小到大的顺序，字典序等等等等。</p><p>那么，<strong>从底向上</strong>看排序，其最核心的部分，就在于两两比较，通过比较，就能确定两两之间的相对顺序——即谁先谁后。</p><p>而排序的效率，则取决于比较次数的多少，比如我们可以通过<strong>不重复比较</strong>，或者一些特殊的比较方式来缩短时间复杂度。</p><h3 id="比较函数">比较函数</h3><h4 id="总述">总述</h4><p>什么是比较函数？抽象来说，就是比较两个数，并确定其先后顺序的函数；具体来说，就是C语言 <code>qsort()</code> 函数中的 <code>cmp</code> 参数，是 <code>java</code> 中 <code>Arrays.sort()</code> 方法中的 <code>Comparator</code> 参数。</p><p>比较函数的一般写法是，对传入的两个参数（<code>a, b</code>）进行比较：</p><ul><li><code>a</code> 大于 <code>b</code> 返回 <code>1</code></li><li><code>a</code> 大于 <code>b</code> 返回 <code>-1</code></li><li><code>a</code> 大于 <code>b</code> 返回 <code>0</code></li></ul><p>规则进行返回，通过控制两个参数的传入，来控制从大到小排列或者从小到大排列。</p><h4 id="比较">比较</h4><p>比较可以自己写规则，比如最为简单的数字的 从大到小，从小到大 等等，但是一些时候就不仅仅是简单的的从大到小或是从小到大了，比如我今天写的这个题（<a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener"><code>leetcode 179</code></a>）：</p><p><strong>题目如下：</strong></p><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p><p>示例 1:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: 210</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: 9534330</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p><strong>题目解答：</strong></p><p>这题本质是一个排序问题，而排序的方式不再是简单的数字排序：</p><ul><li>数字从大到小排序：<code>98</code> 肯定在 <code>9</code>前面，但是此题则应该将顺序置反</li><li>数字从小到大排序：<code>2</code> 肯定在 <code>42</code> 前面，但是此题则应该将顺序置反</li></ul><p>所以此题的比较不能够按照常规方式写，而我们可以按照字符串的字典序来看，也就是说，将两个数字拼接，比较两种拼接方式的大小，从而选择排列顺序，比如：<code>98</code> 和 <code>9</code></p><ul><li>两个数只有两种拼接方式：<code>998</code> 明显大于 <code>989</code> ，所以 <code>9</code> 应该在 <code>98</code> 前面</li></ul><p>便是以此种方式，来进行排序，排序后，将之依次拼贴为一字符串即可, <code>java</code>代码（参考了 <code>leetcode</code> 官方题解）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LargerNumberComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String a, String b)</span> </span>&#123;</span><br><span class="line">            String order1 = a + b;</span><br><span class="line">            String order2 = b + a;</span><br><span class="line">            <span class="hljs-keyword">return</span> order2.compareTo(order1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">largestNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] numsString = <span class="hljs-keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            numsString[i] = String.valueOf(nums[i]);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(numsString, <span class="hljs-keyword">new</span> LargerNumberComparator());</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> (numsString[<span class="hljs-number">0</span>].equals(<span class="hljs-string">"0"</span>))</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        String ret = <span class="hljs-keyword">new</span> String();</span><br><span class="line">        <span class="hljs-keyword">for</span> (String numString:numsString)</span><br><span class="line">            ret += numString;   </span><br><span class="line">        <span class="hljs-keyword">return</span> ret;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较次数">比较次数</h3><p>这部分内容不算是重点，所以，大致说明即可：</p><ul><li>冒泡排序，每次循环都会比较，所以几乎每两个数字间都会进行比较，所以其时间复杂度为 <span class="math inline">\(O(N^2)\)</span></li><li>而比较高级的排序，比如归并，快排甚至桶排，都是降低了比较次数，从而降低了时间复杂度；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天闲得无聊，写了道题，写完后，我发现这道题让我对排序有了更加深刻的认识，如今在看来，排序的核心主要有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较函数（也就是比较的结果），决定了以何种方式进行排序：从大到小抑或是从小到大，甚至是其他更为特殊的方式&lt;/li&gt;
&lt;li&gt;比较次数（也就是比较的方式），决定了排序的时间复杂度，也就是说，要想降低排序的时间复杂度，其重点就在于减少排序的次数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://yoursite.com/2019/08/02/%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/08/02/队列/</id>
    <published>2019-08-02T08:58:43.000Z</published>
    <updated>2019-08-02T13:15:20.841Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>队列是具有一定操作约束的线性表，只能在一端（队尾）进行插入，另一端（队头）进行删除。</strong></p><p>简单地理解，按照字面意思，队列这种数据结构，就如同生活中排队的队列一般，后来的人（数据）只能跟在队尾，而队首的人（数据）首先接受服务（进行删除）。</p><ul><li>数据插入：入队列 （<code>addQueue</code>）</li><li>数据删除：出队列 （<code>deleteQueue</code>）</li></ul><a id="more"></a><p>而队列主要的<strong>特性</strong>如下：</p><ul><li>先来先服务</li><li>先进先出：FIFO</li></ul><p><strong>类型名称：</strong>队列（Queue）</p><p><strong>数据对象集：</strong>一个有0个或多个元素的有穷线性表</p><p><strong>操作集：</strong>长度为 <code>MaxSize</code> 的队列 <code>Q</code> 属于 <code>Queue</code>， 队列元素 <code>item</code> 属于 <code>ElementType</code></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Queue CreatQueue()生成空队列</span><br><span class="line">2. int IsFullQ(Queue PtrQ)判断队列Q是否已满</span><br><span class="line">3. void AddQ(Queue PtrQ, ElementType item)将数据元素item插入队列Q中</span><br><span class="line">4. int IsEmptyQ(Queue PtrQ)判断队列是否为空</span><br><span class="line">5. ElementType DeleteQ(Queue PtrQ)将对头数据元素从队列中删除并返回</span><br></pre></td></tr></table></figure><h3 id="队列的顺序储存实现">队列的顺序储存实现</h3><p>利用数组来实现相关操作</p><ul><li><h4 id="直接利用数组实现">直接利用数组实现</h4><p>数组的一端作为头，另一端作为尾，这样的方式是比较容易<strong>实现</strong>的：</p><ul><li>首先在空数组上的将队列头和尾均放在数组头的前一个位置，头和尾的标号为-1</li></ul></li><li><p>添加元素之后，则将队尾保存的标号加一；同理删除元素之后，将队头的元素加一</p></li></ul><p><strong>存在的问题：</strong></p><ul><li><p>如果队放满，也就是队尾下标为 <code>MaxSize-1</code> 但此时队头由于删除元素的原因，还空有位置，因此会造成空间浪费。</p></li><li><h4 id="利用环形数组实现">利用环形数组实现</h4><p>环形数组并不是物理意义上的环形，而是指队列如果放满之后（队尾下标为 <code>MaxSize-1</code> ），数组头部如果还有空位，就将新加进来的元素，从数组头继续存放。这时，如何判断队列是否已满呢？</p><p><strong>判断队列空和满</strong></p><ul><li><strong>空：</strong>队头下标等于队尾下标</li></ul></li><li><p><strong>满：</strong>队尾下标加一等于对头下标，但如果此时队尾下标而队头为0则无法用此法判断</p></li></ul><p><strong>改进：</strong>最大队尾下标加一除以 <code>MaxSize</code> 的余数等于队尾下标（除数大于被除数，余数为被除数本身）</p><p>正因为上述所说，平常所说的 <strong>顺序存储</strong> 实现均是以 <strong>指环形数组</strong> 的方式实现。</p><p>首先写出 <code>Queue.h</code> ，C语言代码如下：</p><p><strong>C语言代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-comment">// Created by wenmang on 2019/8/2.</span></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATA_STRUCTURE_QUEUE_H</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA_STRUCTURE_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BASE_SIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> elementType;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">queue</span>;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>&#123;</span></span><br><span class="line">    elementType* data;<span class="hljs-comment">// 队列数据存储位置</span></span><br><span class="line">    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">// data 数组大小</span></span><br><span class="line">    <span class="hljs-keyword">int</span> rear;<span class="hljs-comment">// 队尾</span></span><br><span class="line">    <span class="hljs-keyword">int</span> front;<span class="hljs-comment">// 队首</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-built_in">queue</span> <span class="hljs-title">createQueue</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q, elementType e)</span></span>;</span><br><span class="line"><span class="hljs-function">elementType <span class="hljs-title">deleteQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//DATA_STRUCTURE_QUEUE_H</span></span></span><br></pre></td></tr></table></figure><p>紧接着，我们在 <code>Queue.c</code> 文件中实现头文件中所申明的函数：</p><p><strong>C语言代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-comment">// Created by wenmang on 2019/8/2.</span></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Queue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-built_in">queue</span> <span class="hljs-title">createQueue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">queue</span> q = (<span class="hljs-built_in">queue</span>) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct QNode));</span><br><span class="line">    q-&gt;size = <span class="hljs-number">8</span>;</span><br><span class="line">    q-&gt;data = (elementType*) <span class="hljs-built_in">malloc</span>(q-&gt;size * <span class="hljs-keyword">sizeof</span>(elementType));</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (q-&gt;rear+<span class="hljs-number">1</span>) % q-&gt;size == q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> q-&gt;rear == q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q, elementType e)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (isFull(q)) &#123;</span><br><span class="line">        q-&gt;size *= <span class="hljs-number">2</span>;</span><br><span class="line">        q-&gt;data = (elementType*) <span class="hljs-built_in">realloc</span>(q-&gt;data, q-&gt;size * <span class="hljs-keyword">sizeof</span>(elementType));</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear = (q-&gt;rear+<span class="hljs-number">1</span>) % q-&gt;size;</span><br><span class="line">    q-&gt;data[q-&gt;rear] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">elementType <span class="hljs-title">deleteQueue</span><span class="hljs-params">(<span class="hljs-built_in">queue</span> q)</span> </span>&#123;</span><br><span class="line">    assert(!isEmpty(q));</span><br><span class="line">    q-&gt;front = (q-&gt;front+<span class="hljs-number">1</span>) % q-&gt;size;</span><br><span class="line">    <span class="hljs-keyword">return</span> q-&gt;data[q-&gt;front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式储存实现">队列的链式储存实现</h3><p>也就是使用链表存储</p><p>首先可以写出头文件 <code>Queue.h</code> 的内容：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-comment">// Created by wenmang on 2019/8/2.</span></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATA_STRUCTURE_QUEUE_H</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA_STRUCTURE_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span>* <span class="hljs-title">lQueue</span>;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span></span><br><span class="line">    elementType data;</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LQNode</span>&#123;</span></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">rear</span>;</span></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">front</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">lQueue <span class="hljs-title">createlQueue</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addlQueue</span><span class="hljs-params">(lQueue q, elementType e)</span></span>;</span><br><span class="line"><span class="hljs-function">elementType <span class="hljs-title">deletelQueue</span><span class="hljs-params">(lQueue q)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">islEmpty</span><span class="hljs-params">(lQueue q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//DATA_STRUCTURE_QUEUE_H</span></span></span><br></pre></td></tr></table></figure><p>用链表储存，设计了两个结构，</p><p><code>Node</code> 为队列中节点，指针指向下一个节点，<code>data</code> 储存节点数据</p><p><code>QNode</code> 为队列头节点，两个指针分别指向队列头和队列尾</p><p>然后，在 <code>Queue.c</code> 文件中实现声明的函数：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">lQueue <span class="hljs-title">createlQueue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    lQueue q = (lQueue) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct LQNode));</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addlQueue</span><span class="hljs-params">(lQueue q, elementType e)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">tmp</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>*) <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span></span><br><span class="line">    tmp-&gt;data = e;</span><br><span class="line">    <span class="hljs-keyword">if</span> (q-&gt;front == <span class="hljs-literal">NULL</span>)</span><br><span class="line">        q-&gt;front = q-&gt;rear = tmp;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        q-&gt;rear = q-&gt;rear-&gt;next = tmp;</span><br><span class="line">    q-&gt;rear-&gt;next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">elementType <span class="hljs-title">deletelQueue</span><span class="hljs-params">(lQueue q)</span> </span>&#123;</span><br><span class="line">    assert(!islEmpty(q));</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">tmp</span> = <span class="hljs-title">q</span>-&gt;<span class="hljs-title">front</span>;</span></span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">    <span class="hljs-keyword">return</span> tmp-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">islEmpty</span><span class="hljs-params">(lQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> q-&gt;front == <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong>链表储存无需判断是否队列已满</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;队列是具有一定操作约束的线性表，只能在一端（队尾）进行插入，另一端（队头）进行删除。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单地理解，按照字面意思，队列这种数据结构，就如同生活中排队的队列一般，后来的人（数据）只能跟在队尾，而队首的人（数据）首先接受服务（进行删除）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据插入：入队列 （&lt;code&gt;addQueue&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;数据删除：出队列 （&lt;code&gt;deleteQueue&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈的应用及练习</title>
    <link href="http://yoursite.com/2019/07/29/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/07/29/栈的应用及练习/</id>
    <published>2019-07-29T13:03:06.000Z</published>
    <updated>2019-07-29T13:59:12.417Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>既然学了栈这种数据结构，那么就应该进一步深入或者熟练地应用。这也构成了两种不同的应用方式：</p><ul><li>一种是利用栈这种数据结构，来<strong>实现一些其他的数据结构</strong>，比如：用栈来实现队列，或者是<strong>实现一些特殊的栈</strong>，比如：最小栈。</li><li>另一种是具体问题的解决，比如经典的逆波兰表达式的求解等一系列问题</li></ul><a id="more"></a><h4 id="闲话部分在线提交">闲话部分——在线提交</h4><p>为什么要<strong>在线提交？</strong>答案很简单，就是保证自己代码的<strong>完全正确性</strong>。</p><p>怎么理解呢，就是说，你写完一个程序之后，应该仅仅会想出一组或者部分样例来进行测试代码运行结果是否符合自己的预期，但是<strong>自己想出来</strong>的这些样例往往是<strong>不完备</strong>的，而在线提交平台的样例基本是完备的，尤其是一些著名的提交平台。</p><p>那么有哪些平台可以选择呢？</p><ul><li>我个人的喜好是 <a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener"><code>LeetCode</code></a> ，由于网速和英语不好的原因，我选择了其中文网站，如果想练习英语，也可以进其英文官网。</li><li>还有其他类似的平台，牛客啊啥的，可凭自己喜好进行选择。</li></ul><h4 id="栈的应用">栈的应用</h4><p><code>LeetCode</code> 还有比较好的一点就是可以按照标签进行刷题，而网站的题量也在稳步上升，而关于栈的应用，我特意选了这么几道有代表性的题：</p><ul><li><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener"><strong>最小栈</strong></a></li><li><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener"><strong>逆波兰表达式求值</strong></a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener"><strong>二叉树的前序遍历</strong></a></li></ul><h4 id="例题题解">例题题解</h4><p>用什么编程语言写是个问题，我个人觉得，用一些数据结构库比较完备的语言来写比较好，因为写这些题的目的是使用栈来解答问题，而不再需要过度关注栈的构成。</p><p>所以我推荐类似于 <code>C++</code> ，<code>java</code> 甚至 <code>python</code> 等语言来写题。 但是也要注意库的使用，不能说题目让自己实现一个什么，然后你直接调用已经实现的库函数搞定，这样就背离了题目的初衷。</p><h5 id="最小栈">最小栈</h5><p>题目就不复制过来了，可点击链接查看。</p><p>最小栈就是要自己实现一个名为最小栈的数据结构，这个数据结构与普通的栈不同的是，可以在<strong>常数时间</strong>内检测到栈中的最小元素，那么可利用两个栈来实现，从而降低时间复杂度。此题 <code>java</code> 代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="hljs-keyword">if</span> (minStack.empty() || x &lt;= minStack.peek())</span><br><span class="line">            minStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> tmp = stack.pop();</span><br><span class="line">        <span class="hljs-keyword">if</span> (tmp == minStack.peek())</span><br><span class="line">            minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>stack</code> 栈作为普通的栈使用，而 <code>minStack</code> 作为最小栈</li></ul><h5 id="逆波兰表达式求值">逆波兰表达式求值</h5><p>这是一个极为基础的栈题，可以说完全是一个基础的栈的练习，所以也不必进行太多的解释。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (token.equals(<span class="hljs-string">"+"</span>) || token.equals(<span class="hljs-string">"-"</span>) || token.equals(<span class="hljs-string">"*"</span>) || token.equals(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> one = stack.pop();</span><br><span class="line">                <span class="hljs-keyword">int</span> two = stack.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="hljs-keyword">if</span> (token.equals(<span class="hljs-string">"-"</span>))</span><br><span class="line">                    stack.push(two-one);</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token.equals(<span class="hljs-string">"*"</span>))</span><br><span class="line">                    stack.push(two*one);</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token.equals(<span class="hljs-string">"/"</span>))</span><br><span class="line">                    stack.push(two/one);</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token.equals(<span class="hljs-string">"+"</span>))</span><br><span class="line">                    stack.push(two+one);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span></span><br><span class="line">                stack.push(Integer.parseInt(token));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此题注意减数与除数是哪个</li></ul><h5 id="二叉树前序遍历">二叉树前序遍历</h5><p>二叉树前序遍历可利用递归简单地写出，而如果不使用递归的话，就要利用栈来实现，<code>java</code> 代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="hljs-comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="hljs-comment"> *     int val;</span></span><br><span class="line"><span class="hljs-comment"> *     TreeNode left;</span></span><br><span class="line"><span class="hljs-comment"> *     TreeNode right;</span></span><br><span class="line"><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="hljs-comment"> * &#125;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (stack.peek() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                stack.pop();                </span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode tmp = stack.pop();</span><br><span class="line">            ret.add(tmp.val);</span><br><span class="line">            stack.push(tmp.right);</span><br><span class="line">            stack.push(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用栈 <code>先进后出</code> 的特性，先压右子树，再将左子树压入栈中即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然学了栈这种数据结构，那么就应该进一步深入或者熟练地应用。这也构成了两种不同的应用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是利用栈这种数据结构，来&lt;strong&gt;实现一些其他的数据结构&lt;/strong&gt;，比如：用栈来实现队列，或者是&lt;strong&gt;实现一些特殊的栈&lt;/strong&gt;，比如：最小栈。&lt;/li&gt;
&lt;li&gt;另一种是具体问题的解决，比如经典的逆波兰表达式的求解等一系列问题&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>堆栈</title>
    <link href="http://yoursite.com/2019/07/22/%E5%A0%86%E6%A0%88/"/>
    <id>http://yoursite.com/2019/07/22/堆栈/</id>
    <published>2019-07-22T05:00:00.000Z</published>
    <updated>2019-08-02T09:03:47.371Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>堆栈是一种数据项按序排列的数据结构，只能在一端（称为栈顶(top)）对数据项进行插入和删除。</strong></p><p>简单地说，堆栈可以看作一个箱子，只能在一端放和取，所以其主要操作有：</p><ul><li>插入数据：入栈（Push）</li><li>删除数据：出栈（Pop）</li></ul><a id="more"></a><p>而只能一端存取，也形成了其最主要的特性：</p><ul><li>后入先出：Last In First Out（LIFO）</li></ul><p><strong>类型名称：</strong>堆栈（Stack）</p><p><strong>数据对象集：</strong>一个有0个或多个元素的有穷线性表</p><p><strong>操作集：</strong>长度为 <code>MaxSize</code> 的堆栈 <code>S</code> 属于 <code>Stack</code> ， 堆栈元素 <code>item</code> 属于 <code>ElementType</code></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Stack CreateStack  ()生成空堆栈</span><br><span class="line">2. int IsFull (Stack S)判断堆栈S是否已满</span><br><span class="line">3. void Push (Stack PtrS, ElementType item) 将元素item压入堆栈</span><br><span class="line">4. int IsEmpty (Stack S)    判断堆栈S是否为空</span><br><span class="line">5. ElementType Pop (Stack PtrS)删除堆栈并返回栈顶元素</span><br></pre></td></tr></table></figure><h3 id="栈的顺序储存实现">栈的顺序储存实现</h3><p>所谓顺序存储，也就是利用数组来实现栈的相关操作，那么根据之前的叙述，我们可以写出栈库的头文件 <code>Stack.h</code></p><p><strong>C语言代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATA_STRUCTURE_STACK_H</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA_STRUCTURE_STACK_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> elementType;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span>* <span class="hljs-title">stack</span>;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span>* <span class="hljs-built_in">stack</span>;<span class="hljs-comment">// 栈元素所在的数组</span></span><br><span class="line">    <span class="hljs-keyword">int</span> allocLength;<span class="hljs-comment">// 栈的大小</span></span><br><span class="line">    <span class="hljs-keyword">int</span> top;<span class="hljs-comment">// 栈顶下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-built_in">stack</span> <span class="hljs-title">createStack</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span> <span class="hljs-params">(<span class="hljs-built_in">stack</span> s, <span class="hljs-keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="hljs-function">elementType <span class="hljs-title">pop</span> <span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//DATA_STRUCTURE_STACK_H</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>说明：</strong> 栈所在结构体，为了使其大小可扩展，所以将 <code>stack[]</code> 数组以指针的方式替换，同时增加了一个用于保存栈大小的元素，即 <code>allocLength</code></li></ul><p>接下来在 <code>Stack.c</code> 中实现所定义的函数。</p><p><strong>C语言代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment"> * Created by wenmang on 2019/7/22.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-built_in">stack</span> <span class="hljs-title">createStack</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">stack</span> s =  (<span class="hljs-built_in">stack</span>) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct SNode));</span><br><span class="line">    s-&gt;allocLength = <span class="hljs-number">8</span>;<span class="hljs-comment">// 栈初始空间分配为 8</span></span><br><span class="line">    s-&gt;top = <span class="hljs-number">0</span>;</span><br><span class="line">    s-&gt;<span class="hljs-built_in">stack</span> = (elementType*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(elementType) * s-&gt;allocLength);</span><br><span class="line">    <span class="hljs-keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span> <span class="hljs-params">(<span class="hljs-built_in">stack</span> s, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (isFull(s)) &#123;</span><br><span class="line">        s-&gt;allocLength *= <span class="hljs-number">2</span>;</span><br><span class="line">        s-&gt;<span class="hljs-built_in">stack</span> = (elementType*) <span class="hljs-built_in">realloc</span>(s-&gt;<span class="hljs-built_in">stack</span>, <span class="hljs-keyword">sizeof</span>(elementType) * s-&gt;allocLength);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;<span class="hljs-built_in">stack</span>[s-&gt;top++] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">elementType <span class="hljs-title">pop</span> <span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span> </span>&#123;</span><br><span class="line">    assert(s-&gt;top &gt;= <span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> s-&gt;<span class="hljs-built_in">stack</span>[s-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> s-&gt;top == s-&gt;allocLength<span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> s-&gt;top &lt; <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思考">思考</h4><p><strong>问：</strong>一个数组实现两个堆栈</p><ol type="1"><li><p>数组对半分之后分别从左向右储存</p><p>缺点：对半分之后，如果右边的数组放满之后左边却未放满，即有空间却无法再储存，就会造成空间浪费</p></li><li><p>一个从左向右，一个从右向左（<strong>改进方法</strong>）</p></li></ol><p><strong>对应栈的结构体如下：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Stack</span>;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DStack</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="hljs-keyword">int</span> Top1;</span><br><span class="line">    <span class="hljs-keyword">int</span> Top2;    <span class="hljs-comment">// 表示栈中元素的下标</span></span><br><span class="line">&#125;S;</span><br><span class="line">S.Top1 = <span class="hljs-number">-1</span>;<span class="hljs-comment">// 栈1的初始下标为-1</span></span><br><span class="line">S.Top2 = MaxSize;<span class="hljs-comment">//栈2的初始下标为MaxSise</span></span><br></pre></td></tr></table></figure><p><strong>压栈</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(struct DStack *ParS, ElementType item, <span class="hljs-keyword">int</span> Tag)</span></span>&#123;  <span class="hljs-comment">// 压栈操作</span></span><br><span class="line">    <span class="hljs-comment">/* Tag 为区分两个堆栈的标志 取值为1和2 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (PtrS-&gt;Top2 - PtrS-&gt;Top1 == <span class="hljs-number">1</span>)&#123;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"堆栈满"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (Tag == <span class="hljs-number">1</span>)   <span class="hljs-comment">// 压入第一个堆栈</span></span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item;</span><br><span class="line">    <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 压入第二个堆栈</span></span><br><span class="line">        PtrS-&gt;Data[--(PtrS-&gt;Top1)] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>弹栈</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">ElementType <span class="hljs-title">Pop</span><span class="hljs-params">(struct DStack *ParS, <span class="hljs-keyword">int</span> Tag)</span></span>&#123;  <span class="hljs-comment">// 弹栈操作 两个栈分别考虑</span></span><br><span class="line">    <span class="hljs-comment">/* Tag 为区分两个堆栈的标志 取值为1和2 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (Tag == <span class="hljs-number">1</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (PtrS-&gt;Top1 == <span class="hljs-number">-1</span>)&#123;</span><br><span class="line">            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"堆栈1为空"</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span></span><br><span class="line">            <span class="hljs-keyword">return</span> PtrS-Data[(PtrS-&gt;Top1)--];</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (PtrS-&gt;Top2 == MaxSize)&#123;</span><br><span class="line">            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"堆栈2为空"</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span></span><br><span class="line">            <span class="hljs-keyword">return</span> PtrS-&gt;Data[(PtrS-&gt;Top2)++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆栈的链式储存实现">堆栈的链式储存实现</h3><p>链式存储其实我认为就栈而言，并不占什么优势，所以一般顺序实现即可，链式存储的 <code>Stack.h</code> 如下：</p><p><strong>C语言代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATA_STRUCTURE_STACK_H</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA_STRUCTURE_STACK_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>* <span class="hljs-title">lStack</span>;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>   <span class="hljs-comment">// 链式存储的栈</span></span><br><span class="line">    elementType data;</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>* <span class="hljs-title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">lStack <span class="hljs-title">createLStack</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushL</span> <span class="hljs-params">(lStack s, <span class="hljs-keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">popL</span> <span class="hljs-params">(lStack s)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLEmpty</span><span class="hljs-params">(lStack s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//DATA_STRUCTURE_STACK_H</span></span></span><br></pre></td></tr></table></figure><p>函数实现如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">lStack <span class="hljs-title">createLStack</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    lStack s = (lStack) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct LNode));</span><br><span class="line">    s-&gt;next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushL</span> <span class="hljs-params">(lStack s, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>* <span class="hljs-title">tmp</span> = (<span class="hljs-title">lStack</span>) <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">LNode</span>));</span></span><br><span class="line">    tmp-&gt;data = val;</span><br><span class="line">    tmp-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">elementType <span class="hljs-title">popL</span> <span class="hljs-params">(lStack s)</span> </span>&#123;</span><br><span class="line">    assert(s-&gt;next != <span class="hljs-literal">NULL</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> tmp = s-&gt;next-&gt;data;</span><br><span class="line">    s-&gt;next = s-&gt;next-&gt;next;</span><br><span class="line">    <span class="hljs-keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLEmpty</span><span class="hljs-params">(lStack s)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> s-&gt;next == <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 链式存储的栈，为方便操作，是带有头指针的。</p><hr><p>学习的数据结构就是<strong>拿来用的</strong>，而如今的许多高级语言，已经将绝大多数数据结构以库的形式封装起来，在使用的时候，我们只需要直接调用即可，而不需要自己再写一个栈。例如 <code>Java</code> 中的 <code>Stack</code> 类，我们在使用的时候如果不熟，则可以查看<a href="https://www.runoob.com/java/java-stack-class.html" target="_blank" rel="noopener">文档</a>，然后直接调用即可。</p><p>在熟悉构成之后，便可以进行应用，比如刷<a href="https://leetcode-cn.com/tag/stack/" target="_blank" rel="noopener">LeetCode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;堆栈是一种数据项按序排列的数据结构，只能在一端（称为栈顶(top)）对数据项进行插入和删除。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单地说，堆栈可以看作一个箱子，只能在一端放和取，所以其主要操作有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入数据：入栈（Push）&lt;/li&gt;
&lt;li&gt;删除数据：出栈（Pop）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>以stack来进一步了解C语言的泛型</title>
    <link href="http://yoursite.com/2019/03/29/%C2%96%E4%BB%A5stack%E6%9D%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/29/以stack来进一步了解C语言的泛型/</id>
    <published>2019-03-29T14:34:44.000Z</published>
    <updated>2019-03-29T14:45:16.449Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>此篇博文根据斯坦福公开课 《编程范式》整理，也算是一个简单的笔记。</p><h4 id="stack栈">Stack（栈）</h4><p>栈是一种十分基础的数据结构，也十分简单，下面我们首先来实现此种数据结构的int表示</p><a id="more"></a><h4 id="stack.h">stack.h</h4><p>在此文件之中，我们对栈的结构和栈的基本操作进行了定义，其中代码如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span>* elems;</span><br><span class="line">    <span class="hljs-keyword">int</span> logLength;</span><br><span class="line">    <span class="hljs-keyword">int</span> allocLength;</span><br><span class="line">&#125;<span class="hljs-built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackNew</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackDispose</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackPush</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s, <span class="hljs-keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">StackPop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="stack.c">stack.c</h4><p>此文件中，将 <code>.h</code> 文件中的函数进行了实现，代码如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackNew</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line">    s-&gt;allocLength = <span class="hljs-number">4</span>;</span><br><span class="line">    s-&gt;logLength = <span class="hljs-number">0</span>;</span><br><span class="line">    s-&gt;elems = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*s-&gt;allocLength);</span><br><span class="line">    assert(s-&gt;elems != <span class="hljs-literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackDispose</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">free</span>(s-&gt;elems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackPush</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s, <span class="hljs-keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s-&gt;logLength == s-&gt;allocLength) &#123;</span><br><span class="line">        s-&gt;allocLength *= <span class="hljs-number">2</span>;</span><br><span class="line">        s-&gt;elems = <span class="hljs-built_in">realloc</span>(s-&gt;elems, s-&gt;allocLength*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));</span><br><span class="line">        assert(s-&gt;elems != <span class="hljs-literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;elems[s-&gt;logLength++] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">StackPop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line">    assert(s-&gt;logLength &gt; <span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> s-&gt;elems[s-&gt;logLength--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol type="1"><li><code>assert()</code> ：存于 <code>assert.h</code> 头文件之中，其传参为一个布尔值，传入值为<code>true</code> 之时，什么也不做；如果为<code>flase</code> ，就停止继续执行程序并打印错误。用于此处，是为了检测开辟空间是否成功。</li><li><code>StackPush()</code> 函数可以拓展栈的大小</li></ol><p>如同之前所讲，有了基本的 <code>int</code> 版，那么就可以向着泛型版转化了。</p><h4 id="泛型化的stack">泛型化的stack</h4><p>为了向泛型进化，我们必须在原结构体中加入数据类型的字节数，所以结构体结果如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span>* elems;</span><br><span class="line">    <span class="hljs-keyword">int</span> elemSize;</span><br><span class="line">    <span class="hljs-keyword">int</span> logLength;</span><br><span class="line">    <span class="hljs-keyword">int</span> allocLength;</span><br><span class="line">&#125;<span class="hljs-built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackNew</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s, <span class="hljs-keyword">int</span> elemSize)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackDispose</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackPush</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s, <span class="hljs-keyword">void</span>* elemAddr)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackPop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s, <span class="hljs-keyword">void</span>* elemAddr)</span></span>;</span><br></pre></td></tr></table></figure><p>同理，各个函数的写法如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackNew</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s, <span class="hljs-keyword">int</span> elemSize)</span> </span>&#123;</span><br><span class="line">    assert(s-&gt;elems &gt; <span class="hljs-number">0</span>);</span><br><span class="line">    s-&gt;elemSize = elemSize;</span><br><span class="line">    s-&gt;allocLength = <span class="hljs-number">4</span>;</span><br><span class="line">    s-&gt;logLength = <span class="hljs-number">0</span>;</span><br><span class="line">    s-&gt;elems = <span class="hljs-built_in">malloc</span>(elemSize*s-&gt;allocLength);</span><br><span class="line">    assert(s-&gt;elems != <span class="hljs-literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackDispose</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">free</span>(s-&gt;elems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StackGrow</span><span class="hljs-params">(<span class="hljs-built_in">stack</span> *s)</span> </span>&#123;</span><br><span class="line">    s-&gt;allocLength *= <span class="hljs-number">2</span>;</span><br><span class="line">    s-&gt;elems = <span class="hljs-built_in">realloc</span>(s-&gt;elems, s-&gt;elemSize * s-&gt;allocLength);</span><br><span class="line">    assert(s-&gt;elems != <span class="hljs-literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackPush</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s, <span class="hljs-keyword">void</span>* elemAddr)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s-&gt;logLength == s-&gt;allocLength)</span><br><span class="line">        StackGrow(s);</span><br><span class="line">    <span class="hljs-keyword">void</span>* target = (<span class="hljs-keyword">char</span>*)s-&gt;elems + s-&gt;logLength*s-&gt;elemSize;</span><br><span class="line">    <span class="hljs-built_in">memcpy</span>(target, elemAddr, s-&gt;elemSize);</span><br><span class="line">    s-&gt;logLength++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackPop</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s, <span class="hljs-keyword">void</span>* elemAddr)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span>* source = (<span class="hljs-keyword">char</span>*)s-&gt;elems + (s-&gt;logLength - <span class="hljs-number">1</span>) * s-&gt;elemSize;</span><br><span class="line">    <span class="hljs-built_in">memcpy</span>(elemAddr, source, s-&gt;elemSize);</span><br><span class="line">    s-&gt;logLength--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol type="1"><li>值与值之间的传递都依靠参数传递</li><li><code>static</code> 修饰的函数，只在当前文件可以调用（也就是相当于一个内部函数）</li></ol><h4 id="关于字符串">关于字符串</h4><p>众所周知，字符串的传递是与众不同的，所以与其相关的一些问题也需要进行特殊处理，我们先来看一段使用字符串进行栈操作的代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* names[] = &#123;<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Lily"</span>, <span class="hljs-string">"Mike"</span>, <span class="hljs-string">"James"</span>&#125;;</span><br><span class="line">    <span class="hljs-built_in">stack</span>* s;</span><br><span class="line">    <span class="hljs-keyword">char</span>* name;</span><br><span class="line">    StackNew(s, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>*));</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">char</span>* copy = strdup(names[i]);</span><br><span class="line">        StackPush(s, &amp;copy);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;</span><br><span class="line">        StackPop(s, &amp;name);</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, name);</span><br><span class="line">        <span class="hljs-built_in">free</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    StackDispose(s);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于字符串的长度是不一定的，为了简化代码，因此操作字符串之时在栈中保存的是指向该字符串的指针，但是如此一来便会产生一个<strong>问题：</strong></p><p>当栈中还有元素之时，用户直接进行<code>StackDispose()</code> 操作之后，并没有释放掉指针所指向的空间，因此我们需要继续改进代码。</p><p>而怎样改进呢？<strong>首先我们应该让程序知道这个栈到底是什么类型的栈</strong>，如果是指针类型的，就要在结构体中传入一个额外的指针，指向栈所指向的地址，以便在之后更好地进行<code>free()</code>，所以将结构体改进如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span>* elems;</span><br><span class="line">    <span class="hljs-keyword">int</span> elemSize;</span><br><span class="line">    <span class="hljs-keyword">int</span> logLength;</span><br><span class="line">    <span class="hljs-keyword">int</span> allocLength;</span><br><span class="line">    <span class="hljs-keyword">void</span> (*freefn) (<span class="hljs-keyword">void</span>*);</span><br><span class="line">&#125;<span class="hljs-built_in">stack</span>;</span><br></pre></td></tr></table></figure><p>而我们在进行 <code>StackNew()</code> 操作之时，就需要对栈的类型进行声明，所以将其传参改进如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackNew</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s, <span class="hljs-keyword">int</span> elemSize; <span class="hljs-keyword">void</span>* freefn(<span class="hljs-keyword">void</span>*))</span> </span>&#123;</span><br><span class="line">    assert(s-&gt;elems &gt; <span class="hljs-number">0</span>);</span><br><span class="line">    s-&gt;freefn = freefn;</span><br><span class="line">    s-&gt;elemSize = elemSize;</span><br><span class="line">    s-&gt;allocLength = <span class="hljs-number">4</span>;</span><br><span class="line">    s-&gt;logLength = <span class="hljs-number">0</span>;</span><br><span class="line">    s-&gt;elems = <span class="hljs-built_in">malloc</span>(elemSize*s-&gt;allocLength);</span><br><span class="line">    assert(s-&gt;elems != <span class="hljs-literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们将对 <code>StackDispose()</code> 进行重写：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StackDispose</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s-&gt;freefn != <span class="hljs-literal">NULL</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s-&gt;logLength; i++) &#123;</span><br><span class="line">            s-&gt;freefn ((<span class="hljs-keyword">char</span>*)s-&gt;elems + i * s-&gt;elemSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">free</span>(s-&gt;elems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一般来说，字符串的释放函数应当如下：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StrFree</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">free</span>(*(<span class="hljs-keyword">char</span>**)s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇博文根据斯坦福公开课 《编程范式》整理，也算是一个简单的笔记。&lt;/p&gt;
&lt;h4 id=&quot;stack栈&quot;&gt;Stack（栈）&lt;/h4&gt;
&lt;p&gt;栈是一种十分基础的数据结构，也十分简单，下面我们首先来实现此种数据结构的int表示&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现简单的泛型</title>
    <link href="http://yoursite.com/2019/03/05/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/05/C语言实现简单的泛型/</id>
    <published>2019-03-05T07:02:34.000Z</published>
    <updated>2019-08-31T06:08:15.345Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>众所周知，C语言是不支持泛型的，但可以利用C语言自身的语法特点来实现此特性。而此篇博文根据斯坦福公开课 《编程范式》整理，以阐述用C语言实现此种特性的大致思路，也算是一个简单的笔记。</p><h4 id="从-swap-谈起">从 Swap 谈起</h4><a id="more"></a><p>交换函数应该是最常见也是最常用的函数之一，C语言的交换函数一般这样写：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> *p, <span class="hljs-keyword">int</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> tmp = *p;</span><br><span class="line">    *p = *q;</span><br><span class="line">    *q = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如上代码仅能对 <code>int</code> 类型数据进行交换，如果要交换 <code>double</code> 或者其他类型的数据又需要写一段极其相似的代码（仅将 <code>int</code> 换掉），而这样无疑是不够简练的，代码也不够优美。所以我们考虑写一个能交换所有数据类型的函数，以简练代码，提高效率。</p><p>既然有这样的想法，那么我们试着去实现它。既然要普适所以数据类型，那么我们就需要向本源出发去寻找。无论什么类型的数据，在计算机底层都是以二进制储存的，这我们就找到了所有不同类型数据的共同点，也就有了设计思路：</p><ol type="1"><li>在内存中找到两个数据的地址</li><li>从头至尾，将两个数据的每一个字节进行交换</li></ol><p>所以结合C语言的语法特点，便有了如下代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">void</span> *q, <span class="hljs-keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> buffer[size];</span><br><span class="line">    <span class="hljs-built_in">memcpy</span>(buffer, p, size);</span><br><span class="line">    <span class="hljs-built_in">memcpy</span>(p, q, size);</span><br><span class="line">    <span class="hljs-built_in">memcpy</span>(q, buffer, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就代码而言，此一类函数写就的重中之重就是 <code>void</code> 指针的利用，将 <code>void</code> 指针用于形参，以作限定。由于 <code>void *</code> 变量无法直接引用，因为编译器不知道此指针所指变量到底占了几个字节，且因为要适应所有数据类型，所以多传了个参数—— <code>size</code> ，来对传入数据类型所占字节数进行说明。而整段代码原理如下：</p><ol type="1"><li>传入两个数据在内存中的地址以及数据所占字节数</li><li>创建临时变量字符数组 <code>buffer[]</code> 作为中间值（因为一个 <code>char</code> 占1个字节，所以正好采用字符数组来作为中间值）</li><li>与正常交换的方式相同，不过是采用 <code>memcpy()</code> 来进直接对内存进行操作，逐个字节进行复制</li></ol><h4 id="谈谈-issearch">谈谈 IsSearch()</h4><p>既然知道了此种思路与写法，那么我们直接看另一个简单的函数——线性查找，以 <code>int</code> 为例，代码是这样的：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsSearch</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)</span><br><span class="line">        <span class="hljs-keyword">if</span> (a[i] == key)</span><br><span class="line">            <span class="hljs-keyword">return</span> i;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果使用泛型，代码应该怎样写呢？答案是这样的：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">IsSearch</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* key, <span class="hljs-keyword">void</span>* base, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> elemSize)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">void</span>* elemAddr = (<span class="hljs-keyword">char</span>*)base + i*elemSize;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcpy</span>(key, elemAddr, elemSize) == <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> elemAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整段代码解释如下：</p><ol type="1"><li>传入需要搜索的值，被搜索数组，数组元素数，数组每个元素所占字节数</li><li>进入循环开始查找：<ol type="1"><li>先确定每一个元素的地址（由于 <code>void*</code> 类型的指针不支持直接操作，所以需要先将其进行强制类型转换为 <code>char*</code> 类型指针）</li><li>调用库函数，将 <code>key</code> 和数组中的元素依次进行必较</li></ol></li><li>成功则返回数组对应元素的首地址，否则返回NULL</li></ol><p>但如果我们不利用库函数来进行比较呢？我们想使用自己写的比较函数来比较，那有应该怎么做呢？（<strong>注：</strong>这个想法显然必较牵强，因为此时的这种写法无疑是更加合理的，而为了说明知识点，就加了这个想法）</p><p>（此处 <code>qsort()</code> 课中并未提及）在这里就不得不提一个C语言库函数了，那就是—— <code>qsort()</code> ，一个在调用之时需要写一个针对问题具体情况的比较函数当作参数传入函数之中，而我们这时的情况显然和 <code>qsort()</code> 函数面临的一样，所以我们采用相同的处理方式：传入一个必较函数，来判断两个元素是否一致。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">IsSearch</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* key, <span class="hljs-keyword">void</span>* base, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> elemSize, <span class="hljs-keyword">int</span> (*cmpfn) (<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*))</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">void</span>* elemAddr = (<span class="hljs-keyword">char</span>*)base + i*elemSize;</span><br><span class="line">        <span class="hljs-keyword">if</span> (cmpfn(key, elemAddr) == <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> elemAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>因为 <code>cmpfn()</code> 是调用者写的函数，所以其数据类型是确定的，只需直接比较就行，故只传入两个参数。</p><h4 id="调用-issearch">调用 IsSearch()</h4><p>有了普适版（第二版）的代码，其中提供了函数接口，那么调用者应该怎么写这个函数呢？</p><h5 id="int-类型数据"><code>int</code> 类型数据</h5><p>比较 <code>int</code> 类型数据的函数，代码如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IntCmp</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* n1, <span class="hljs-keyword">void</span>* n2)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span>* ip1 = n1;</span><br><span class="line">    <span class="hljs-keyword">int</span>* ip2 = n2;</span><br><span class="line">    <span class="hljs-keyword">return</span> (*ip1 - *ip2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>此函数所带参数l类型以及返回值类型需与形参中函数一致</p><h5 id="char-字符串类型数据"><code>char*</code> (字符串)类型数据</h5><p>字符串无疑是优雅的，但在C语言中处理字符串，就完全不存在优雅这一说了，因为C语言更加底层，对于字符串的处理不如其他的一些新语言来的形象（当然也是此些语言为字符串处理做了许多预备工作，以至于处理之时只调用已有的函数即可），所以关于字符串的处理可能要更加不易理解，代码如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">StrCmp</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* vp1, <span class="hljs-keyword">void</span>* vp2)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span>* s1 = * (<span class="hljs-keyword">char</span>**)vp1;</span><br><span class="line">    <span class="hljs-keyword">char</span>* s2 = * (<span class="hljs-keyword">char</span>**)vp2;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅看如此代码，会有种毫无头绪的感觉，那么为了更好地理解，我们需要写一下查找字符串时的全过程，代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">char</span>* key = <span class="hljs-string">"Li"</span>;</span><br><span class="line"><span class="hljs-keyword">char</span>* faName[] = &#123;<span class="hljs-string">"zhang"</span>, <span class="hljs-string">"wang"</span>, <span class="hljs-string">"li"</span>, <span class="hljs-string">"zhao"</span>, <span class="hljs-string">"sun"</span>&#125;;</span><br><span class="line"><span class="hljs-keyword">char</span>** found = IsSearch(&amp;key, faName, <span class="hljs-number">5</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>*), StrCmp);</span><br></pre></td></tr></table></figure><p>好，因为单个的 <code>char</code> 是字符，而字符串是 <code>char*</code> ，那么理所当然字符串数组就是 <code>char**</code> 了，所以需要查找之时，传入 <code>IsSearch()</code> 的参数实际上是指针的指针，所以在调用比较函数之时需要进行一次解耦，将之变成两个字符串，而这也就是比较函数前两行的意义所在。</p><p><strong>注：</strong></p><ol type="1"><li>为了比较函数代码美观，所以在传参之时将目标字符串也作为指针的指针传入，如只将其作为指针传入，就无需解耦和了。</li><li>在调用之时，用于接收返回值的变量必须是指针的指针，因为返回是个字符串，也就是一个字符指针</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，C语言是不支持泛型的，但可以利用C语言自身的语法特点来实现此特性。而此篇博文根据斯坦福公开课 《编程范式》整理，以阐述用C语言实现此种特性的大致思路，也算是一个简单的笔记。&lt;/p&gt;
&lt;h4 id=&quot;从-swap-谈起&quot;&gt;从 Swap 谈起&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据在内存中的存储</title>
    <link href="http://yoursite.com/2019/01/24/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2019/01/24/数据在内存中的存储/</id>
    <published>2019-01-24T10:21:02.000Z</published>
    <updated>2019-10-04T13:13:32.199Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>二进制是计算机的基础，数据的存储在底层看来均是由二进制来表示的，那么如何用二进制来表示各种数据呢？此时就需要设计出一套完整的科学的储存方案</p><h3 id="整型数据的存储">整型数据的存储</h3><p>整型数据包括 <code>short</code>, <code>int</code>, <code>long</code> 等，其中最为常用的便是 <code>int</code> ，在目前的系统中（32位和64位编译器，以C语言为主要实例），其所占字节如下：</p><a id="more"></a><table><thead><tr class="header"><th>数据类型</th><th>所占字节</th></tr></thead><tbody><tr class="odd"><td><code>short</code></td><td>2</td></tr><tr class="even"><td><code>int</code></td><td>4</td></tr><tr class="odd"><td><code>long</code></td><td>8</td></tr></tbody></table><p>而整型数据的存储都是类似的，也就是以二进制方式进行存储，所以很容易理解，但是与日常使用的二进制数不同的是，在计算机储存中，为了方便地计算加减法，我们实际储存的是二进制数的 补码<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>:</p><p><strong>示例</strong></p><p>下面写几个简单 int 类型数字的在计算机中的二进制储存方式：</p><table><thead><tr class="header"><th>十进制</th><th>二进制（<code>int</code>）</th></tr></thead><tbody><tr class="odd"><td>10</td><td>00000000 00000000 00000000 00001010</td></tr><tr class="even"><td>-10</td><td>11111111 11111111 11111111 11110110</td></tr><tr class="odd"><td>0</td><td>00000000 00000000 00000000 00000000</td></tr></tbody></table><p><strong>注：</strong>字符型（即 <code>char</code>）的存储方式和整数型一致，只不过仅占一个字节</p><h3 id="浮点型数据的储存">浮点型数据的储存</h3><p>浮点型数据由于有了小数点，小数点后的位数甚至可能是无穷的，那么此时我们就无法再采用和整型数据存储相同的方式了，必须有一种新的存储方法</p><p>浮点型数据最常见的有 <code>float</code> 和 <code>double</code> ，两种数据类型分别占4字节和8字节</p><p>所以，要在固定的位数中表示出各种浮点数，计算机中采取了如下方案：</p><p>下面以 <code>float</code> 为例进行说明：</p><p>从左到右：第一个 <code>bit</code> 为符号位，接下来的8个 <code>bit</code> 为整数位，后 23 个 <code>bit</code> 为小数位，依次为<span class="math inline">\(2^{-1}, 2^{-2}, ...\)</span> ,如下图所示：</p><figure><img src="http://t1.aixinxi.net/o_1d1vscgvl1nbm1k3d1j2o5e01jbpa.png-j.jpg" alt="示意图"><figcaption>示意图</figcaption></figure><p>所表示的数字，由以下方式叠加：<span class="math inline">\((-1)^m * 1.XXXX * 2^{exp-127}\)</span></p><p><strong>说明：</strong></p><ol type="1"><li><code>XXX</code> 为小数位所表示的数字</li><li><code>exp</code> 为整数位数字的大小</li><li>综上所述，<code>float</code> 可表示从 $2^{-127} $ 到 <span class="math inline">\(2^{128}\)</span>的数字</li></ol><section class="footnotes"><hr><ol><li id="fn1"><p>二进制的表示方式，具体计算方法为：正数补码不变，负数的补码等于反码加一<a href="#fnref1" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制是计算机的基础，数据的存储在底层看来均是由二进制来表示的，那么如何用二进制来表示各种数据呢？此时就需要设计出一套完整的科学的储存方案&lt;/p&gt;
&lt;h3 id=&quot;整型数据的存储&quot;&gt;整型数据的存储&lt;/h3&gt;
&lt;p&gt;整型数据包括 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; 等，其中最为常用的便是 &lt;code&gt;int&lt;/code&gt; ，在目前的系统中（32位和64位编译器，以C语言为主要实例），其所占字节如下：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="底层" scheme="http://yoursite.com/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>pygame初探</title>
    <link href="http://yoursite.com/2018/11/29/pygame%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2018/11/29/pygame初探/</id>
    <published>2018-11-29T07:22:46.000Z</published>
    <updated>2018-12-06T09:01:13.239Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>想写小游戏的心早就有了，但是一直觉得额外学习一门语言的GUI编程好像不是很划算，今年趁着看了点 python 的内容，所以想试试用python来写，在过程中了解到python有一个专门的库——pygame ，所以就看了点教程，以下权当做个笔记</p><h3 id="初识-pygame">初识 pygame</h3><p>pygame最小开发框架主要包含两个方面 —— 引入库和初始化，主循环和刷新</p><a id="more"></a><ul><li>引入主要是引入自己要用到的库</li><li>初始化主要是初始化窗体，主要包括窗体的大小，窗体的名称，图标等等</li><li>主循环主要是接收操作，逻辑判断，事件处理和刷新游戏等</li></ul><p>根据教程的壁球小游戏，我直接贴上老师的代码：</p><h4 id="初始化部分">初始化部分</h4><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> pygame, sys</span><br><span class="line"><span class="hljs-keyword">from</span> pygame.locals <span class="hljs-keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 初始化 pygame</span></span><br><span class="line">pygame.init()</span><br><span class="line"><span class="hljs-comment"># 获取系统屏幕尺寸大小</span></span><br><span class="line">sysSize = pygame.display.Info()</span><br><span class="line">size = width, height = <span class="hljs-number">400</span>, <span class="hljs-number">600</span></span><br><span class="line">speed = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]</span><br><span class="line">BLACK = <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 创建屏幕对象并设定尺寸</span></span><br><span class="line">screen = pygame.display.set_mode(size)</span><br><span class="line"><span class="hljs-comment"># 屏幕大小可调节</span></span><br><span class="line"><span class="hljs-comment"># screen = pygame.display.set_mode(size, pygame.RESIZABLE)</span></span><br><span class="line"><span class="hljs-comment"># 屏幕无边框</span></span><br><span class="line"><span class="hljs-comment"># screen = pygame.display.set_mode(size, pygame.NOFRAME)</span></span><br><span class="line"><span class="hljs-comment"># 全屏模式</span></span><br><span class="line"><span class="hljs-comment"># screen = pygame.display.set_mode(sysSize, pygame.FULLSCREEN)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 设置窗体显示 一般为游戏名称</span></span><br><span class="line">pygame.display.set_caption(<span class="hljs-string">"壁球"</span>)</span><br><span class="line">icon = pygame.image.load(<span class="hljs-string">"F:\\PYG02-ball.gif"</span>)</span><br><span class="line"><span class="hljs-comment"># 设置窗体图标</span></span><br><span class="line">pygame.display.set_icon(icon)</span><br></pre></td></tr></table></figure><ul><li>首先，<code>pygame.init()</code>代表初始化pygame，也就是所有用pygame写的第一句代码</li><li>之后可以看到初始化部分主要依托于<code>pygame.XXX()</code>的属性设置来完成，具体属性见代码注释<ul><li>比如：<code>pygame.display.set_mode()</code> 来设置窗体大小</li><li><code>pygame.display.set_caption()</code> 来设置窗体名称</li><li><code>pygame.display.set_icon(icon)</code> 设置窗体图标 等等……</li><li><code>pygame.display.Info()</code> 来获取系统，也就是自己电脑的屏幕尺寸大小</li></ul></li></ul><h4 id="主循环和刷新">主循环和刷新</h4><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 载入球图片 保存为一个 Surface 对象</span></span><br><span class="line">ball = pygame.image.load(<span class="hljs-string">"F:\\PYG02-ball.gif"</span>)</span><br><span class="line"><span class="hljs-comment"># 调用 get_rect() 方法 返回覆盖图像的矩形 Rect 对象</span></span><br><span class="line"><span class="hljs-comment"># Rect 对象具有 上下左右宽高 等属性</span></span><br><span class="line">ballRect = ball.get_rect()</span><br><span class="line">fps = <span class="hljs-number">500</span></span><br><span class="line">fClock = pygame.time.Clock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># while True 为游戏主体循环</span></span><br><span class="line">running = <span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-keyword">while</span> running:</span><br><span class="line">    <span class="hljs-comment"># 从队列中取出事件</span></span><br><span class="line">    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():</span><br><span class="line">        <span class="hljs-keyword">if</span> event.type == pygame.QUIT:</span><br><span class="line">            sys.exit()</span><br><span class="line">        <span class="hljs-comment"># 按键操控</span></span><br><span class="line">        <span class="hljs-keyword">elif</span> event.type == KEYDOWN:</span><br><span class="line">            <span class="hljs-keyword">if</span> event.key == K_ESCAPE:</span><br><span class="line">                running = <span class="hljs-literal">False</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> event.key == K_LEFT:</span><br><span class="line">                speed[<span class="hljs-number">0</span>] = speed[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> speed[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (abs(speed[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>) * int(speed[<span class="hljs-number">0</span>]/abs(speed[<span class="hljs-number">0</span>]))</span><br><span class="line">            <span class="hljs-keyword">elif</span> event.key == K_RIGHT:</span><br><span class="line">                speed[<span class="hljs-number">0</span>] = speed[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> speed[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> speed[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> event.key == K_DOWN:</span><br><span class="line">                speed[<span class="hljs-number">1</span>] = speed[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> speed[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (abs(speed[<span class="hljs-number">1</span>]) - <span class="hljs-number">1</span>) * int(speed[<span class="hljs-number">1</span>]/abs(speed[<span class="hljs-number">1</span>]))</span><br><span class="line">            <span class="hljs-keyword">elif</span> event.key == K_UP:</span><br><span class="line">                speed[<span class="hljs-number">1</span>] = speed[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> speed[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> speed[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># 如果改变了窗体大小</span></span><br><span class="line">        <span class="hljs-keyword">elif</span> event.type == pygame.VIDEORESIZE:</span><br><span class="line">            size = width, height = event.size[<span class="hljs-number">0</span>], event.size[<span class="hljs-number">1</span>]</span><br><span class="line">            screen = pygame.display.set_mode(size, pygame.RESIZABLE)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 判断窗体是否被最小化</span></span><br><span class="line">    <span class="hljs-keyword">if</span> pygame.display.get_active():</span><br><span class="line">        <span class="hljs-comment"># 调用move方法移动矩形</span></span><br><span class="line">        ballRect = ballRect.move(speed[<span class="hljs-number">0</span>], speed[<span class="hljs-number">1</span>])</span><br><span class="line">    <span class="hljs-comment"># 判断 反弹</span></span><br><span class="line">    <span class="hljs-keyword">if</span> ballRect.left &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> ballRect.right &gt; width:</span><br><span class="line">        speed[<span class="hljs-number">0</span>] = -speed[<span class="hljs-number">0</span>]</span><br><span class="line">    <span class="hljs-keyword">if</span> ballRect.top &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> ballRect.bottom &gt; height:</span><br><span class="line">        speed[<span class="hljs-number">1</span>] = -speed[<span class="hljs-number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 填充窗口背景</span></span><br><span class="line">    screen.fill(BLACK)</span><br><span class="line">    <span class="hljs-comment"># 使小球绘制在矩形框内</span></span><br><span class="line">    screen.blit(ball, ballRect)</span><br><span class="line">    pygame.display.update()</span><br><span class="line">    <span class="hljs-comment"># 控制帧速度</span></span><br><span class="line">    fClock.tick(fps)</span><br></pre></td></tr></table></figure><ul><li>载入图片，之后会保存为<code>surface</code> 对象，因此载入的图片可以运用其方法和属性</li><li><code>for event in pygame.event.get():</code> pygame 中的事件都储存在队列中，需要逐次取出<ul><li><code>event.type == KEYDOWN</code> 表示按下某个键，在此判断内，可以进而匹配是按下了什么键</li></ul></li><li><code>screen.fill(BLACK)</code> 窗口的背景色，直接可以传RGB值</li><li><code>pygame.display.update()</code> 刷新画面，适用于变换场景简单的画面</li><li><code>fClock.tick(fps)</code> 控制帧率</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想写小游戏的心早就有了，但是一直觉得额外学习一门语言的GUI编程好像不是很划算，今年趁着看了点 python 的内容，所以想试试用python来写，在过程中了解到python有一个专门的库——pygame ，所以就看了点教程，以下权当做个笔记&lt;/p&gt;
&lt;h3 id=&quot;初识-pygame&quot;&gt;初识 pygame&lt;/h3&gt;
&lt;p&gt;pygame最小开发框架主要包含两个方面 —— 引入库和初始化，主循环和刷新&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="小游戏" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>进阶查找</title>
    <link href="http://yoursite.com/2018/11/25/%E8%BF%9B%E9%98%B6%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2018/11/25/进阶查找/</id>
    <published>2018-11-25T12:16:48.000Z</published>
    <updated>2019-03-30T07:51:20.539Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>当数组（或其他查找的对象）是杂乱无章之时，或许查找起来就会比较困难，甚至只能一个一个找。但是，当数据是有序的之后，查找数据就有更为省时的算法了</p><h3 id="二分查找">二分查找</h3><p>二分查找也被称之为折半查找，其绝对是应用最为广泛也的查找算法了，其 <span class="math inline">\(log(N)\)</span> 的时间复杂度也是相当优秀，所以其名声也是相当大，以至于我在很久之前就听说过此算法并写了一篇博文，可以点击<a href="https://wenmang.github.io/2018/04/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" target="_blank" rel="noopener">链接</a>直接跳转</p><a id="more"></a><h3 id="插值查找">插值查找</h3><p><strong>插值查找</strong>是在二分查找的基础上改进产生的，其大致思路如下：当我们查字典时，如果首字母为 <code>a</code> ，我们必然不会往中间翻，而是翻向靠前的页数，所以，当我们进行查找之时，也可以根据具体情况进行镶银的调整</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> size,<span class="hljs-keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>; </span><br><span class="line">    <span class="hljs-keyword">int</span> R = size - <span class="hljs-number">1</span>; </span><br><span class="line">    <span class="hljs-keyword">while</span>( L &lt;= R) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> mid = L + (R-L) * (p-a[L]) / a[R] - a[L]; </span><br><span class="line">        <span class="hljs-keyword">if</span>( p == a[mid] )</span><br><span class="line">            <span class="hljs-keyword">return</span> mid;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( p &gt; a[mid])</span><br><span class="line">            L = mid + <span class="hljs-number">1</span>; </span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            R = mid - <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol type="1"><li>插值查找的实质就是 根据key值于表中最大最小值比较后的查找方法，其核心为插值计算公式——<span class="math inline">\(\frac {key-a[low]} {a[hight]- {a[long]}}\)</span></li><li>其对于较为均匀排列的查找表有更好的效率，而对极端不均匀的数据来说可能不是很好的选择</li></ol><h3 id="斐波那契查找">斐波那契查找</h3><p>既然有了二分查找这样的思路，二分查找是以中间作为划分的，插值查找是依据插值计算公式进行划分的，那么我们同样可以试图采用别的划分方法，比如：<strong>斐波那契数列</strong></p><p><strong>代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FibSearsh</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> F[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">21</span>, <span class="hljs-number">34</span>, <span class="hljs-number">55</span>, <span class="hljs-number">89</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">int</span> low = <span class="hljs-number">1</span>, high = n, mid, i, k = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (n &gt; F[k] - <span class="hljs-number">1</span>)</span><br><span class="line">        k++;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = n; i &lt; F[k] - <span class="hljs-number">1</span>; i++)</span><br><span class="line">        a[i] = a[n];</span><br><span class="line">    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = low + F[k<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">            high = mid - <span class="hljs-number">1</span>;</span><br><span class="line">            k -= <span class="hljs-number">1</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; a[mid]) &#123;</span><br><span class="line">            low = mid + <span class="hljs-number">1</span>;</span><br><span class="line">            k -= <span class="hljs-number">2</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (mid &lt;= n)</span><br><span class="line">                <span class="hljs-keyword">return</span> mid;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                <span class="hljs-keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树">二叉搜索树</h3><p>这是利用二叉树来进行查找的算法，相关内容可点击<a href="https://wenmang.github.io/2018/08/02/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" target="_blank" rel="noopener">链接</a>直接跳转</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当数组（或其他查找的对象）是杂乱无章之时，或许查找起来就会比较困难，甚至只能一个一个找。但是，当数据是有序的之后，查找数据就有更为省时的算法了&lt;/p&gt;
&lt;h3 id=&quot;二分查找&quot;&gt;二分查找&lt;/h3&gt;
&lt;p&gt;二分查找也被称之为折半查找，其绝对是应用最为广泛也的查找算法了，其 &lt;span class=&quot;math inline&quot;&gt;\(log(N)\)&lt;/span&gt; 的时间复杂度也是相当优秀，所以其名声也是相当大，以至于我在很久之前就听说过此算法并写了一篇博文，可以点击&lt;a href=&quot;https://wenmang.github.io/2018/04/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;直接跳转&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>普通查找</title>
    <link href="http://yoursite.com/2018/11/20/%E6%99%AE%E9%80%9A%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2018/11/20/普通查找/</id>
    <published>2018-11-20T06:16:26.000Z</published>
    <updated>2019-03-30T06:43:57.788Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>查找是一类重要的算法，尤其是在现今的大数据时代来看更是如此，选择一个好的查找算法往往可以起到事倍功半的效果</p><h3 id="顺序表查找">顺序表查找</h3><p>顺序表查找是最为简单也是最为笨重的一类查找，其遵循的理念就是一个一个找。当需要在顺序表中查找一元素时，需要做的就是从头到尾对表进行一次遍历，直到找到结果为止</p><a id="more"></a><p><strong>代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SequentialSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="hljs-keyword">if</span> (a[i] == key)</span><br><span class="line">            <span class="hljs-keyword">return</span> i;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进版顺序查找">改进版顺序查找</h3><p>为了使顺序表在每次查找之前不进行不必要的判断是否越界，我们可以利用 “哨兵” 法，在数组的开头或者末尾之前设置一个 “哨兵” ，查找至哨兵位置直接返回没找到即可</p><p><strong>代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SequentialSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>;</span><br><span class="line">    a[<span class="hljs-number">0</span>] = key</span><br><span class="line">    <span class="hljs-keyword">while</span> (a[i--] != key);</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这样写返回 <code>0</code> 表示没有找到</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查找是一类重要的算法，尤其是在现今的大数据时代来看更是如此，选择一个好的查找算法往往可以起到事倍功半的效果&lt;/p&gt;
&lt;h3 id=&quot;顺序表查找&quot;&gt;顺序表查找&lt;/h3&gt;
&lt;p&gt;顺序表查找是最为简单也是最为笨重的一类查找，其遵循的理念就是一个一个找。当需要在顺序表中查找一元素时，需要做的就是从头到尾对表进行一次遍历，直到找到结果为止&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>排序进阶</title>
    <link href="http://yoursite.com/2018/11/15/%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/11/15/排序进阶/</id>
    <published>2018-11-15T14:51:39.000Z</published>
    <updated>2018-12-06T08:59:02.444Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="开始之前">开始之前</h3><p>进阶排序是对一些特殊情况下排序的处理方式，也是非常重要的一些排序方法</p><h3 id="表排序">表排序</h3><ul><li>当数据不再是简单的数字或者字符，而是一些比较大的元素，例如文件等，那么这时在之前介绍的排序中所采取方式就会产生很大的时间复杂度 —— 因为文件的移动是需要时间的，而且需要不短的一段时间，我们普通的排序所采取的不停<code>Swap</code>的操作，就会使时间大大增加</li></ul><a id="more"></a><h4 id="间接排序">间接排序</h4><ul><li>那么此时，我们可以采取间接排序的方式，也就是在结构体中添加一个属性，将之进行简单排序，来作为数据的真实顺序</li></ul><table><thead><tr class="header"><th style="text-align: center;">A</th><th style="text-align: center;">[0]</th><th style="text-align: center;">[1]</th><th style="text-align: center;">[2]</th><th style="text-align: center;">[3]</th><th style="text-align: center;">[4]</th><th style="text-align: center;">[5]</th><th style="text-align: center;">[6]</th><th style="text-align: center;">[7]</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">key</td><td style="text-align: center;">f</td><td style="text-align: center;">d</td><td style="text-align: center;">c</td><td style="text-align: center;">a</td><td style="text-align: center;">g</td><td style="text-align: center;">b</td><td style="text-align: center;">h</td><td style="text-align: center;">e</td></tr><tr class="even"><td style="text-align: center;">table</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td></tr></tbody></table><ul><li>对<code>table</code>根据<code>key</code>值进行排序即可</li></ul><table><thead><tr class="header"><th style="text-align: center;">A</th><th style="text-align: center;">[0]</th><th style="text-align: center;">[1]</th><th style="text-align: center;">[2]</th><th style="text-align: center;">[3]</th><th style="text-align: center;">[4]</th><th style="text-align: center;">[5]</th><th style="text-align: center;">[6]</th><th style="text-align: center;">[7]</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">key</td><td style="text-align: center;">f</td><td style="text-align: center;">d</td><td style="text-align: center;">c</td><td style="text-align: center;">a</td><td style="text-align: center;">g</td><td style="text-align: center;">b</td><td style="text-align: center;">h</td><td style="text-align: center;">e</td></tr><tr class="even"><td style="text-align: center;">table</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">7</td><td style="text-align: center;">0</td><td style="text-align: center;">4</td><td style="text-align: center;">6</td></tr></tbody></table><ul><li>排序完成后结果如上，这时如果要求按顺序输出元素，就可按照<code>A[table[i]]</code> `i取值为0~n-1</li></ul><h4 id="物理排序">物理排序</h4><ul><li>如果明确要求需要对数据进行物理排序的话，那么我们就可以在表排序的基础之上对数据进行交换</li><li>首先我们将<code>A[0]</code>取出，赋给临时值<code>temp</code>，之后寻找<code>A[table[0]]</code>，将之移动到空位上，依次寻找并移动</li><li>因有定理：<strong>N个数字的排列由若干个独立的环组成</strong>，所以我们将每个环都一次移动一遍就好</li><li>那么如何判断一个环已经全部排列整齐呢？我们可以将已排列好的环的<code>table</code>值改为<code>A</code>的下标值，所以<code>if(table[i] == i)</code>为<code>true</code>之时，就说明此环已经被排列整齐</li></ul><h4 id="物理排序复杂度分析">物理排序复杂度分析</h4><ul><li>最好情况：有序，不用交换</li><li>最坏情况：每个环都只有两个元素</li></ul><h3 id="桶排序">桶排序</h3><ul><li>采用传统交换的排序，其时间下限为<span class="math inline">\(O(Nlog(N))\)</span> ，就算是最快的排序也总能找到一个特例，使其最坏时间复杂度为<span class="math inline">\(O(Nlog(N))\)</span></li><li>那么就无法让排序变为线性复杂度吗？</li></ul><p>例：有N(N = 50000)个学生，考试成绩为 0 - 100 ，那么此时将学生的考试成绩排序，怎样排序最快呢？</p><p>这时我们可以采用桶排序，将时间复杂度提升到线性时间：</p><ul><li>因为人数极多，而分数只有101种可能，所以我们可以先建立101个桶（指针数组）</li><li>遍历每个学生的成绩，将其放在对应的桶下</li><li>依次输出每个桶内的学生，排序完成</li></ul><h4 id="实现思路">实现思路</h4><p>桶排序的一般实现思路：</p><ul><li>在数据种类小而数据规模大时使用</li><li>为所有可能出现的数据种类建桶，将数据分别放入对应的桶中</li><li>从桶中取出并进行之后的操作</li></ul><p>那么，如果数据规模不大，但是种类比较多，又该如何操作呢？</p><h3 id="基数排序">基数排序</h3><p>假设有10个整数，数字在0到999之间，这时应该怎样使用基数排序呢？</p><ul><li>次位优先法进行排序</li><li>在一个数中，个位被称为该数的次位，最高位称为主位</li></ul><h4 id="实例说明">实例说明</h4><p>例：有数字 64， 8， 216， 512， 27， 729 ，0， 1， 343， 125</p><ul><li>因为是十进制数字，所以我们建立0-9十个桶</li></ul><table><thead><tr class="header"><th>0</th><th>1</th><th>2</th><th>3</th><th style="text-align: left;">4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr class="odd"><td>0</td><td>1</td><td>512</td><td>343</td><td style="text-align: left;">64</td><td>125</td><td>216</td><td>27</td><td>8</td><td>729</td></tr></tbody></table><ul><li>第一次排列，根据个位（次位）数字，将之放入相应的桶中</li></ul><table><thead><tr class="header"><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr class="odd"><td>0</td><td>512</td><td>125</td><td></td><td>343</td><td></td><td>64</td><td></td><td></td><td></td></tr><tr class="even"><td>1</td><td>216</td><td>27</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>8</td><td></td><td>729</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>第二次排列，在第一次的基础上按照十位数字将元素放入相应的桶中</li></ul><table><thead><tr class="header"><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr class="odd"><td>0</td><td>125</td><td>216</td><td>343</td><td></td><td>512</td><td></td><td>729</td><td></td><td></td></tr><tr class="even"><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>8</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>27</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>64</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>第三次排列，按照百位数字放入相应的桶中，排序完毕</li><li>用的时候，直接将元素按次序从桶中依次取出即可</li></ul><h4 id="实现思路-1">实现思路</h4><ul><li>显然，我们首先要知道最高位的位数，以便知晓我们应该进行几趟排序</li><li>之后就是每一趟将元素依次放入桶中即可</li></ul><p><strong>次位优先</strong></p><ul><li>实现需要创建桶的结构体</li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_DIGIT 4</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REDIX 10</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 桶元素结点 */</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">PtrToNode</span>;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">/* 桶头结点 */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeadNode</span>&#123;</span></span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeadNode</span> <span class="hljs-title">Bucket</span>[<span class="hljs-title">REDIX</span>];</span></span><br></pre></td></tr></table></figure><ul><li><code>REDIX</code>表示需要排序数字的进制，<code>MAX_DIGIT</code>表示排序数字的最高位数</li><li>之后，因为要根据每一位的数字来放置，所以需要一个取固定位 数字的函数</li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetDit</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> tmp, i;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= d; ++i) &#123;</span><br><span class="line">        tmp = x % REDIX;</span><br><span class="line">        x /= REDIX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>准备工作做完之后，就可以进行排序了</li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LSDRadixSort</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> d, di, i;</span><br><span class="line">    Bucket bucket;</span><br><span class="line">    PtrToNode tmp, p, <span class="hljs-built_in">list</span> = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; REDIX; ++i) <span class="hljs-comment">// 初始化桶</span></span><br><span class="line">        bucket[i].head = bucket[i].tail = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;   <span class="hljs-comment">// 将数组逆序存入list链表</span></span><br><span class="line">        tmp = (PtrToNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node));</span><br><span class="line">        tmp-&gt;key = a[i];</span><br><span class="line">        tmp-&gt;next = <span class="hljs-built_in">list</span>;</span><br><span class="line">        <span class="hljs-built_in">list</span> = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (d = <span class="hljs-number">1</span>; d &lt;= MAX_DIGIT; ++d) &#123;<span class="hljs-comment">// 排序</span></span><br><span class="line">        p = <span class="hljs-built_in">list</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (p) &#123;<span class="hljs-comment">// 将 list 按顺序放入桶中</span></span><br><span class="line">            di = GetDit(p-&gt;key, d);</span><br><span class="line">            tmp = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (bucket[di].head == <span class="hljs-literal">NULL</span>)</span><br><span class="line">                bucket[di].head = bucket[di].tail = tmp;</span><br><span class="line">            <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                bucket[di].tail-&gt;next = tmp;</span><br><span class="line">                bucket[di].tail = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">list</span> = <span class="hljs-literal">NULL</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (di = REDIX<span class="hljs-number">-1</span>; di &gt;= <span class="hljs-number">0</span>; di--) &#123;<span class="hljs-comment">// 将桶中数字按顺序放回 list 中</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (bucket[di].head) &#123;</span><br><span class="line">                bucket[di].tail-&gt;next = <span class="hljs-built_in">list</span>;</span><br><span class="line">                <span class="hljs-built_in">list</span> = bucket[di].head;</span><br><span class="line">                bucket[di].head = bucket[di].tail = <span class="hljs-literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<span class="hljs-comment">// 将排序完成的list重新赋值给a数组</span></span><br><span class="line">        tmp = <span class="hljs-built_in">list</span>;</span><br><span class="line">        <span class="hljs-built_in">list</span> = <span class="hljs-built_in">list</span>-&gt;next;</span><br><span class="line">        a[i] = tmp-&gt;key;</span><br><span class="line">        <span class="hljs-built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主位优先</strong></p><ul><li>该算法采用递归的方式实现，初始化部分和之前一致，只是后面有点差异</li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MSD</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> di, i, j;</span><br><span class="line">    Bucket bucket;</span><br><span class="line">    PtrToNode tmp, p, <span class="hljs-built_in">list</span> = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; REDIX; ++i)</span><br><span class="line">        bucket[i].head = bucket[i].tail = <span class="hljs-literal">NULL</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = l; l &lt;= r; ++l) &#123;</span><br><span class="line">        tmp = (PtrToNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Node));</span><br><span class="line">        tmp-&gt;key = a[i];</span><br><span class="line">        tmp-&gt;next = <span class="hljs-built_in">list</span>;</span><br><span class="line">        <span class="hljs-built_in">list</span> = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="hljs-built_in">list</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p) &#123;</span><br><span class="line">        di = GetDit(p-&gt;key, d);</span><br><span class="line">        tmp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="hljs-keyword">if</span> (bucket[di].head == <span class="hljs-literal">NULL</span>)</span><br><span class="line">            bucket[di].tail = tmp;</span><br><span class="line">        tmp-&gt;next = bucket[di].head;</span><br><span class="line">        bucket[di].head = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    i = j = l;</span><br><span class="line">    <span class="hljs-keyword">for</span> (di = <span class="hljs-number">0</span>; di &lt; REDIX; ++di) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (bucket[di].head) &#123;</span><br><span class="line">            p = bucket[di].head;</span><br><span class="line">            <span class="hljs-keyword">while</span> (p) &#123;</span><br><span class="line">                tmp = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                a[j++] = tmp-&gt;key;</span><br><span class="line">                <span class="hljs-built_in">free</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            MSD(a, i, j<span class="hljs-number">-1</span>, d<span class="hljs-number">-1</span>);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MSDRadixSort</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MSD(a, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, MAX_DIGIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上</p><h4 id="基数排序的应用">基数排序的应用</h4><p>在有多个条件之时，可以先按照一个条件将之进行简单的归类，再逐个类进行排序，最后将其合并</p><hr><h3 id="总结">总结</h3><p>排序算法的探究到这里就告一段落了，我们对所有排序的时间复杂度和空间复杂度，以及其是否稳定进行一次统计总结：</p><table><thead><tr class="header"><th>排序方法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>额外空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr class="odd"><td>简单选择排序</td><td><span class="math inline">\(O(N^2)\)</span></td><td><span class="math inline">\(O(N^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td></tr><tr class="even"><td>冒泡排序</td><td>$O(N^ 2 ) $</td><td><span class="math inline">\(O(N^2 )\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>稳定</td></tr><tr class="odd"><td>直接插入排序</td><td><span class="math inline">\(O(N^ 2)\)</span></td><td><span class="math inline">\(O(N^ 2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>稳定</td></tr><tr class="even"><td>希尔排序</td><td><span class="math inline">\(O(N^ d)\)</span></td><td><span class="math inline">\(O(N^ 2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td></tr><tr class="odd"><td>堆排序</td><td><span class="math inline">\(O(Nlog N)\)</span></td><td><span class="math inline">\(O(Nlog N)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td></tr><tr class="even"><td>快速排序</td><td><span class="math inline">\(O(Nlog N)\)</span></td><td><span class="math inline">\(O(N^ 2)\)</span></td><td><span class="math inline">\(O(log N)\)</span></td><td>不稳定</td></tr><tr class="odd"><td>归并排序</td><td><span class="math inline">\(O(Nlog N)\)</span></td><td><span class="math inline">\(O(Nlog N)\)</span></td><td><span class="math inline">\(O( N)\)</span></td><td>稳定</td></tr><tr class="even"><td>基数排序</td><td><span class="math inline">\(O(P(N+B))\)</span></td><td><span class="math inline">\(O(P(N+B))\)</span></td><td><span class="math inline">\(O(N+B)\)</span></td><td>稳定</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开始之前&quot;&gt;开始之前&lt;/h3&gt;
&lt;p&gt;进阶排序是对一些特殊情况下排序的处理方式，也是非常重要的一些排序方法&lt;/p&gt;
&lt;h3 id=&quot;表排序&quot;&gt;表排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当数据不再是简单的数字或者字符，而是一些比较大的元素，例如文件等，那么这时在之前介绍的排序中所采取方式就会产生很大的时间复杂度 —— 因为文件的移动是需要时间的，而且需要不短的一段时间，我们普通的排序所采取的不停&lt;code&gt;Swap&lt;/code&gt;的操作，就会使时间大大增加&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>改进排序</title>
    <link href="http://yoursite.com/2018/11/08/%E6%94%B9%E8%BF%9B%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/11/08/改进排序/</id>
    <published>2018-11-08T06:39:01.000Z</published>
    <updated>2018-12-06T09:00:09.745Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在了解了简单排序之后，我们仍不满足简单排序的效率，在此驱动之下，又有效率更高的排序算法被设计出来</p><h3 id="希尔排序">希尔排序</h3><p>在学习了冒泡和插入排序之后，我们发现，对于同一数列而言，采用冒泡排序和采用插入排序所进行的交换次数是一致的，进而可以得知，排序实际是消除逆序对的过程，由此我们可以有以下思路</p><a id="more"></a><h4 id="实现思路">实现思路</h4><ul><li>冒泡和插入排序每次只消除一个逆序对</li><li><p>既然排序是为了消除逆序对，那么能不能通过一次交换消除多个逆序对呢</p></li><li>显然，我们可以采用隔几个数字的方式来进行排序，这样一来，进行一次交换就可消除不止一个逆序对</li><li><p>结和以上思路，便实现了希尔排序的一般实现方式</p></li></ul><h4 id="代码1">代码1</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-comment">// 希尔1</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i, j, k;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = n/<span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i /= <span class="hljs-number">2</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (j = i; j &lt; n; j++) &#123;</span><br><span class="line">            ELEMENT_TYPE temp = a[j];</span><br><span class="line">            <span class="hljs-keyword">for</span> (k = j; k &gt;= i &amp;&amp; a[k - i] &gt; temp; k -= i)</span><br><span class="line">                a[k] = a[k - i];</span><br><span class="line">            a[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的希尔排序如上，也就是分别隔<code>n/2``n/4</code>…… 直至<code>n = 1</code></p><p>但是采用这种方法可能出现尴尬的情况</p><table><thead><tr class="header"><th style="text-align: center;">1</th><th style="text-align: center;">9</th><th style="text-align: center;">2</th><th style="text-align: center;">10</th><th style="text-align: center;">3</th><th style="text-align: center;">11</th><th style="text-align: center;">4</th><th style="text-align: center;">12</th><th style="text-align: center;">5</th><th style="text-align: center;">13</th><th style="text-align: center;">6</th><th style="text-align: center;">14</th><th style="text-align: center;">7</th><th style="text-align: center;">15</th><th style="text-align: center;">8</th><th style="text-align: center;">16</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">9</td><td style="text-align: center;">2</td><td style="text-align: center;">10</td><td style="text-align: center;">3</td><td style="text-align: center;">11</td><td style="text-align: center;">4</td><td style="text-align: center;">12</td><td style="text-align: center;">5</td><td style="text-align: center;">13</td><td style="text-align: center;">6</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">15</td><td style="text-align: center;">8</td><td style="text-align: center;">16</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">9</td><td style="text-align: center;">2</td><td style="text-align: center;">10</td><td style="text-align: center;">3</td><td style="text-align: center;">11</td><td style="text-align: center;">4</td><td style="text-align: center;">12</td><td style="text-align: center;">5</td><td style="text-align: center;">13</td><td style="text-align: center;">6</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">15</td><td style="text-align: center;">8</td><td style="text-align: center;">16</td></tr><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">9</td><td style="text-align: center;">2</td><td style="text-align: center;">10</td><td style="text-align: center;">3</td><td style="text-align: center;">11</td><td style="text-align: center;">4</td><td style="text-align: center;">12</td><td style="text-align: center;">5</td><td style="text-align: center;">13</td><td style="text-align: center;">6</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">15</td><td style="text-align: center;">8</td><td style="text-align: center;">16</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">8</td><td style="text-align: center;">9</td><td style="text-align: center;">10</td><td style="text-align: center;">11</td><td style="text-align: center;">12</td><td style="text-align: center;">13</td><td style="text-align: center;">14</td><td style="text-align: center;">15</td><td style="text-align: center;">16</td></tr></tbody></table><p>也就是数列刚好每隔<code>n/2``n/4</code>…… 都是排序完成的，那么扫描就成了无用功</p><p>发现上述问题之后，有专家就提出来一个交换间隔的数列</p><ul><li><p>Hibbard 增量序列</p><ul><li><span class="math inline">\(D_K\)</span> = <span class="math inline">\(2^k\)</span> - 1（<span class="math inline">\(D_k\)</span>为间隔数）</li><li>最坏情况：<span class="math inline">\(T = Θ{(N^{\frac{2}{3}})}\)</span></li><li>猜测：<span class="math inline">\(T_{avg} = O(N{\frac{5}{4}})\)</span></li></ul></li><li><p>Sedgewick增量序列</p><ul><li><p>{1, 5, 19, 41, 109, …}</p><p>—— <span class="math inline">\(9\times4^i - 9\times2^i + 1\)</span> 或者 <span class="math inline">\(4^i - 3\times2^i + 1\)</span></p></li><li><p>猜想：<span class="math inline">\(T_{avg} = O(N^\frac{7}{6})\)</span> , <span class="math inline">\(T_{worst} = O(N\frac{4}{3})\)</span></p></li></ul></li></ul><p>则改进后的代码为：（只写Sedgewick）</p><h4 id="代码2">代码2</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-comment">// 希尔2</span></span><br><span class="line">    <span class="hljs-keyword">int</span> si, i, j, k;</span><br><span class="line">    <span class="hljs-keyword">int</span> Sedgewick[] = &#123;<span class="hljs-number">929</span>, <span class="hljs-number">505</span>, <span class="hljs-number">20</span>, <span class="hljs-number">109</span>, <span class="hljs-number">41</span>, <span class="hljs-number">19</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">for</span> (si = <span class="hljs-number">0</span>; Sedgrwick[si] &gt;= N; si++) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (i = Sedgrwick[si]; i &gt; <span class="hljs-number">0</span>; i = Sedgrwick[++si]) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (j = i; j &lt; n; j++) &#123;</span><br><span class="line">                ELEMENT_TYPE temp = a[j];</span><br><span class="line">                <span class="hljs-keyword">for</span> (k = j; k &gt;= i &amp;&amp; a[k - i] &gt; temp; k -= i)</span><br><span class="line">                    a[k] = a[k - i];</span><br><span class="line">                a[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序">堆排序</h3><p>那么简单排序中的选择排序是否可以优化呢？答案是肯定的</p><h4 id="实现思路-1">实现思路</h4><ul><li>首先选择排序的外层循环是不可变的，优化的只能是内层循环，即寻找数列之中最小的元素的过程</li><li>选择排序中，此过程运用了遍历数组的方式，复杂度为 <span class="math inline">\(O(N)\)</span></li><li>而在之前，我们学习了堆的知识，所以我们可以利用最小堆来进行寻找</li></ul><h4 id="代码1-1">代码1</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// 堆</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i;</span><br><span class="line">    ELEMENT_TYPE tmpA;</span><br><span class="line">    BuildHeap(a);</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i)</span><br><span class="line">        tmpA = DeleteMin(a);</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++i)</span><br><span class="line">        a[i] = tmpA[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上代码，首先将<code>a</code>调整为一个最小堆</li><li>之后取出依次最小的元素置于一个新临时数组中</li><li>最后，将排好序的<code>tmpA</code>数组中的元素复制回原数组</li></ul><p>这样，虽然将时间复杂度降到了<span class="math inline">\(O(log(n))\)</span> ，但是空间复杂度提升了一倍，在数据量较大之时应用不是很方便</p><h4 id="代码2-1">代码2</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// 堆</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = N / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i)</span><br><span class="line">        PercDown(a, i, n);</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; --i) &#123;</span><br><span class="line">        Swap(&amp;a[<span class="hljs-number">0</span>], &amp;a[i]);</span><br><span class="line">        PercDown(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先通过第一个循环将其建为最大堆</li><li>将最大堆的根与<code>a[0]</code>交换，之后再将<code>a</code>调整为最大堆</li><li>重复2步骤，n次</li></ul><p>由定理可知，其平均比较次数为 <span class="math inline">\(2NlogN - O(Nlog(logN))\)</span></p><h3 id="归并排序">归并排序</h3><p>归并排序的核心就是有序子列的归并，也就是将两个已经排好序的数列，归并到一个更大的数列中去</p><h4 id="实现思路-2">实现思路</h4><ul><li>分别设立两个指针，从两个数组的开头扫到结尾，比较指针所在处数组的值，将小值复制到大数组中，之后将小值所在数组的指针后移一位</li><li>重复步骤一，直至所有数字都挪入大数组</li></ul><p>核心理解之后就可以进行排序了，也就是将需排序的数组拆分成若干已排序的小数组直接进行归并</p><h4 id="递归代码">递归代码</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rightEnd, <span class="hljs-keyword">int</span> temp[])</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> leftEnd = r<span class="hljs-number">-1</span> ;</span><br><span class="line">    <span class="hljs-keyword">int</span> left = l, tmp = l;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> (l &lt;= leftEnd &amp;&amp; r &lt;= rightEnd)&#123; <span class="hljs-comment">// 当左右子序列均不空</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (a[l] &gt; a[r])</span><br><span class="line">            temp[tmp++] = a[r++];</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            temp[tmp++] = a[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">while</span> (l &lt;= leftEnd)</span><br><span class="line">        temp[tmp++] = a[l++];</span><br><span class="line">    <span class="hljs-keyword">while</span> (r &lt;= rightEnd)</span><br><span class="line">        temp[tmp++] = a[r++];</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt; rightEnd + <span class="hljs-number">1</span>; i++)</span><br><span class="line">        a[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> rightEnd, <span class="hljs-keyword">int</span> temp[])</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> center;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &lt; rightEnd) &#123;</span><br><span class="line">        center = (l + rightEnd) / <span class="hljs-number">2</span>;</span><br><span class="line">        MergeSort(a, l, center, temp);</span><br><span class="line">        MergeSort(a, center + <span class="hljs-number">1</span>, rightEnd, temp);</span><br><span class="line">        Merge(a, l, center+<span class="hljs-number">1</span>, rightEnd, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span>* tmpA;</span><br><span class="line">    tmpA = <span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));</span><br><span class="line">    <span class="hljs-keyword">if</span> (tmpA != <span class="hljs-literal">NULL</span>)&#123;</span><br><span class="line">        MergeSort(a, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, tmpA);</span><br><span class="line">        <span class="hljs-built_in">free</span>(tmpA);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ERROR"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>三个函数，分别为归并函数，主函数，和接口函数</li><li>归并函数就是将两个有序数组归并为一个大数组</li><li>主函数起到将数组左边右边分别进行归并的作用，也就是当数组分割到只有一个元素之后，直接进行归并</li><li>接口函数为了使其符合排序函数的规律，仅传入数组及其长度</li></ul><h4 id="循环代码">循环代码</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],  <span class="hljs-keyword">int</span> temp[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> rightEnd)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> leftEnd = r<span class="hljs-number">-1</span> ;</span><br><span class="line">    <span class="hljs-keyword">int</span> left = l, tmp = l;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> (l &lt;= leftEnd &amp;&amp; r &lt;= rightEnd)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (a[l] &gt; a[r])</span><br><span class="line">            temp[tmp++] = a[r++];</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            temp[tmp++] = a[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">while</span> (l &lt;= leftEnd)</span><br><span class="line">        temp[tmp++] = a[l++];</span><br><span class="line">    <span class="hljs-keyword">while</span> (r &lt;= rightEnd)</span><br><span class="line">        temp[tmp++] = a[r++];</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt; rightEnd + <span class="hljs-number">1</span>; i++)</span><br><span class="line">        a[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergePass</span><span class="hljs-params">(ELEMENT_TYPE a[], ELEMENT_TYPE tmpA[], <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> i, j;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= n - <span class="hljs-number">2</span>*length; i += <span class="hljs-number">2</span>*length)</span><br><span class="line">        Merge(a, tmpA, i, i+length, n<span class="hljs-number">-1</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (i + length &lt; n)</span><br><span class="line">        Merge(a, tmpA, i, i+length, n<span class="hljs-number">-1</span>);</span><br><span class="line">    <span class="hljs-keyword">else</span> </span><br><span class="line">        <span class="hljs-keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">            tmpA[j] = a[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> length;</span><br><span class="line">    ELEMENT_TYPE* tmpA;</span><br><span class="line">    length = <span class="hljs-number">1</span>;</span><br><span class="line">    tmpA = <span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(ELEMENT_TYPE));</span><br><span class="line">    <span class="hljs-keyword">if</span> (tmpA != <span class="hljs-literal">NULL</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (length &lt; n) &#123;</span><br><span class="line">            MergePass(a, tmpA, n, length);</span><br><span class="line">            length *= <span class="hljs-number">2</span>;</span><br><span class="line">            MergePass(a, tmpA, n, length);</span><br><span class="line">            length *= <span class="hljs-number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">free</span>(tmpA);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"空间不足"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的递归可以用循环代替，所以也就有了上面的代码</p><ul><li>即先将数组元素，相邻的两个一对进行归并</li><li>之后相邻的元素便排序完成，再四个一对进行归并，同理，之后就是八个……</li></ul><h3 id="快速排序">快速排序</h3><p>快排是很有名的一个排序算法，在许多语言的库函数中直接调用的排序函数就是快速排序，据说快排是在实际应用中最快的算法，其由归并排序衍生而来，也主要采用递归的方法来实现，其主要原理寻找主元和针对主元对数组进行调整的过程</p><h4 id="选主元">选主元</h4><p>主元的选择是快排中至关重要的一个环节，如果主元失误的话就整个排序就容易废掉，那么如何选取主元呢?</p><ul><li>随机选择主元，<code>rand()</code> 函数也是需要时间的</li><li>取数组头，中，尾三个数字中的中位数</li><li>等等 等等……</li></ul><p>这里采取选取三者中位数的方式来选取主元</p><p><strong>代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">ELEMENT_TYPE <span class="hljs-title">Media3</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> center = (left + right) / <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (a[left] &gt; a[center])</span><br><span class="line">        Swap(&amp;a[left], &amp;a[center]);</span><br><span class="line">    <span class="hljs-keyword">if</span> (a[left] &gt; a[right])</span><br><span class="line">        Swap(&amp;a[left], &amp;a[right]);</span><br><span class="line">    <span class="hljs-keyword">if</span> (a[center] &gt; a[right])</span><br><span class="line">        Swap(&amp;a[center], &amp;a[right]);</span><br><span class="line"></span><br><span class="line">    Swap(&amp;a[center], &amp;a[right<span class="hljs-number">-1</span>]);</span><br><span class="line">    <span class="hljs-keyword">return</span> a[right<span class="hljs-number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>功能就是将三个数排列，并将中位数置于<code>right-1</code>的位置，并返回主元</li></ul><h4 id="子集划分">子集划分</h4><ul><li>子集划分主要由两个 “指针” 从两端进行查找，将比主元小的元素调整到数组左边，比主元大的元素调整到数组的右边</li><li>之后将主元移动到数组固定的位置</li></ul><p>在子集划分之后，采用递归处理， 将数组左边进行快排，右边进行快排</p><p>了解了子集划分之后，就又有了新的问题，因为快排的实现方式是采用递归的方法，所以对于小规模数据的排序可能还不如插入排序，所以我们应该设置一个阈值，在数据量低于此阈值的情况下直接采用插入排序</p><p><strong>代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QSort</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> pivot, cutoff = <span class="hljs-number">10000</span>, low, high;</span><br><span class="line">    <span class="hljs-keyword">if</span> (cutoff &lt;= right - left) &#123;</span><br><span class="line">        pivot = Media3(a, left, right);</span><br><span class="line">        low = left;</span><br><span class="line">        high = right <span class="hljs-number">-1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (; ;) &#123;</span><br><span class="line">            <span class="hljs-keyword">while</span> (a[++low] &lt; a[right<span class="hljs-number">-1</span>]);</span><br><span class="line">            <span class="hljs-keyword">while</span> (a[--high] &gt; a[right<span class="hljs-number">-1</span>]);</span><br><span class="line">            <span class="hljs-keyword">if</span> (low &lt; high)</span><br><span class="line">                Swap(&amp;a[low], a[high]);</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Swap(&amp;a[low], &amp;a[right<span class="hljs-number">-1</span>]);</span><br><span class="line">        QSort(a, left, low<span class="hljs-number">-1</span>);</span><br><span class="line">        QSort(a, low+<span class="hljs-number">1</span>, right);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span></span><br><span class="line">        InsertionSort(a+left, right-left+<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此段代码最精髓之处我觉得是采用两个<code>while</code>循环进行子集划分的操作，很帅</li><li><code>pivot</code>为主元 <code>cutoff</code>为阈值 我将其设为1000</li></ul><p>之后对接口进行统一化处理</p><p><strong>代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    QSort(a, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解了简单排序之后，我们仍不满足简单排序的效率，在此驱动之下，又有效率更高的排序算法被设计出来&lt;/p&gt;
&lt;h3 id=&quot;希尔排序&quot;&gt;希尔排序&lt;/h3&gt;
&lt;p&gt;在学习了冒泡和插入排序之后，我们发现，对于同一数列而言，采用冒泡排序和采用插入排序所进行的交换次数是一致的，进而可以得知，排序实际是消除逆序对的过程，由此我们可以有以下思路&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>简单排序</title>
    <link href="http://yoursite.com/2018/11/03/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/11/03/简单排序/</id>
    <published>2018-11-03T07:24:29.000Z</published>
    <updated>2018-12-06T09:00:46.072Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>排序可以说是相当常用的一类数据处理方式，而进行排序的方法也是多种多样的，此文主要记录经典的排序算法，并阐明基本原理</p><h3 id="开始之前">开始之前</h3><ul><li>所有的排序算法以函数形式展现，采用C语言编写</li><li>函数风格统一，命名规则同<code>ASort</code>，A为排序方法名称，首字母大写，传参均仅传入数组及其大小，函数类型为<code>void</code>，即直接将原数组进行排序</li><li>所有排序的终点，也就时排序后的结果，为从大到小排序</li></ul><a id="more"></a><p>为了让排序更好的进行，首先编写交换函数，即<code>Swap()</code>函数</p><p><strong>代码：</strong></p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELEMENT_TYPE int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(ELEMENT_TYPE *x, ELEMENT_TYPE *y)</span> </span>&#123;</span><br><span class="line">    ELEMENT_TYPE temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><p>冒泡排序可谓是相当经典的一个排序算法，记得自己大一面试学校社团之时，学长让第一个去了解的排序算法就是冒泡算法</p><h4 id="实现思路">实现思路</h4><ul><li>冒泡，顾名思义，就是将需排序的元素，看作大小不同的泡泡进行处理</li><li>首先将数组进行一趟从头至尾的扫描，遇到后者比前者大的元素，就将二者交换，一趟扫描之后，最大的元素实现沉底</li><li>那么只需要扫描n趟，就可让数组排列整齐</li></ul><p>结合上述思路，我们可以写出以下代码：</p><h4 id="代码1">代码1</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123; <span class="hljs-comment">// 冒泡</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="hljs-keyword">if</span> (a[j] &gt; a[j+<span class="hljs-number">1</span>])</span><br><span class="line">                Swap(&amp;a[j], &amp;a[j+<span class="hljs-number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码相当简单，但是还可进行优化</li><li>因为冒泡排序过程中，有可能只进行小于n趟就已经排序完成，之后的扫描都属于无用功，所以加一标记，使其在扫描一趟的过程中，若无元素交换，则直接结束循环</li></ul><h4 id="代码2">代码2</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123; <span class="hljs-comment">// 冒泡</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (a[j] &gt; a[j+<span class="hljs-number">1</span>]) &#123;</span><br><span class="line">                Swap(&amp;a[j], &amp;a[j+<span class="hljs-number">1</span>]);</span><br><span class="line">                flag = <span class="hljs-number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，其最好情况为<code>O(N)</code>，而最坏情况为<code>O(N^2)</code></p><h3 id="插入排序">插入排序</h3><p>插入排序也是简单排序的一种，也是比较常见的一种算法</p><h4 id="实现思路-1">实现思路</h4><ul><li>为了更好地理解插入算法，我们引入打牌时的实例</li><li>打牌时，为方便出牌，我们一般将牌有顺序地拿着，当摸一张牌时，我们会与手中已排序完成的牌进行比较，以插入到合适的位置</li><li>插入排序也是模拟了这一过程，首先假设数组中的首个元素已经 “拿在手中” ，之后将数组中的元素依次取出，进行插入</li></ul><h4 id="代码">代码</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertionSort</span><span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-comment">// 插入</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i, j;</span><br><span class="line">    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ELEMENT_TYPE temp = a[i];</span><br><span class="line">        <span class="hljs-keyword">for</span> (j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j<span class="hljs-number">-1</span>] &gt; temp; j--)</span><br><span class="line">            a[j] = a[j<span class="hljs-number">-1</span>];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码在插入的时候是从后往前比较的，也就是从<code>i</code>到<code>0</code></li><li>插入排序无需进行数字的交换，某种程度来说代码量是少于冒泡的</li><li>其最好情况为<code>O(N)</code>，而最坏情况为<code>O(N^2)</code></li></ul><h3 id="选择排序">选择排序</h3><p>提到简单排序，就不得不说选择排序</p><h4 id="实现思路-2">实现思路</h4><ul><li>选择排序很好理解，就是首先遍历一遍数组，找到，该数组中最小的元素，与数组首位元素进行交换</li><li>这种交换需要进行<code>n</code>次，所以遍历也会进行<code>n</code>次</li></ul><h4 id="代码-1">代码</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span> <span class="hljs-params">(ELEMENT_TYPE a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-comment">// 选择</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> min = i;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (a[j] &lt; a[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        Swap(&amp;a[min], &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>选择排序的时间复杂度是恒定的，无所谓最好最坏，均为 <code>O(N^2)</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序可以说是相当常用的一类数据处理方式，而进行排序的方法也是多种多样的，此文主要记录经典的排序算法，并阐明基本原理&lt;/p&gt;
&lt;h3 id=&quot;开始之前&quot;&gt;开始之前&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有的排序算法以函数形式展现，采用C语言编写&lt;/li&gt;
&lt;li&gt;函数风格统一，命名规则同&lt;code&gt;ASort&lt;/code&gt;，A为排序方法名称，首字母大写，传参均仅传入数组及其大小，函数类型为&lt;code&gt;void&lt;/code&gt;，即直接将原数组进行排序&lt;/li&gt;
&lt;li&gt;所有排序的终点，也就时排序后的结果，为从大到小排序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
