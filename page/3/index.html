<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>文的盲</title><meta name="description"><meta name="author" content="文盲"><meta name="copyright" content="文盲"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://yoursite.com/page/3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="website"><meta property="og:title" content="文的盲"><meta property="og:url" content="http://yoursite.com/page/3/"><meta property="og:site_name" content="文的盲"><meta property="og:description"><meta property="og:image" content="http://yoursite.com/img/avatar.jpg"><meta property="article:published_time" content="2020-08-30T15:31:30.010Z"><meta property="article:modified_time" content="2020-08-30T15:31:30.010Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?368a5ed7d73f0d4d2bd25d9682f37580";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: undefined,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isSidebar: false,
  postUpdate: '2020-08-30 23:31:30'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="文的盲" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">51</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">文的盲</a></span><span class="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="site-info"><h1 id="site_title">文的盲</h1><div id="site_subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/wenmang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xdwenmang@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://wenmang.github.io" target="_blank" title="Rss"><i class="fas fa-rss"></i></a></div></div><div id="scroll_down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout_page" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/07/29/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E7%BB%83%E4%B9%A0/" title="栈的应用及练习">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈的应用及练习"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/07/29/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8A%E7%BB%83%E4%B9%A0/" title="栈的应用及练习">栈的应用及练习</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-07-29T13:03:06.000Z" title="发表于 2019-07-29 21:03:06">2019-07-29</time></span></div><div class="content"><!-- hexo-inject:begin --><!-- hexo-inject:end -->既然学了栈这种数据结构，那么就应该进一步深入或者熟练地应用。这也构成了两种不同的应用方式：

一种是利用栈这种数据结构，来实现一些其他的数据结构，比如：用栈来实现队列，或者是实现一些特殊的栈，比如：最小栈。
另一种是具体问题的解决，比如经典的逆波兰表达式的求解等一系列问题


闲话部分——在线提交
为什么要在线提交？答案很简单，就是保证自己代码的完全正确性。
怎么理解呢，就是说，你写完一个程序之后，应该仅仅会想出一组或者部分样例来进行测试代码运行结果是否符合自己的预期，但是自己想出来的这些样例往往是不完备的，而在线提交平台的样例基本是完备的，尤其是一些著名的提交平台。
那么有哪些平台可以选择呢？

我个人的喜好是 LeetCode ，由于网速和英语不好的原因，我选择了其中文网站，如果想练习英语，也可以进其英文官网。
还有其他类似的平台，牛客啊啥的，可凭自己喜好进行选择。

栈的应用
LeetCode 还有比较好的一点就是可以按照标签进行刷题，而网站的题量也在稳步上升，而关于栈的应用，我特意选了这么几道有代表性的题：

最小栈
逆波兰表达式求值
二叉 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/07/22/%E5%A0%86%E6%A0%88/" title="堆栈">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="堆栈"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/07/22/%E5%A0%86%E6%A0%88/" title="堆栈">堆栈</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-07-22T05:00:00.000Z" title="发表于 2019-07-22 13:00:00">2019-07-22</time></span></div><div class="content">堆栈是一种数据项按序排列的数据结构，只能在一端（称为栈顶(top)）对数据项进行插入和删除。
简单地说，堆栈可以看作一个箱子，只能在一端放和取，所以其主要操作有：

插入数据：入栈（Push）
删除数据：出栈（Pop）


而只能一端存取，也形成了其最主要的特性：

后入先出：Last In First Out（LIFO）

类型名称：堆栈（Stack）
数据对象集：一个有0个或多个元素的有穷线性表
操作集：长度为 MaxSize 的堆栈 S 属于 Stack ， 堆栈元素 item 属于 ElementType
123451. Stack CreateStack  ()						生成空堆栈2. int IsFull (Stack S)							判断堆栈S是否已满3. void Push (Stack PtrS, ElementType item)		 将元素item压入堆栈4. int IsEmpty (Stack S)					    判断堆栈S是否为空5. ElementType Pop (Stack PtrS)					删除堆栈并返回栈顶元素 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/03/29/%C2%96%E4%BB%A5stack%E6%9D%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B3%9B%E5%9E%8B/" title="以stack来进一步了解C语言的泛型">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="以stack来进一步了解C语言的泛型"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/03/29/%C2%96%E4%BB%A5stack%E6%9D%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BA%86%E8%A7%A3C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B3%9B%E5%9E%8B/" title="以stack来进一步了解C语言的泛型">以stack来进一步了解C语言的泛型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-03-29T14:34:44.000Z" title="发表于 2019-03-29 22:34:44">2019-03-29</time></span></div><div class="content">此篇博文根据斯坦福公开课 《编程范式》整理，也算是一个简单的笔记。
Stack（栈）
栈是一种十分基础的数据结构，也十分简单，下面我们首先来实现此种数据结构的int表示

stack.h
在此文件之中，我们对栈的结构和栈的基本操作进行了定义，其中代码如下：
12345678910typedef struct &#123;    int* elems;    int logLength;    int allocLength;&#125;stack;void StackNew(stack* s);void StackDispose(stack* s);void StackPush(stack* s, int value);int StackPop(stack* s);
stack.c
此文件中，将 .h 文件中的函数进行了实现，代码如下：
123456void StackNew(stack* s) &#123;    s-&gt;allocLength = 4;    s-&gt;logLength = 0;    s-&gt;elems = malloc(sizeof ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2019/03/05/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%9B%E5%9E%8B/" title="C语言实现简单的泛型">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言实现简单的泛型"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/03/05/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%9B%E5%9E%8B/" title="C语言实现简单的泛型">C语言实现简单的泛型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-03-05T07:02:34.000Z" title="发表于 2019-03-05 15:02:34">2019-03-05</time></span></div><div class="content">众所周知，C语言是不支持泛型的，但可以利用C语言自身的语法特点来实现此特性。而此篇博文根据斯坦福公开课 《编程范式》整理，以阐述用C语言实现此种特性的大致思路，也算是一个简单的笔记。
从 Swap 谈起

交换函数应该是最常见也是最常用的函数之一，C语言的交换函数一般这样写：
12345void Swap (int *p, int *q) &#123;    int tmp = *p;    *p = *q;    *q = tmp;&#125;
但是如上代码仅能对 int 类型数据进行交换，如果要交换 double 或者其他类型的数据又需要写一段极其相似的代码（仅将 int 换掉），而这样无疑是不够简练的，代码也不够优美。所以我们考虑写一个能交换所有数据类型的函数，以简练代码，提高效率。
既然有这样的想法，那么我们试着去实现它。既然要普适所以数据类型，那么我们就需要向本源出发去寻找。无论什么类型的数据，在计算机底层都是以二进制储存的，这我们就找到了所有不同类型数据的共同点，也就有了设计思路：

在内存中找到两个数据的地址
从头至尾，将两个数据的每一个字节进行交换
 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2019/01/24/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/" title="数据在内存中的存储">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据在内存中的存储"></a></div><div class="recent-post-info"><a class="article-title" href="/2019/01/24/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/" title="数据在内存中的存储">数据在内存中的存储</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2019-01-24T10:21:02.000Z" title="发表于 2019-01-24 18:21:02">2019-01-24</time></span></div><div class="content">二进制是计算机的基础，数据的存储在底层看来均是由二进制来表示的，那么如何用二进制来表示各种数据呢？此时就需要设计出一套完整的科学的储存方案
整型数据的存储
整型数据包括 short, int, long 等，其中最为常用的便是 int ，在目前的系统中（32位和64位编译器，以C语言为主要实例），其所占字节如下：




数据类型
所占字节




short
2


int
4


long
8



而整型数据的存储都是类似的，也就是以二进制方式进行存储，所以很容易理解，但是与日常使用的二进制数不同的是，在计算机储存中，为了方便地计算加减法，我们实际储存的是二进制数的 补码1:
示例
下面写几个简单 int 类型数字的在计算机中的二进制储存方式：



十进制
二进制（int）




10
00000000 00000000 00000000 00001010


-10
11111111 11111111 11111111 11110110


0
00000000 00000000  ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2018/11/29/pygame%E5%88%9D%E6%8E%A2/" title="pygame初探">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pygame初探"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/11/29/pygame%E5%88%9D%E6%8E%A2/" title="pygame初探">pygame初探</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2018-11-29T07:22:46.000Z" title="发表于 2018-11-29 15:22:46">2018-11-29</time></span></div><div class="content">想写小游戏的心早就有了，但是一直觉得额外学习一门语言的GUI编程好像不是很划算，今年趁着看了点 python 的内容，所以想试试用python来写，在过程中了解到python有一个专门的库——pygame ，所以就看了点教程，以下权当做个笔记
初识 pygame
pygame最小开发框架主要包含两个方面 —— 引入库和初始化，主循环和刷新


引入主要是引入自己要用到的库
初始化主要是初始化窗体，主要包括窗体的大小，窗体的名称，图标等等
主循环主要是接收操作，逻辑判断，事件处理和刷新游戏等

根据教程的壁球小游戏，我直接贴上老师的代码：
初始化部分
1234567891011121314151617181920212223242526import pygame, sysfrom pygame.locals import *# 初始化 pygamepygame.init()# 获取系统屏幕尺寸大小sysSize = pygame.display.Info()size = width, height = 400, 600speed = [1, 1]BLACK = 25 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2018/11/25/%E8%BF%9B%E9%98%B6%E6%9F%A5%E6%89%BE/" title="进阶查找">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进阶查找"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/11/25/%E8%BF%9B%E9%98%B6%E6%9F%A5%E6%89%BE/" title="进阶查找">进阶查找</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2018-11-25T12:16:48.000Z" title="发表于 2018-11-25 20:16:48">2018-11-25</time></span></div><div class="content">当数组（或其他查找的对象）是杂乱无章之时，或许查找起来就会比较困难，甚至只能一个一个找。但是，当数据是有序的之后，查找数据就有更为省时的算法了
二分查找
二分查找也被称之为折半查找，其绝对是应用最为广泛也的查找算法了，其 \(log(N)\) 的时间复杂度也是相当优秀，所以其名声也是相当大，以至于我在很久之前就听说过此算法并写了一篇博文，可以点击链接直接跳转

插值查找
插值查找是在二分查找的基础上改进产生的，其大致思路如下：当我们查字典时，如果首字母为 a ，我们必然不会往中间翻，而是翻向靠前的页数，所以，当我们进行查找之时，也可以根据具体情况进行镶银的调整
1234567891011121314int BinarySearch(int a[],int size,int p) &#123;    int L = 0;     int R = size - 1;     while( L &lt;= R) &#123;        int mid = L + (R-L) * (p-a[L]) / a[R] - a[L];         if( p == a[mid] ) ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2018/11/20/%E6%99%AE%E9%80%9A%E6%9F%A5%E6%89%BE/" title="普通查找">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="普通查找"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/11/20/%E6%99%AE%E9%80%9A%E6%9F%A5%E6%89%BE/" title="普通查找">普通查找</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2018-11-20T06:16:26.000Z" title="发表于 2018-11-20 14:16:26">2018-11-20</time></span></div><div class="content">查找是一类重要的算法，尤其是在现今的大数据时代来看更是如此，选择一个好的查找算法往往可以起到事倍功半的效果
顺序表查找
顺序表查找是最为简单也是最为笨重的一类查找，其遵循的理念就是一个一个找。当需要在顺序表中查找一元素时，需要做的就是从头到尾对表进行一次遍历，直到找到结果为止

代码：
123456int SequentialSearch(int* a, int n, int key) &#123;    for (int i = 0; i &lt; n; i++)        if (a[i] == key)            return i;    return -1;&#125;
改进版顺序查找
为了使顺序表在每次查找之前不进行不必要的判断是否越界，我们可以利用 “哨兵” 法，在数组的开头或者末尾之前设置一个 “哨兵” ，查找至哨兵位置直接返回没找到即可
代码：
123456int SequentialSearch(int* a, int n, int key) &#123;    int i = n - 1;    a[0] = key    whil ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2018/11/15/%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6/" title="排序进阶">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序进阶"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/11/15/%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6/" title="排序进阶">排序进阶</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2018-11-15T14:51:39.000Z" title="发表于 2018-11-15 22:51:39">2018-11-15</time></span></div><div class="content">开始之前
进阶排序是对一些特殊情况下排序的处理方式，也是非常重要的一些排序方法
表排序

当数据不再是简单的数字或者字符，而是一些比较大的元素，例如文件等，那么这时在之前介绍的排序中所采取方式就会产生很大的时间复杂度 —— 因为文件的移动是需要时间的，而且需要不短的一段时间，我们普通的排序所采取的不停Swap的操作，就会使时间大大增加


间接排序

那么此时，我们可以采取间接排序的方式，也就是在结构体中添加一个属性，将之进行简单排序，来作为数据的真实顺序




A
[0]
[1]
[2]
[3]
[4]
[5]
[6]
[7]




key
f
d
c
a
g
b
h
e


table
0
1
2
3
4
5
6
7




对table根据key值进行排序即可




A
[0]
[1]
[2]
[3]
[4]
[5]
[6]
[7]




key
f
d
c
a
g
b
h
e


table
3
5
2
 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2018/11/08/%E6%94%B9%E8%BF%9B%E6%8E%92%E5%BA%8F/" title="改进排序">     <img class="post_bg" data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="改进排序"></a></div><div class="recent-post-info"><a class="article-title" href="/2018/11/08/%E6%94%B9%E8%BF%9B%E6%8E%92%E5%BA%8F/" title="改进排序">改进排序</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2018-11-08T06:39:01.000Z" title="发表于 2018-11-08 14:39:01">2018-11-08</time></span></div><div class="content">在了解了简单排序之后，我们仍不满足简单排序的效率，在此驱动之下，又有效率更高的排序算法被设计出来
希尔排序
在学习了冒泡和插入排序之后，我们发现，对于同一数列而言，采用冒泡排序和采用插入排序所进行的交换次数是一致的，进而可以得知，排序实际是消除逆序对的过程，由此我们可以有以下思路

实现思路

冒泡和插入排序每次只消除一个逆序对
既然排序是为了消除逆序对，那么能不能通过一次交换消除多个逆序对呢
显然，我们可以采用隔几个数字的方式来进行排序，这样一来，进行一次交换就可消除不止一个逆序对
结和以上思路，便实现了希尔排序的一般实现方式

代码1
1234567891011void ShellSort(ELEMENT_TYPE a[], int n) &#123;   // 希尔1    int i, j, k;    for (i = n/2; i &gt; 0; i /= 2) &#123;        for (j = i; j &lt; n; j++) &#123;            ELEMENT_TYPE temp = a[j];            ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">文盲</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length_num">51</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length_num">23</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wenmang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wenmang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xdwenmang@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://wenmang.github.io" target="_blank" title="Rss"><i class="fas fa-rss"></i></a></div></div></div><div class="sticky_layout"><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">我的博客</div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/" title="计算机网络传输层"><img data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络传输层"/></a><div class="content"><a class="title" href="/2020/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/" title="计算机网络传输层">计算机网络传输层</a><time datetime="2020-08-30T07:36:13.000Z" title="发表于 2020-08-30 15:36:13">2020-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络应用层"><img data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络应用层"/></a><div class="content"><a class="title" href="/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络应用层">计算机网络应用层</a><time datetime="2020-05-01T06:56:33.000Z" title="发表于 2020-05-01 14:56:33">2020-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" title="计算机网络概述"><img data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络概述"/></a><div class="content"><a class="title" href="/2020/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" title="计算机网络概述">计算机网络概述</a><time datetime="2020-04-27T06:11:39.000Z" title="发表于 2020-04-27 14:11:39">2020-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/01/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E5%88%99/" title="二分查找细则"><img data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二分查找细则"/></a><div class="content"><a class="title" href="/2020/01/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E5%88%99/" title="二分查找细则">二分查找细则</a><time datetime="2020-01-10T13:47:55.000Z" title="发表于 2020-01-10 21:47:55">2020-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2019/11/22/%E8%8A%B1%E9%87%8C%E8%83%A1%E5%93%A8%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/" title="花里胡哨的位运算"><img data-lazy-src="https://i.loli.net/2020/08/30/rKtH1fxmLVdzJTl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="花里胡哨的位运算"/></a><div class="content"><a class="title" href="/2019/11/22/%E8%8A%B1%E9%87%8C%E8%83%A1%E5%93%A8%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/" title="花里胡哨的位运算">花里胡哨的位运算</a><time datetime="2019-11-22T10:45:25.000Z" title="发表于 2019-11-22 18:45:25">2019-11-22</time></div></div></div></div></div><div class="card-widget card-tags"><div class="card-content"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 1.1em; color: #999">AI</a> <a href="/tags/C/" style="font-size: 1.17em; color: #999c9f">C</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.3em; color: #99a1ac">C语言</a> <a href="/tags/Java/" style="font-size: 1.1em; color: #999">Java</a> <a href="/tags/c/" style="font-size: 1.1em; color: #999">c</a> <a href="/tags/python/" style="font-size: 1.1em; color: #999">python</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 1.17em; color: #999c9f">刷题</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.5em; color: #99a9bf">博客</a> <a href="/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/" style="font-size: 1.1em; color: #999">小游戏</a> <a href="/tags/%E5%BA%95%E5%B1%82/" style="font-size: 1.3em; color: #99a1ac">底层</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 1.17em; color: #999c9f">教程</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.43em; color: #99a6b9">数据结构</a> <a href="/tags/%E6%9C%89%E8%B6%A3/" style="font-size: 1.1em; color: #999">有趣</a> <a href="/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/" style="font-size: 1.1em; color: #999">模式识别</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.23em; color: #999ea6">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" style="font-size: 1.17em; color: #999c9f">算法基础</a> <a href="/tags/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" style="font-size: 1.1em; color: #999">算法思想</a> <a href="/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/" style="font-size: 1.23em; color: #999ea6">算法技巧</a> <a href="/tags/%E7%BB%83%E4%B9%A0/" style="font-size: 1.17em; color: #999c9f">练习</a> <a href="/tags/%E7%BB%86%E8%8A%82/" style="font-size: 1.1em; color: #999">细节</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.23em; color: #999ea6">计算机网络</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 1.17em; color: #999c9f">链表</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 1.37em; color: #99a4b2">随笔</a></div></div></div><div class="card-widget card-archives"><div class="card-content"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/08/"><span class="card-archive-list-date">八月 2020</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/05/"><span class="card-archive-list-date">五月 2020</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/04/"><span class="card-archive-list-date">四月 2020</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/01/"><span class="card-archive-list-date">一月 2020</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2019/11/"><span class="card-archive-list-date">十一月 2019</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2019/10/"><span class="card-archive-list-date">十月 2019</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2019/09/"><span class="card-archive-list-date">九月 2019</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2019/08/"><span class="card-archive-list-date">八月 2019</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item more is-center"><a class="card-archive-list-link-more" href="/archives">
              <span>查看更多</span><i class="fas fa-angle-right"  ></i></a></li></ul></div></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By 文盲</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    var typed = new Typed("#subtitle", {
      strings: "游戏已到了关底，空虚是最后结局".split(","),
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '游'
  }
}

if (true) {
  if (typeof Typed === 'function') subtitleType()
  else $.getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js', subtitleType)
} else {
  subtitleType()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>